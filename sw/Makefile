############################################################################
# TOP Level Makefile
# SYNOPSIS:
#
#   make [all]  - makes everything
#   make TARGET - makes the given target (TODO)
#   make clean  - removes all files generated by make
#   make env    - sets up the environment
############################################################################

############################################################################
# Include the project specific configuration
############################################################################
TP_PRODUCT		?= linux
TP_MCU_FAMILY	?= posix
TARGET			?= rel

include project_files/$(TP_PRODUCT)/target.mk

############################################################################
# Define whether display the message on running, enable for debug purpose
ifeq ($(VERBOSE),1)
  Q =
else
  Q = @
endif

#===========================================================================
# debug build with full assert
ifeq "$(TARGET)" "dbg"
TARGET_FLAGS	+= -DUSE_FULL_ASSERT
else
TARGET_FLAGS	+= -DNDEBUG
endif

#===========================================================================
# Output filename
# output executable name
ELF		:= $(TARGET)/a.elf
EXEC	:= $(TARGET)/tp.hex

# map file name
MAP_FILE:= $(TARGET)/a.map

# environment variable export file
ENV_FILE:= tp_env.sh

#===========================================================================
# Compiler for STM32, Windows IAR compiler
ifeq "$(TP_MCU_FAMILY)" "stm32"
  IAR	:= "/cygdrive/c/Program Files (x86)/IAR Systems/Embedded Workbench 7.0"
  CC		:= $(IAR)/arm/bin/iccarm.exe
  LD		:= $(IAR)/arm/bin/ilinkarm.exe
  STRIP	:= $(IAR)/arm/bin/ielftool.exe $(STRIPFLAGS) $(ELF) $(EXEC)
  qp_dir	:= common/qp/ports/stm32
endif

# Compiler for destop linux build
ifeq "$(TP_MCU_FAMILY)" "posix"
  CC		:= gcc
  LD		:= gcc
  STRIP	:= strip $(STRIPFLAGS) $(ELF) -o $(EXEC)
  qp_dir	:= common/qp/ports/posix/gnu
endif

#===========================================================================
# Unit-test top directory
UT_PARSE := TP_SW_TOP=$(CURDIR) TP_PRODUCT=$(TP_PRODUCT) TP_MCU_FAMILY=$(TP_MCU_FAMILY)

############################################################################
# builtin commands mapping
############################################################################
AWK		?= awk
GCC		?= gcc
GREP	?= grep
MKDIR	?= mkdir -p
MV		?= mv -f
PR		?= pr
RM		?= rm -f
SED		?= sed
SORT	?= sort

############################################################################
# Function definition
############################################################################
# $(call make-depend,source-file,object-file,depend-file)
# create the dependency file (.d) by gcc
define make-depend
  $(GCC) -MM -MF $3 -MP -MT $2 $(CFLAGS) $(CPPFLAGS) $1
endef

# $(call target-object, source-file)
# convert the source file name to object file name
target-object = $(addprefix $(TARGET)/, 	\
				 $(sort						\
				  $(patsubst %.c,%.o,		\
				   $(notdir $1))))

# $(compile-rules)
# replace the generic %.o:%.c for building all targets in a separate folder
define compile-rules
  $(foreach f, $(sort $(sources)),\
   $(call one-compile-rule,$f))
endef

# $(call one-compile-rule, source-files)
# replace the generic %.o:%.c for building all targets in a separate folder
define one-compile-rule
$(call target-object,$1): $1
	$(call make-depend,$$<,$$@,$$(subst .o,.d,$$@))
	$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_FLAGS) $$< -o $$@

endef

# $(call macro-depend, macro, depend-macro)
# if macro is defined, it requested depend-macro to be defined as well
define macro-depend
  ifneq "$(filter $1,$(TP_FEATURE))" ""
    TP_FEATURE += $2
  endif
endef

# $(call add-module, macro, module)
# if macro is defined, the module need to be built
define add-module
  ifneq "$(filter $1,$(TP_FEATURE))" ""
    modules += $2
  endif
endef

############################################################################
# Collect information from each module in these four variables.
# Initialize them here as simple variables.
############################################################################
# modules: defines the folder with modules.mk for including more sources to be built
modules		:=
# sources: files to be compiled
sources		:= $(plat_file)

# objects and dependencies deduced from sources
objects		 = $(call target-object,$(sources))
dependencies = $(subst .o,.d,$(objects))

# flags for platform build
CFLAGS		+= -c
CPPFLAGS	+= $(addprefix -I,$(include_dirs)) -I$(qp_dir)
LDFLAGS		+= -L$(qp_dir)/$(TARGET)

# add the include paths to vpath
vpath $(include_dirs)

all:

############################################################################
# Map macro dependency
#   for example: uartDrv depend ringbuf, so if HAS_UART is defined, HAS_RINGBUF need to be defined
#   for example: if a audio driver is defined, its server and transport protocol should be defined
############################################################################
$(eval $(call macro-depend,HAS_MENU,HAS_DELEGATES))

$(eval $(call macro-depend,HAS_BLE_CTRL,HAS_DEBUG))

$(eval $(call macro-depend,HAS_DEBUG,HAS_CRC))
$(eval $(call macro-depend,HAS_DEBUG,HAS_UART))
$(eval $(call macro-depend,HAS_DEBUG,HAS_RINGBUF))

$(eval $(call macro-depend,HAS_ADC_KEY,HAS_ADC))
$(eval $(call macro-depend,HAS_GPIO_KEY,HAS_GPIO))
$(eval $(call macro-depend,HAS_NEC_IR,HAS_IR_RECEIVER))

$(eval $(call macro-depend,HAS_ADC,HAS_TPQSORT))
$(eval $(call macro-depend,HAS_UART,HAS_RINGBUF))

$(eval $(call macro-depend,HAS_ADAU1761,HAS_I2C))
$(eval $(call macro-depend,HAS_CS42526,HAS_I2C))
$(eval $(call macro-depend,HAS_TLV320AIC3254,HAS_I2C))
$(eval $(call macro-depend,HAS_ADAU1761,HAS_AUDIO_CONTROL))

#===========================================================================
# Map macro to modules
#   add the required modules to the target if the corresponding macro is defined
#===========================================================================
# Delegates
$(eval $(call add-module,HAS_DELEGATES,ui_layer/delegate))
$(eval $(call add-module,HAS_IR_LEARNING,ui_layer/delegate))
$(eval $(call add-module,HAS_POWER_DELEGATE,ui_layer/delegate))
# Server
$(eval $(call add-module,HAS_AUDIO_CONTROL,driver/DSP_Driver))
$(eval $(call add-module,HAS_AUDIO_CONTROL,driver/audio_driver))
$(eval $(call add-module,HAS_AUDIO_CONTROL,server/audio_server))

$(eval $(call add-module,HAS_BLUETOOTH,driver/bluetooth_driver))
$(eval $(call add-module,HAS_BLUETOOTH,server/bt_server))

$(eval $(call add-module,HAS_DISPLAY,driver/display_driver))
$(eval $(call add-module,HAS_DISPLAY,server/display_server))

$(eval $(call add-module,HAS_DEBUG,server/ds_server))

$(eval $(call add-module,HAS_KEYS,driver/key_driver))
$(eval $(call add-module,HAS_KEYS,server/key_server))

$(eval $(call add-module,HAS_LEDS,driver/led_driver))
$(eval $(call add-module,HAS_LEDS,server/led_server))

$(eval $(call add-module,HAS_POWER_CONTROL,driver/power_driver))
$(eval $(call add-module,HAS_POWER_CONTROL,server/power_server))

$(eval $(call add-module,HAS_SETTING,driver/storage_driver))
$(eval $(call add-module,HAS_SETTING,server/setting_server))
$(eval $(call add-module,HAS_LIGHT_SETTING_SRV,server/setting_server))

$(eval $(call add-module,HAS_DEBUGSETT,driver/storage_driver))
$(eval $(call add-module,HAS_DEBUGSETT,server/dss_server))

# Driver
$(eval $(call add-module,HAS_CRC,common/crc16_lib))
$(eval $(call add-module,HAS_RINGBUF,common/datatype/ringbuf))
$(eval $(call add-module,HAS_TPQSORT,common/sort_lib))

$(eval $(call add-module,HAS_ADC,driver/adc_driver))
$(eval $(call add-module,HAS_GPIO,driver/gpio_driver))
$(eval $(call add-module,HAS_I2C,driver/i2c_driver))
$(eval $(call add-module,HAS_IR_RECEIVER,driver/ir_receiver_driver))
$(eval $(call add-module,HAS_IR_LEARNING,driver/ir_receiver_driver))
$(eval $(call add-module,HAS_UART,driver/uart_driver))
$(eval $(call add-module,LED_HAS_IOEXPANDER,driver/led_driver))
$(eval $(call add-module,LED_HAS_IOEXPANDER,driver/ioexpander_driver))

ifeq "$(TP_MCU_FAMILY)" "stm32"
  STARTUP_PATH:= bsp/stm32/Libraries/CMSIS/ST/STM32F0xx/Source
  modules		+= bsp/stm32/Libraries/STM32F0xx_StdPeriph_Driver/src
  objects		+= $(TARGET)/startup_stm32f0xx.o
endif

############################################################################
# QP files
QEP	:= common/qp/qep/source
QF	:= common/qp/qf/source
sources   	+= $(QEP)/qep.c
sources   	+= $(QEP)/qfsm_dis.c
sources   	+= $(QEP)/qfsm_ini.c
sources   	+= $(QEP)/qhsm_dis.c
sources   	+= $(QEP)/qhsm_in.c
sources   	+= $(QEP)/qhsm_ini.c
sources   	+= $(QEP)/qhsm_top.c
sources   	+= $(QEP)/qmsm_dis.c
sources   	+= $(QEP)/qmsm_ini.c
sources   	+= $(QF)/qa_ctor.c
sources   	+= $(QF)/qa_defer.c
sources   	+= $(QF)/qa_fifo.c
sources   	+= $(QF)/qa_get_.c
sources   	+= $(QF)/qa_lifo.c
sources   	+= $(QF)/qa_sub.c
sources   	+= $(QF)/qa_usub.c
sources   	+= $(QF)/qa_usuba.c
sources   	+= $(QF)/qeq_fifo.c
sources   	+= $(QF)/qeq_get.c
sources   	+= $(QF)/qeq_init.c
sources   	+= $(QF)/qeq_lifo.c
sources   	+= $(QF)/qf_act.c
sources   	+= $(QF)/qf_gc.c
sources   	+= $(QF)/qf_log2.c
sources   	+= $(QF)/qf_new.c
sources   	+= $(QF)/qf_pool.c
sources   	+= $(QF)/qf_psini.c
sources   	+= $(QF)/qf_pspub.c
sources   	+= $(QF)/qf_pwr2.c
sources   	+= $(QF)/qf_tick.c
sources   	+= $(QF)/qma_ctor.c
sources   	+= $(QF)/qmp_get.c
sources   	+= $(QF)/qmp_init.c
sources   	+= $(QF)/qmp_put.c
sources   	+= $(QF)/qte_arm.c
sources   	+= $(QF)/qte_ctor.c
sources   	+= $(QF)/qte_ctr.c
sources   	+= $(QF)/qte_darm.c
sources   	+= $(QF)/qte_rarm.c
ifeq "$(TP_MCU_FAMILY)" "stm32"
sources   	+= $(QF)/qvanilla.c
endif
ifeq "$(TP_MCU_FAMILY)" "posix"
sources   	+= $(qp_dir)/qf_port.c
include_dirs+= $(QF)
endif

############################################################################
# Include the make targets of the modules
include $(addsuffix /module.mk,$(modules))

############################################################################
# mkdir the output directory
create-output-directory := $(shell $(MKDIR) $(TARGET);)

############################################################################
# Rules
############################################################################
.PHONY: all env help clean ut utclean

$(ELF): $(objects)
# link the objects in the sorted order, for maintaining the same md5sum from IAR build binary
	$(LD) $(LDFLAGS) $(TARGET_ARCH) $$(echo $(notdir $(objects)) | sed 's| |\n|g' | sort | sed 's|^|$(TARGET)\\|g' | sed 's|$$| |g' | tr -d '\n' ) $(TARGET_LDFLAGS) -o $(ELF) $(LD_MAP)

$(EXEC): $(ELF)
	$(STRIP)

all: env $(EXEC)

help:
	@$(MAKE) --print-data-base --question |             \
	$(GREP) -v -e '^no-such-target' -e '^makefile' |    \
	$(AWK) '/^[^.%][-A-Za-z0-9_]*:/                     \
			{ print substr($$1, 1, length($$1)-1) }' |  \
	$(SORT) |                                           \
	$(PR) --omit-pagination --width=80 --columns=4

clean:
	$(RM) $(EXEC) $(ELF) $(objects) $(dependencies) $(MAP_FILE) $(ENV_FILE)
	$(RM) -rf $(TARGET)

env:
	$(RM) $(ENV_FILE)
	echo export TP_SW_TOP=$$(pwd) >> $(ENV_FILE)
	echo export TP_PRODUCT=$(TP_PRODUCT) >> $(ENV_FILE)
	echo export TP_MCU_FAMILY=$(TP_MCU_FAMILY) >> $(ENV_FILE)
	echo export TARGET=$(TARGET) >> $(ENV_FILE)
	# exporting all the features from $(TP_FEATURE) with the format HAS_XXX=HAX_XXX
	echo $(foreach f, $(sort $(TP_FEATURE)),export $f=$f) | sed 's/ export/\nexport/g' >> $(ENV_FILE)

#===========================================================================
# Unit-test target
ut:
	echo $(CURDIR)
#	$(MAKE) run $(UT_PARSE) -C common/controller -f controller_ut.mk
	$(MAKE) run $(UT_PARSE) -C common/datatype/ringbuf -f ringbuf_ut.mk
	$(MAKE) run $(UT_PARSE) -C server/audio_server -f AudioSrv_ut.mk
#	$(MAKE) run $(UT_PARSE) -C server/bt_server -f BluetoothSrv_ut.mk
	$(MAKE) run $(UT_PARSE) -C server/ds_server -f DebugSSrv_ut.mk
	$(MAKE) run $(UT_PARSE) -C server/key_server -f keysrv_ut.mk
#	$(MAKE) run $(UT_PARSE) -C server/led_server -f LedSrv_ut.mk
	$(MAKE) run $(UT_PARSE) -C server/power_server -f powersrv_ut.mk
#	$(MAKE) run $(UT_PARSE) -C server/setting_server -f settingsrv_ut.mk

utclean:
#	$(MAKE) clean $(UT_PARSE) -C common/controller -f controller_ut.mk
	$(MAKE) clean $(UT_PARSE) -C common/datatype/ringbuf -f ringbuf_ut.mk
	$(MAKE) clean $(UT_PARSE) -C server/audio_server -f AudioSrv_ut.mk
#	$(MAKE) clean $(UT_PARSE) -C server/bt_server -f BluetoothSrv_ut.mk
	$(MAKE) clean $(UT_PARSE) -C server/ds_server -f DebugSSrv_ut.mk
	$(MAKE) clean $(UT_PARSE) -C server/key_server -f keysrv_ut.mk
#	$(MAKE) clean $(UT_PARSE) -C server/led_server -f LedSrv_ut.mk
	$(MAKE) clean $(UT_PARSE) -C server/power_server -f powersrv_ut.mk
#	$(MAKE) clean $(UT_PARSE) -C server/setting_server -f settingsrv_ut.mk

############################################################################
# include the dependency files (*.d)
############################################################################
ifeq "$(MAKECMDGOALS)" "all"
  -include $(dependencies)
endif

############################################################################
# Evaluate the rules for each .o.d from the sources
############################################################################
$(eval $(compile-rules))

#===========================================================================
# STM32 rule from assembly
ifeq "$(TP_MCU_FAMILY)" "stm32"
  $(TARGET)/startup_stm32f0xx.o: $(STARTUP_PATH)/startup_stm32f0xx.s
	$(IAR)/arm/bin/iasmarm.exe $< -O$(TARGET) -s+ -w+ -r --cpu Cortex-M0 --fpu None
endif




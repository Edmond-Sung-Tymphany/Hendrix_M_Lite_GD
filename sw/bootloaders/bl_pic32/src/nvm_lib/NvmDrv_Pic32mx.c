/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Nvm Driver
                  -------------------------

                  SW Module Document




@file        NvmPic32mxDrv.c
@brief       It's the driver to read/write Non-Volatile Memory (NVM) of PIC32MX
@author      Johnny Fan 
@date        2014-03-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-03-17     Johnny Fan 
DESCRIPTION: First Draft. Generated by newclass.py.
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "BootLoader.h" //each file must include Bootloader.h
#include <p32xxxx.h>
#include <stdlib.h>
#include <plib.h>       //Include to use PIC32 peripheral libraries
#include "HardwareProfile_flash.h"
#include "NvmDrv.h"
#include "NvmDrv_priv.h"
#include "dbgprint.h"

/* Application delare NVM_DATA[] as constant array.
 * Bootloader just use pointer to NVM_DATA_ADDRaccess it
 */
volatile uint8 *NVM_DATA= (uint8 *)NVM_STORAGE_ADDR;
//NVM_ALLOCATE_ADDR(NVM_STORAGE_ADDR, NVM_DATA, NVM_STORE_BYTE_SIZE); //declare NVM_DATA[NVM_STORE_BYTE_SIZE];


/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
//write a single word
BOOL NvmDrv_WriteWord(uint32 address, uint32 wData)
{
    if( !NVM_STORAGE_VALUE_CHECK(wData) ) {
        //DBG_PRINT("[%s] ERROR: NVM_DATA[%d] have wrong data 0x%08x", __func__, (int)address, (int)wData);
    }

    if((address+sizeof(wData))>NVM_STORE_BYTE_SIZE)
    {
        return FALSE;
    }
    
    /* page buffer needed by NVMprogram function, as it will first erase the flash before writing,
    * this buffer is for temporary storage for the flash data*/
    uint32 pagebuff[PAGE_SIZE];

    if( *(uint32 *)(&NVM_DATA[address]) != wData ) {
        /* If user press REBOOT when upgrading firmware before, we need to clear error before do any operation */
        if( NVMIsError() ) {
            NVMClearError();
            DBG_PRINT("\r\n\r\n*** WARNING: Flash operation had error before ***\r\n\r\n\r\n", __func__);
        }

        NVMProgram((void *)(NVM_DATA + address), (const void *)(&wData), \
                sizeof(wData), (void*) pagebuff);
    }
    assert( *(uint32 *)(&NVM_DATA[address]) == wData );	
    return NvmDrv_CheckError();
}

//write some words
BOOL NvmDrv_WriteWords(uint32 address, uint32* pWriteData, uint32 dataSizeInByte)
{
    if((address+dataSizeInByte)>NVM_STORE_BYTE_SIZE)
    {
        return FALSE;
    }
    
    /* If user press REBOOT when upgrading firmware before, we need to clear error before do any operation */
    if( NVMIsError() ) {
        NVMClearError();
        DBG_PRINT("\r\n\r\n*** WARNING: Flash operation had error before ***\r\n\r\n\r\n", __func__);
    }

    uint32 pagebuff[PAGE_SIZE];
    NVMProgram((void *)(NVM_DATA + address), (const void *)pWriteData, \
            dataSizeInByte, (void*) pagebuff);
    return NvmDrv_CheckError();
}

//read a single word
uint32 NvmDrv_ReadWord(uint32 address)
{
    uint32 value= 0;    
    assert((address+ sizeof(uint32))<=NVM_STORE_BYTE_SIZE);
    value = *(uint32 *)(&NVM_DATA[address]);
    return value;
}

//read some words
BOOL NvmDrv_ReadWords(uint32 address, uint32* pReadData, uint32 dataSizeInByte)
{
    if((address + dataSizeInByte)>NVM_STORE_BYTE_SIZE)
    {
        return FALSE;
    }
    memcpy((void *)pReadData,(void *)(&NVM_DATA[address]), dataSizeInByte);
    return TRUE;
}

//erase the whole NVM storage NVM_DATA
BOOL NvmDrv_EraseAll()
{
    if (NVM_STORE_BYTE_SIZE > BYTE_PAGE_SIZE)
    {
        /* if the storage size is bigger than 1 page, erase page by page*/
        int32 nvmFlashSize = NVM_STORE_BYTE_SIZE;
        uint8* pNvmData = (uint8*) NVM_DATA;

        /* If user press REBOOT when upgrading firmware before, we need to clear error before do any operation */
        if( NVMIsError() ) {
            NVMClearError();
            DBG_PRINT("\r\n\r\n*** WARNING: Flash operation had error before ***\r\n\r\n\r\n", __func__);
        }

        do
        {
            NVMErasePage((void *) pNvmData);
            nvmFlashSize -= BYTE_PAGE_SIZE;
            pNvmData += BYTE_PAGE_SIZE;
        }while(nvmFlashSize>0);
    }
    else
    {/* erase one page*/
        NVMErasePage((void *) NVM_DATA);
    }
    return NvmDrv_CheckError();
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static BOOL NvmDrv_CheckError()
{
    if(NVMIsError())
    {   // if there's error
        NVMClearError();
        return FALSE;
    }
    return TRUE;
}
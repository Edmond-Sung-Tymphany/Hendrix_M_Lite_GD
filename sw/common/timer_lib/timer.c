/*
-------------------------------------------------------------------------------
TYMPHANY





                  Timer service
                  -------------------------

                  SW Module Document




@file        Timer.c
@brief       This file implements the timer service which gives a "one-shot" callback 
             event after a specific time interval ie a Timer
@author      Bob.Xu 
@date        2015-10-15
@Copyright (c) <2015> Tymphany HK Ltd. All rights reserved.

DESCRIPTION: Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "timer.h"
#include "./timer_priv.h"
#include "trace.h"
#include "controller.h"
#include "bsp.h"
#include "sortLib.h"
/* internal signals */
enum InternalSignals
{
    TIMEOUT_SIG = MAX_SIG,
};

#if (NUM_OF_MAX_TIMER >= 65536)
   #error "build error due to too big NUM_OF_MAX_TIMER"
#endif

#ifndef GET_MS_IN_TICKS
  #error GET_MS_IN_TICKS is not defined yet, please define "#define GET_MS_IN_TICKS(y)      (y * 1000 /BSP_TICKS_PER_SEC)" in projBsp.h
#endif
const uint16 TIMER_SRV_TICK_TIME = GET_TICKS_IN_MS(1); //the minimal time unit which is 1 ms
static QEvt const * TimerSrvQueueSto[TIMER_SRV_EVENT_Q_SIZE];
static tTimer timerInstants[NUM_OF_MAX_TIMER];
static cTimeService timeServiceInstance = {SRV_CTOR_FNC(&Time_StartUp), NULL};

/***************************Public functions*********************************/
/**
* Start a Timer
* @param[in]       time       the time interval in ms, the callback function will be invoked after this period is passed by
* @param[out]      pTimerId   the allocated timer ID will be save to the memory location of this poiter
* @param[in]       pFunc      callback funtion pointer
* @param[in]       pCbPara    the parameters for the callback function, user should cast it to right type in the callback function
* @param[return]   bool       TRUE/FALSE, TRUE indicate that the timer allocate succeed, otherwise there is no timer available
*/
bool Timer_StartTimer(uint32 timeout, uint16 *pTimerId, timerCallbackFunc pFunc, void *pCbPara)
{
    ASSERT(pFunc && (timeout >= 1));

    int8 ii = 0;
    *pTimerId = TIMER_ID_INVALID;
    uint32 sysTime = getSysTime();

    if (!timeServiceInstance.isCreated)
    {
        Time_StartUp((cPersistantObj*)(&timeServiceInstance));
    }

    for ( ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
    {
        if (timerInstants[ii].isTimerFree)
        {
            timerInstants[ii].pCbFunc = pFunc;
            timerInstants[ii].pCbParam = pCbPara;
            timerInstants[ii].timeoutTicks = GET_TICKS_IN_MS(timeout);
            timerInstants[ii].isTimerFree = false;
            timerInstants[ii].absRegTime = sysTime;
            *pTimerId = timerInstants[ii].timerId;
            break;
        }
    }
    ASSERT(TIMER_ID_INVALID != *pTimerId); //Can not get free timer from timer poll

    /* Sort the Queue after new element is inserted */
    Time_SortTime(timerInstants,NUM_OF_MAX_TIMER);
    /* Start the timer for the event which will be expired first */
    for (ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
    {
        if (!timerInstants[ii].isTimerFree)
        {
            break;
        }
    }
    ASSERT(ii < NUM_OF_MAX_TIMER);
    PersistantObj_RefreshTick((cPersistantObj*)(&timeServiceInstance), timerInstants[ii].timeoutTicks);

    if (TIMER_ID_INVALID != *pTimerId)
    {
        return TRUE;
    }

    ASSERT(0);
    return FALSE;
}

/**
* Stop a timer
* @param[in]      timerId   The timer which will be stopped
* @param[return]  bool      TRUE/FALSE, TRUE means the timer is stoped, otherwisse the timer doesn't exist
*/
bool Timer_StopTimer(uint16 timerId)
{
    uint8 ii;

    ASSERT(timerId < NUM_OF_MAX_TIMER);
    if (!timeServiceInstance.isCreated)
    {
        Time_StartUp((cPersistantObj*)(&timeServiceInstance));
        return FALSE;
    }
    else
    {
        for (ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
        {
            if (timerId == timerInstants[ii].timerId)
            {
                Time_FreeTimer(&timerInstants[ii]);
                return TRUE;
            }
        }
    }
    return FALSE;
}

/**
* Check a specific timer status
* @param[in]       timerId          the timer ID
* @param[in]       pTimerInfo       a pointer to tell the info of a specific timer
* @param[return]   bool             TRUE or FALSE, FALSE means the given timer ID doesn't exist
*/
bool Timer_GetTimerStatus(uint16 timerId, tTimerInfo * pTimerInfo)
{
    ASSERT(timerId < NUM_OF_MAX_TIMER && pTimerInfo);

    uint8 ii;

    if (!timeServiceInstance.isCreated)
    {
        Time_StartUp((cPersistantObj*)(&timeServiceInstance));
        return FALSE;
    }

    for (ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
    {
        if (timerId == timerInstants[ii].timerId)
        {
            pTimerInfo->expireTime  = GET_MS_IN_TICKS(timerInstants[ii].timeoutTicks);// if you have error of not define GET_MS_IN_TICKS, please define it in projBsp.h
            pTimerInfo->pCbFunc     = timerInstants[ii].pCbFunc;
            pTimerInfo->pCbParam    = timerInstants[ii].pCbParam;
            pTimerInfo->isTimerFree = timerInstants[ii].isTimerFree;
            return TRUE;
        }
    }
    return FALSE;
}

/***********************Private functions************************************/
/* Initial state */
static void Time_StartUp(cPersistantObj *me)
{
    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&Time_Initial), TIMEOUT_SIG,
                   TimerSrvQueueSto, Q_DIM(TimerSrvQueueSto), TIMER_SRV_ID);
    Time_InitTimers();
}

static QState Time_Initial(cTimeService *const me, QEvt const * const e)
{
    (void)e; /* suppress the compiler warning about unused parameter */
    return Q_TRAN(&Time_Active);
}

static QState Time_Active(cTimeService * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
            uint8 ii = 0;

            Time_UpdateTimer();
            for (ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
            {
                if (!timerInstants[ii].isTimerFree)
                {
                  PersistantObj_RefreshTick((cPersistantObj*)me, timerInstants[ii].timeoutTicks);
                  break;
                }
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

static void Time_UpdateTimer()
{
    uint8 ii = 0;
    tTimer temp;
    int32 sysTime = getSysTime();

    for ( ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
    {
        if (!timerInstants[ii].isTimerFree)
        {
            timerInstants[ii].timeoutTicks = timerInstants[ii].timeoutTicks - (sysTime - timerInstants[ii].absRegTime);

            if (timerInstants[ii].timeoutTicks <= 0)
            {
                memcpy(&temp,&(timerInstants[ii]),sizeof(tTimer));
                Time_FreeTimer(&timerInstants[ii]);
                temp.pCbFunc(temp.pCbParam);
            }
            else
            {
                timerInstants[ii].absRegTime = sysTime;
            }
        }
    }
    Time_SortTime(timerInstants,NUM_OF_MAX_TIMER);
}

static void Time_InitTimers()
{
    uint8 ii = 0;

    timeServiceInstance.isCreated = TRUE;
    for ( ii = 0; ii < NUM_OF_MAX_TIMER; ii++)
    {
        Time_FreeTimer(&timerInstants[ii]);
        timerInstants[ii].timerId = ii;
    }
}

/* Shell sort */
static void Time_SortTime(tTimer *timerArr, int len)
{
    int32 gap;
    int32 ii;
    int32 jj;
    tTimer temp;

    for (gap = len >> 1; gap > 0; gap >>= 1)
    {
        for (ii = gap; ii < len; ii++)
        {
            memcpy(&temp, &(timerArr[ii]), sizeof(tTimer));
            for (jj = ii - gap; jj >= 0 && timerArr[jj].timeoutTicks > temp.timeoutTicks; jj -= gap)
            {
                memcpy(&timerArr[jj + gap], &timerArr[jj], sizeof(tTimer));
            }
            memcpy(&timerArr[jj + gap], &temp, sizeof(tTimer));
        }
    }
}

static void Time_FreeTimer(tTimer *timer)
{
    timer->isTimerFree  = TRUE;
    timer->pCbFunc      = NULL;
    timer->pCbParam     = NULL;
    timer->absRegTime   = 0;
    timer->timeoutTicks = 0;
}

/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  dsp 1701 driver
                  -------------------------

                  SW Module Document




@file        dsp_adau1701_driver.c
@brief       This file implements the drivers for adau1701 
@author      Jerry Guo,Edmond Sung, Bob.Xu, Johnny Fan
@date        2014-08-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-3-23     Johnny.Fan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include <stdio.h>
#include "trace.h"
#include "cplus.h"
#include "commonTypes.h"
#include "I2CDrv.h"
#include "SettingSrv.h"
#include "dspAdau1701Drv_priv.h"
#include "dspDrv.conf"
#include "GpioDrv.h"

#ifdef USE_DSP_COMPRESS
#  include "Dsp_Init_Tab.h"
#  include "Dsp_Tunable_Tab.h"
#else
#  include "adau1701_config.h"
#endif




/***********************************************************/
/************************ Feature **************************/
/***********************************************************/
//#define DSP_INIT_REPEAT_TEST


/***********************************************************/
/********************* Definition **************************/
/***********************************************************/
#ifndef NULL
#define NULL          (0)
#endif

/*#ifndef DSPDRV_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif*/

#define ON_STATE      (1)
#define OFF_STATE     (0)


/***********************************************************/
/****************** Global Variable ************************/
/***********************************************************/
static int16 *pSettData;

#ifdef USE_DSP_COMPRESS
static tDspInitSection DspInitSection[] =
{
    {DSPDrv1701_Reset1, 50},
    {DSPDrv1701_Reset2, 50},
    {DSPDrv1701_Reset3, 50},
    {&DSPDrv1701_InitSection0, 50},
    {&DSPDrv1701_InitSection1, 50},
    {&DSPDrv1701_InitSection2, 50},
    {&DSPDrv1701_InitSection3, 50},
    {&DSPDrv1701_InitSection4, 50},
    {&DSPDrv1701_InitSection5, 50},
    {&DSPDrv1701_InitSection6, 50},
    {&DSPDrv1701_InitSection7, 50},
};
#else
static tDspInitSection DspInitSection[] =
{
    {DSPDrv1701_Reset1, 50},
    {DSPDrv1701_Reset2, 50},
    {DSPDrv1701_Reset3, 50},
    {&DSPDrv1701_InitSection0, 50},
    {&DSPDrv1701_InitSection1, 50},
    {&DSPDrv1701_InitSection2, 50},
    {&DSPDrv1701_InitSection3, 50},
    {&DSPDrv1701_InitSection4, 50},
    {&DSPDrv1701_InitSection5, 50},
    {&DSPDrv1701_InitSection6, 50},
    {&DSPDrv1701_InitSection7, 50},
#ifdef DSP_BOOT_TONE    
    {&DSPDrv1701_InitSection8, 500},
#endif    
};
#endif

static tCtrIdEQIdMap ctrIdEQIdMap[] = 
{
   /* DSP setting ID  index of setting db*/
   {DSP_VOLUME_SETT_ID,  SETID_VOLUME},
};

static tInitTableTXCtrl initTableTxCtrl =
{
    .pOffset = NULL,
    .NumOfDataInRow = 0,
    .tableRowNum = 0,
    .dataSegment = INIT_DATA_SEGMENT_1
};

static cGpioDrv gpioDsp;



/***********************************************************/
/****************** PUBLIC FUNCTION ************************/
/***********************************************************/
/**
 * Construct the DSP driver instance.
 * @param      me - instance of the driver
 */
void DSPDrv1701_Ctor(cDSPDrv1701* me, cI2CDrv *pI2cObj)
{
    me->i2cObj        = pI2cObj;
    me->pInitTable    = DspInitSection;
    me->sectionSize   = ArraySize(DspInitSection);
    me->initPhase     = 0;
    me->max_vol       = MAX_VOLUME;
    me->default_vol   = DEFAULT_VOLUME;
    me->isCreated     = TRUE;
    me->deviceAddr    = pI2cObj->pConfig->devAddress;
#ifdef HAS_MENU
    pSettData         = (int16*)Setting_Get(SETID_MENU_DATA);
#endif
    DSPDrv1701_SetPower(ON_STATE);
}

/**
 * Destruct the DSP driver instance.
 * @param      me - instance of the driver
 */
void DSPDrv1701_Xtor(cDSPDrv1701* me)
{
    me->pInitTable    = NULL;
    me->sectionSize   = 0;
    me->initPhase     = 0;
    me->isCreated     = FALSE;
    DSPDrv1701_SetPower(OFF_STATE);
}

/**
 * Set DSP initialization function
 * @param  -    init section state
 * @return -    return the delay time following if the init is not over
 *              return zero if the init is over
 */
uint16 DSPDrv1701_Init(cDSPDrv1701* me)
{
    uint16 delaytime;
    ASSERT(me);
    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
#ifdef DSP_INIT_REPEAT_TEST
        return delaytime;
#else      
        return 0;
#endif        
    }
    return (delaytime);
}



/**
 * Mutes the DSP DAC output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_MuteDACOut(cDSPDrv1701 *me)
{
    DSPDrv1701_I2cWrite(me, ADAU1701_SET_MUTE_LEN, (uint8*)&ADAU1701_SYSTEM_MUTE);
}

/**
 * Unmutes the DSP DAC output, by clearing the bit3 and bit2 of Page0 Reg64.
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_UnMuteDACOut(cDSPDrv1701 *me)
{
    DSPDrv1701_I2cWrite(me, ADAU1701_SET_MUTE_LEN, (uint8*)&ADAU1701_SYSTEM_UNMUTE);
}

/**
 * Mutes the Headphone output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_MuteHPAOut(cDSPDrv1701 *me)
{

}

/**
 * Un-Mutes the Headphone output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_UnMuteHPAOut(cDSPDrv1701 *me)
{

}

/**
 * Mutes the Lineout
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_MuteLineOut(cDSPDrv1701 *me)
{

}

/**
 * Un-Mutes the Lineout
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_UnMuteLoOut(cDSPDrv1701 *me)
{

}

/**
 * Mutes the amplifier output, it is referring to the amplifier outside the DSP.
 * This pin is not necessarily handled by DSP driver
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_MuteAmp(cDSPDrv1701 *me)
{

}

/**
 * Un-Mutes the amplifier output, it is referring to the amplifier outside the DSP.
 * This pin is not necessarily handled by DSP driver
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_UnMuteAmp(cDSPDrv1701 *me)
{

}

/**
 * Gets the status of the lineout jack status
 *
 * @param      void
 * @return     eLineoutStatus         the lineout jack is plugged or not
eLineoutStatus DSPDrv1701_GetLineoutStatus(cDSPDrv1701 *me)
{

}
 */

/**
 * Gets the status of the aux-in jack status
 *
 * @param      void
 * @return     eAuxinStatus         the auxin jack is plugged or not
 */
bool DSPDrv1701_IsAuxin(cDSPDrv1701 *me)
{
    return FALSE;
}


/**
 * Set the DAC gain
 * @param      dB_onetenth - gain level in one tenth
 */
void DSPDrv1701_setDACgain(cDSPDrv1701 *me, int dB_onetenth)
{

}

/**
 * Set the DAC mute
 * @param      bmute - mute or not
 */
void DSPDrv1701_DAC_Mute(cDSPDrv1701 *me, bool bmute)
{

}


/**
 * Select channel whether I2S or Analog
 * @param  -    channel
 */
/**
 * Select channel whether I2S or Analog
 * @param  -    channel
 */
void DSPDrv1701_set_Input(cDSPDrv1701 *me, eAudioChannel input)
{
#ifdef USE_DSP_COMPRESS
    tTunableInfo tunData;
    uint8        ctrData[ADAU1701_INPUT_SEL_LEN] = {0};
    uint8        currIdx;

    tunData.head        = dsp_tunable_tab;
    tunData.type        = ARRAY_TYPE_SRC_SW;

    /* get the start addr */
    for(currIdx = 0; currIdx < DSP_INPUT_NUM ; currIdx++)
    {
        if(inputIdMap[currIdx].InputId == input)
        {
            tunData.id   = inputIdMap[currIdx].controllerId;
            ctrData[ADAU1701_INPUT_SEL_LEN-1] = inputIdMap[currIdx].sourceIdx;
            break;
        }
    }
    ASSERT(currIdx < DSP_INPUT_NUM );
    DSPDrv1701_GetCtrlAddr(&tunData);

    ctrData[0] = tunData.addr >> 8;
    ctrData[1] = (tunData.addr & 0x00FF);

    DSPDrv1701_I2cWrite(me, ADAU1701_INPUT_SEL_LEN, (uint8*)&ctrData);

#else
    const uint8 * ctrData = NULL;
    switch (input)
    {
        case AUDIO_CHANNEL_AUXIN:
        {
            ctrData= ADAU1701_ANALOG_INPUT_SELECT;
            break;
        }
        case AUDIO_CHANNEL_I2S_1:
        {
            ctrData= ADAU1701_DIGITAL_INPUT_1_SELECT;
            break;
        }
        default:
            break;
    }

    if(ctrData)
    {
        DSPDrv1701_I2cWrite(me, ADAU1701_INPUT_SEL_LEN, (uint8*)ctrData);
    }
#endif    
}

/**
 * Select channel on DSP mux which it a customer added on DSP flow
 * @param  -    channel

int DSPDrv1701_setStereoMux(cDSPDrv1701 *me, eDspMuxChannel ch)
{
    
}
 */



#ifdef DSP_BOOT_TONE
void DSPDrv1701_ToneEnable(cDSPDrv1701 *me, bool enable)
{
    TP_PRINTF("DSPDrv1701_ToneEnable: enable=%d\r\n", enable);
    
    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_UNLOCK_REGISTERS);
    
    if(enable) {
      DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_TONE_ON_REG1), (uint8*)&ADAU1701_TONE_ON_REG1);
      DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_TONE_ON_REG2), (uint8*)&ADAU1701_TONE_ON_REG2);
    }
    else {
      DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_TONE_OFF_REG1), (uint8*)&ADAU1701_TONE_OFF_REG1);
      DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_TONE_OFF_REG2), (uint8*)&ADAU1701_TONE_OFF_REG2);
    }
    
    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_LOCK_REGISTERS);
}
#endif /* #ifdef DSP_BOOT_TONE */


/**
 * Sets the DSP volume, by writing the L/R channels PGA Gain registers. Please
 * reference on the volume table to check the real gain.
 *
 * @param      vol             The volume step that will be set
 * @return     void
 */
void DSPDrv1701_SetVol(cDSPDrv1701 *me, uint8 vol)
{
    TP_PRINTF("DSPDrv1701_SetVol: vol=%d \r\n", vol);
    uint8 vol_iic[6] = {0,0,0,0,0,0}; /* write DSP register */
    
#ifdef USE_DSP_COMPRESS    
    tTunableInfo tunable_info;
    tunable_info.head = (uint8*)dsp_tunable_tab;
    tunable_info.type = ARRAY_TYPE_VOL_CTRL;
    tunable_info.id   = 0;    /* suppose there are only 1 volume controller that is changeable */
    DSPDrv1701_GetCtrlAddr(&tunable_info);
    uint32 reg_addr= tunable_info.addr;
#else
    uint32 reg_addr= ADAU1701_VOLUME_ADDR;
#endif
    
    if(vol > MAX_VOLUME)
    {
        vol = MAX_VOLUME;
        ASSERT(0);
    }
    else if(vol < MIN_VOLUME)
    {
        vol = MIN_VOLUME;
        ASSERT(0);
    }

    vol_iic[0] = reg_addr >> 8;
    vol_iic[1] = reg_addr & 0x00FF;
    vol_iic[2] = 0;
    vol_iic[3] = 0;
    vol_iic[4] = 0;
    vol_iic[5] = vol;

    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_UNLOCK_REGISTERS);
    DSPDrv1701_I2cWrite(me, ADAU1701_UPDATE_VOLUME_LEN,     (uint8*)&vol_iic);
    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_LOCK_REGISTERS);
}


/**
 * Detect whether there is a input present
 *
 * @param
 * @return     bool    If the music is present either source depending on the DSP flow design
 */

bool DSPDrv1701_HasMusicStream(cDSPDrv1701 *me)
{
/************************************************************************
********** Messages related to the "DSP Core Control Register" **********
************************************************************************/
  
    bool         ret = FALSE;
    
#ifdef USE_DSP_COMPRESS
    uint8        readDataFromDsp[ADAU1701_AUDIO_DETECT_LEN + 1] = {0};
    tTunableInfo tunData;

    tunData.head        = dsp_tunable_tab;
    tunData.type        = ARRAY_TYPE_MUS_DET;
    tunData.id          = 0;// There is only one control ID

    /* get the addr */
    DSPDrv1701_GetCtrlAddr(&tunData);
    /* read audio detection */
    DSPDrv1701_I2cRead(me, tunData.addr, ADAU1701_AUDIO_DETECT_LEN, (uint8*)&readDataFromDsp);

    if (AUDIO_DETECTED == readDataFromDsp[1])
    {
        ret = TRUE;
    }
    else if (AUDIO_NOT_DETECTED == readDataFromDsp[1])
    {
        ret = FALSE;
    }
    else
    {
        ret = FALSE;
    }

#else    
      //TBD
#endif    
    
    return ret;
    
}

void DSPDrv1701_SetAudio(cDSPDrv1701 *me, eAudioSettId dspSettId, BOOL enable)
{
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
        {
            break;
        }
    }
    ASSERT(dspSettId < DSP_SETT_ID_MAX);
    switch(dspSettId)
    {
        case DSP_VOLUME_SETT_ID:
        {
            if(enable)
            {
                /* Convert it to positive */
                uint8 volume = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION+MAX_VOLUME;
                DSPDrv1701_SetVol(me,volume);
            }
            else
            {
                DSPDrv1701_SetVol(me,0);
            }
        }
        break;
        default:
            break;
    }
}

#ifdef REDUCE_TOTAL_GAIN_WHILE_LOW_POWER
/**
 * Refresh volume when battery is low, reduce it by 6dB
 *
 * @param      uint8        target volume
 * @return     void
 */
void DSPDrv1701_SetVolForLowPower(cDSPDrv1701 *me, uint8 vol)
{
    
}
#endif

#ifdef REDUCE_DYNAMIC_RANGE_WHILE_LOW_POWER
/**
 * Refresh DRCs when power is low
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_SetDrcForLowPower(cDSPDrv1701 *me)
{

}

/**
 * Refresh DRCs for normal power
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_SetDrcForNormalPower(cDSPDrv1701 *me)
{

}

/**
 * Refresh DRCs for adaptor mode
 *
 * @param      void
 * @return     void
 */
void DSPDrv1701_SetDrcForAdaptorMode(cDSPDrv1701 *me)
{

}

#endif






/***********************************************************/
/***************** PRIVATE FUNCTION **************************/
/***********************************************************/

static void DSPDrv1701_SetPower(bool state)
{
/*
    if(state == ON_STATE)
    {
        DC3V3_EN_PIN_HIGH;   // Active high
    }
    else
    {
        DC3V3_EN_PIN_LOW;
    }
*/
}

static void DSPDrv1701_SetReset(bool reset)
{
    if(reset)
    {
        DSP_RESET_PIN_LOW();
    }
    else
    {
        DSP_RESET_PIN_HIGH();
    }
}

            
static void DSPDrv1701_Reset1(void *p)
{
    //GPIO pins init
    tGPIODevice* pDspGPIOConf = NULL;
    pDspGPIOConf= (tGPIODevice*)getDevicebyIdAndType(DSP_DEV_ID, GPIO_DEV_TYPE, NULL);
    GpioDrv_Ctor(&gpioDsp,pDspGPIOConf);

    //pull reset pin
    AMP_DISABLE(gpioDsp);
    AMP_MUTE(gpioDsp);
    DSPDrv1701_SetReset(FALSE);
}

static void DSPDrv1701_Reset2(void *p)
{
    DSPDrv1701_SetReset(TRUE);
}

static void DSPDrv1701_Reset3(void *p)
{
    DSPDrv1701_SetReset(FALSE);
}

static void DSPDrv1701_InitSection0(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection0\r\n");
            
    //Initialize I2C
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    const tDevice * pDevice = NULL;
    pDevice = getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(pDevice);
    I2CDrv_Ctor(me->i2cObj,(tI2CDevice*)pDevice);
    me->i2cObj->registeredUser++;
    
    TP_PRINTF("DSPDrv1701_InitSection0 finish\r\n");
}

static void DSPDrv1701_InitSection1(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection1\r\n");
    
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    //I2C_HW_write_var_len(ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_CLEAR_INT_REGS);
    DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_CLEAR_INT_REGS), (uint8*)&ADAU1701_CLEAR_INT_REGS);

    TP_PRINTF("DSPDrv1701_InitSection1 finish\r\n");
}

static void DSPDrv1701_InitSection2(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection2\r\n");
    
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    uint8 buffer[PROGRAM_RAM_PAGE_SIZE+2]; 
    uint16 RegAddr;
    const uint8* bufferPtr;
    bufferPtr=Program_Data_IC_1;
    RegAddr = PROGRAM_ADDR_IC_1;
    for(RegAddr=PROGRAM_RAM_ADDRESS_LOW_BOUNDARY;RegAddr<=PROGRAM_RAM_ADDRESS_HIGH_BOUNDARY;RegAddr++)
    {
        buffer[0]=(RegAddr>>8); 
        buffer[1]=(RegAddr&0xff);
        memcpy(&buffer[2], bufferPtr, PROGRAM_RAM_PAGE_SIZE);
        DSPDrv1701_I2cWrite(me, sizeof(buffer), (uint8*)buffer);
        bufferPtr+=PROGRAM_RAM_PAGE_SIZE;
    }
    TP_PRINTF("DSPDrv1701_InitSection2 finish\r\n");
}


static void DSPDrv1701_InitSection3(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection3\r\n");
    
    cDSPDrv1701* me = (cDSPDrv1701*)p;

    uint8 buffer[PARA_RAM_PAGE_SIZE+2]; 
    uint16 RegAddr;
    const uint8* bufferPtr;
    bufferPtr=Param_Data_IC_1;
    RegAddr = PARAM_ADDR_IC_1;
    for(RegAddr=PARAM_RAM_ADDRESS_LOW_BOUNDARY;RegAddr<=PARAM_RAM_ADDRESS_HIGH_BOUNDARY;RegAddr++)
    {
        buffer[0]=(RegAddr>>8); 
        buffer[1]=(RegAddr&0xff);
        memcpy(&buffer[2], bufferPtr, PARA_RAM_PAGE_SIZE);
        DSPDrv1701_I2cWrite(me, sizeof(buffer), (uint8*)buffer);
        bufferPtr+=PARA_RAM_PAGE_SIZE;
    }
    TP_PRINTF("DSPDrv1701_InitSection3 finish\r\n");
}


static void DSPDrv1701_InitSection4(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection4\r\n");
    
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    uint8 buffer[R3_HWCONFIGURATION_IC_1_SIZE+2]; 
    uint16 RegAddr = 0x081c;
    buffer[0]=(uint8)(RegAddr>>8); 
    buffer[1]=(uint8)(RegAddr&0xff); 
    memcpy(&buffer[2], R3_HWCONFIGURATION_IC_1_Default, sizeof(R3_HWCONFIGURATION_IC_1_Default));
    DSPDrv1701_I2cWrite(me, sizeof(buffer), (uint8*)buffer);
    
    TP_PRINTF("DSPDrv1701_InitSection4 finish\r\n");
}

static void DSPDrv1701_InitSection5(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection5\r\n");
    
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    DSPDrv1701_I2cWrite(me, sizeof(ADAU1701_RESUME_SIGNAL), (uint8*)&ADAU1701_RESUME_SIGNAL);
    TP_PRINTF("DSPDrv1701_InitSection5 finish\r\n");
}

static void DSPDrv1701_InitSection6(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection6\r\n");
    
    AMP_ENABLE(gpioDsp);
    TP_PRINTF("DSPDrv1701_InitSection6 finish\r\n");

     /*
     *   The input BCLK polarity has to match the output polarity of WM8805,
     *   which is "data changes on rising edge"
     *   This setup is specific to Marley One Foundation platform.
     *   DO NOT apply this setting to other platforms unless you clearly understand the hardware configuration
     */
}


static void DSPDrv1701_InitSection7(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection7\r\n");
    
//#ifdef BGC_ENABLED
    //increase the bgc sine tone gain, default is GAIN_1
    //adau1701_set_sine_tone_gain(GAIN_4);
//#endif
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    /* set the default volume and channel, will remove it later*/
    DSPDrv1701_SetVol(me, DEFAULT_VOLUME);
    DSPDrv1701_set_Input(me,AUDIO_CHANNEL_I2S_1);
        
    AMP_UNMUTE(gpioDsp);
    
#ifdef DSP_BOOT_TONE
    DSPDrv1701_ToneEnable(me, /*enable:*/TRUE);    
#endif
    
    TP_PRINTF("DSPDrv1701_InitSection7 finish\r\n");
}


static void DSPDrv1701_InitSection8(void *p)
{
    TP_PRINTF("DSPDrv1701_InitSection8\r\n");

#ifdef DSP_BOOT_TONE
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    DSPDrv1701_ToneEnable(me, /*enable:*/FALSE);    
#endif
    
    TP_PRINTF("DSPDrv1701_InitSection8 finish\r\n");
}


static void DSPDrv1701_Delay(uint16 count)
{
    while(count--)
    {
        asm("nop");
        asm("nop");
    }
}

/**
 * Write data to DSP by I2C.
 *
 * @param      uint8           device I2C address
 *
 * @param      uint8           data byte number
 *
 * @param      const uint8*    pointer to data array
 *
 * @return     void
 */
static void DSPDrv1701_I2cWrite(cDSPDrv1701 *me, uint16 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = NULL,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };
    I2CDrv_MasterWrite(me->i2cObj, &i2cMsg);
}

static void DSPDrv1701_I2cRead(cDSPDrv1701 *me, uint32 regAddr, uint16 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = regAddr,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };
    I2CDrv_MasterRead(me->i2cObj, &i2cMsg);
}








/*****************************************************
 ***********  Compress related function  *************
 *****************************************************/
#ifdef USE_DSP_COMPRESS
/**
 * Check the magic number in head of the DSP_Init_Tab or DSP_Tunable_Tab
 *
 * @param      uint8*          pointer to the table head
 *
 * @return     void
 */
static void DSPDrv1701_ChkMagicNum(const uint8 *p)
{
    uint8 magic_num[MAGIC_NUMBER_NUM];

    memcpy(magic_num, p, MAGIC_NUMBER_NUM);

    ASSERT((magic_num[0] == MAGIC_NUMBER_EVEN) && (magic_num[2] == MAGIC_NUMBER_EVEN)
           && (magic_num[4] == MAGIC_NUMBER_EVEN) && (magic_num[6] == MAGIC_NUMBER_EVEN)
           && (magic_num[1] == MAGIC_NUMBER_ODD) && (magic_num[3] == MAGIC_NUMBER_ODD)
           && (magic_num[5] == MAGIC_NUMBER_ODD) && (magic_num[7] == MAGIC_NUMBER_ODD));
}

static void DSPDrv1701_DispatchZipProgramData(cDSPDrv1701 *me)
{
    const uint8* curr_ptr;
    uint32 pos_data = 0;
    uint8 curr_array[PROGRAM_RAM_PAGE_SIZE*PROGRAM_RAM_DATA_LEN+REG_ADDRESS_LEN] = {0, 0};
    uint8 cnt = 0;
    uint8 tail_zero_num;
    int16 reg_address;

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_2))
    {
        memset(curr_array, 0, sizeof(curr_array));

        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        /* get the first byte as the start address */
        curr_ptr = initTableTxCtrl.pOffset;
        curr_ptr++;
        tail_zero_num = ((*curr_ptr & 0xF0) >> 4);

        reg_address = (*curr_ptr)&0x0F;
        reg_address <<= 8;
        curr_ptr++;
        reg_address |= *(curr_ptr);

        if ((reg_address <= PARAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(reg_address >= PARAM_RAM_ADDRESS_LOW_BOUNDARY))        /* go to PARAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_3;
            break;
        }

        initTableTxCtrl.pOffset++;

        /* get the position mask data */
        curr_ptr++;
        memcpy((uint8*)(&pos_data), curr_ptr, POS_DATA_BYTE_LEN);
        curr_ptr += POS_DATA_BYTE_LEN;

        if(!pos_data)
        {
            /* There is something wrong with the coef data!!*/
            ASSERT(0);
            return;
        }

        cnt = 0;
        curr_array[cnt] = (reg_address >> SHIFT_EIGHT_BIT);
        cnt++;
        curr_array[cnt] = (reg_address & MASK_LOW_BYTE);
        cnt++;

        /* go throught the pos_data, copy the data according to the pos_data */
        while (cnt < 32*5+2)
        {
            if(!pos_data)
            {
                /* There is something wrong with the coef data!!*/
                ASSERT(0);
                break;
            }
            if(pos_data & 0x01)
            {
                /* if this bit is 1 */
                memcpy(&(curr_array[cnt]), curr_ptr, PROGRAM_RAM_DATA_LEN);
                curr_ptr += PROGRAM_RAM_DATA_LEN;
            }

            pos_data = (pos_data >> 1);
            cnt += PROGRAM_RAM_DATA_LEN;
        }

        /* sends out by I2C */
        cnt += tail_zero_num * PROGRAM_RAM_DATA_LEN;
        DSPDrv1701_I2cWrite(me, cnt, curr_array);
        initTableTxCtrl.tableRowNum--;
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;
    }
}

static void DSPDrv1701_DispatchZipParaDataZero(cDSPDrv1701 *me)
{
    const uint8* curr_ptr;
    uint8 curr_array[PARAM_RAM_PAGE_SIZE*PARAM_RAM_DATA_LEN+REG_ADDRESS_LEN] = {0, 0};
    uint8 cnt = 0;
    int16 reg_address;

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_4))
    {
        memset(curr_array, 0, sizeof(curr_array));

        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        /* get the first byte as the start address */
        curr_ptr = initTableTxCtrl.pOffset;
        curr_ptr++;//point to the address
        reg_address = (*curr_ptr)&0x0F; // clean higher 4 bits
        reg_address <<= 8;
        curr_ptr++;
        reg_address |= *(curr_ptr);

        if (!((reg_address <= PARAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(reg_address >= PARAM_RAM_ADDRESS_LOW_BOUNDARY)))        /* go to PARAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_5;
            break;
        }

        initTableTxCtrl.pOffset++;

        cnt = 0;
        curr_array[cnt] = (reg_address >> SHIFT_EIGHT_BIT);
        cnt++;
        curr_array[cnt] = (reg_address & MASK_LOW_BYTE);
        cnt++;
        /* sends out by I2C */
        cnt += PARAM_RAM_PAGE_SIZE * PARAM_RAM_DATA_LEN;
        DSPDrv1701_I2cWrite(me, cnt, curr_array);
        initTableTxCtrl.tableRowNum--;
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;// cnt is the number of zero while 2 is 2 bytes address
    }
}

static void DSPDrv1701_DispatchZipPARAMData(cDSPDrv1701 *me)
{
    const uint8* curr_ptr;
    uint32 pos_data = 0;
    uint8 curr_array[PARAM_RAM_PAGE_SIZE*PARAM_RAM_DATA_LEN+REG_ADDRESS_LEN] = {0, 0};
    uint8 cnt = 0;
    uint8 tail_zero_num;
    int16 reg_address;

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_3))
    {
        memset(curr_array, 0, sizeof(curr_array));

        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        /* get the first byte as the start address */
        curr_ptr = initTableTxCtrl.pOffset;
        curr_ptr++;
        tail_zero_num = ((*curr_ptr & 0xF0) >> 4);

        reg_address = (*curr_ptr)&0x0F;
        reg_address <<= 8;
        curr_ptr++;
        reg_address |= *(curr_ptr);

        if (!((reg_address <= PARAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(reg_address >= PARAM_RAM_ADDRESS_LOW_BOUNDARY)))        /* go to PARAM DATA */
        {
            /* Go to the last stage directly if there is no zero parameter data */
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_5;
            break;
        }

        /* get the position mask data */
        curr_ptr++;
        memcpy((uint8*)(&pos_data), curr_ptr, POS_DATA_BYTE_LEN);
        curr_ptr += POS_DATA_BYTE_LEN;

        if(!pos_data)
        {
            /* 
             * The reg_address is still in parameter address, however, position
             * mask data is zero, that mean all the data is zero, then go to
             * dispatch parameter zero data stage.
             */
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_4;
            break;
        }

        cnt = 0;
        curr_array[cnt] = (reg_address >> SHIFT_EIGHT_BIT);
        cnt++;
        curr_array[cnt] = (reg_address & MASK_LOW_BYTE);
        cnt++;

        /* go throught the pos_data, copy the data according to the pos_data */
        while (cnt < PARAM_RAM_PAGE_SIZE*PARAM_RAM_DATA_LEN+REG_ADDRESS_LEN)
        {
            if(pos_data & 0x01)
            {
                /* if this bit is 1 */
                memcpy(&(curr_array[cnt]), curr_ptr, PARAM_RAM_DATA_LEN);
                curr_ptr += PARAM_RAM_DATA_LEN;
            }

            pos_data = (pos_data >> 1);
            cnt += PARAM_RAM_DATA_LEN;
        }

        /* sends out by I2C */
        cnt += tail_zero_num * PARAM_RAM_DATA_LEN;
        DSPDrv1701_I2cWrite(me, cnt, curr_array);
        initTableTxCtrl.tableRowNum--;
        initTableTxCtrl.pOffset += (initTableTxCtrl.NumOfDataInRow + 1);
    }
}

static void DSPDrv1701_DispatchRawData(cDSPDrv1701 *me)
{
    uint16  regAddress;
    uint8   dly_arr[8];
    uint8   data_arr[30];

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_1)||(initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_5))
    {
        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        regAddress = (*(initTableTxCtrl.pOffset + 1))&0x0F;
        regAddress <<= 8;
        regAddress |= *((initTableTxCtrl.pOffset)+2);

        if (initTableTxCtrl.tableRowNum == 0)          /* for STAGE_4 or in case slot_num is equal to 0 */
        {
            break;
        }

       if ((regAddress <= PROGRAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(regAddress >= PROGRAM_RAM_ADDRESS_LOW_BOUNDARY))        /* go to PROGRAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_2;
            break;
        }
        initTableTxCtrl.pOffset++;

        /* check whether it is a slot of time delay */
        if ((*(initTableTxCtrl.pOffset) == DELAY_SLOT_DATA0) && (initTableTxCtrl.tableRowNum == DELAY_SLOT_NUM))
        {
            /* copy all the data */
            memcpy(dly_arr, initTableTxCtrl.pOffset, DELAY_SLOT_NUM);

            if((dly_arr[1] == DELAY_SLOT_DATA0) && (dly_arr[2] == DELAY_SLOT_DATA0)
               && (dly_arr[4] == DELAY_SLOT_DATA0) && (dly_arr[5] == DELAY_SLOT_DATA0)
               && (dly_arr[6] == DELAY_SLOT_DATA0) && (dly_arr[7] == DELAY_SLOT_DATA1))
            {
                DSPDrv1701_Delay(RESET_DELAY_PER_UNIT * dly_arr[3]);
                initTableTxCtrl.tableRowNum--;
            }
        }
        else
        {
            memcpy(data_arr, initTableTxCtrl.pOffset, initTableTxCtrl.NumOfDataInRow);
            DSPDrv1701_I2cWrite(me, initTableTxCtrl.NumOfDataInRow, data_arr);
            initTableTxCtrl.tableRowNum--;
        }
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;
    }
}

/**
 * Load the DSP_Init_Tab into DSP
 *
 * @param      void
 *
 * @return     void
 */
static void DSPDrv1701_DispatchDspConfigData(cDSPDrv1701 *me)
{
    ASSERT(me);
    /* check magic number in the head */
    DSPDrv1701_ChkMagicNum((uint8*)dsp_init_tab);

    /* Got the number of slot from DSP data */
    initTableTxCtrl.tableRowNum = dsp_init_tab[ARRAY_NUM_OFF]; // get the lower byte
    initTableTxCtrl.tableRowNum += (dsp_init_tab[ARRAY_NUM_OFF + 1] << 8);

    initTableTxCtrl.pOffset = dsp_init_tab + ARRAY_START_OFF;

    DSPDrv1701_DispatchRawData(me);
    DSPDrv1701_DispatchZipProgramData(me);
    DSPDrv1701_DispatchZipPARAMData(me);
    DSPDrv1701_DispatchZipParaDataZero(me);
    DSPDrv1701_DispatchRawData(me);
}



static void DSPDrv1701_InitSection1(void *p)
{
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    //I2C_HW_write_var_len(ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_CLEAR_INT_REGS);
    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_CLEAR_INT_REGS);
}

static void DSPDrv1701_InitSection2(void *p)
{
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    DSPDrv1701_DispatchDspConfigData(me);
}


static void DSPDrv1701_InitSection3(void *p)
{
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    //adau1701_testToneOff();
    //I2C_HW_write_var_len(ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_RESUME_SIGNAL);
    DSPDrv1701_I2cWrite(me, ADAU1701_DSP_CORE_CTRL_REG_LEN, (uint8*)&ADAU1701_RESUME_SIGNAL);
}


static void DSPDrv1701_InitSection4(void *p)
{
    cDSPDrv1701* me = (cDSPDrv1701*)p;
    /* set the default volume and channel, will remove it later*/
    DSPDrv1701_SetVol(me, 22);
    DSPDrv1701_set_Input(me,AUDIO_CHANNEL_I2S_1);
    //DSPDrv1701_set_Input(me,1);
    //DSPDrv1701_set_Input(me,2);
    //DSPDrv1701_set_Input(me,0);
    
}

static void DSPDrv1701_InitSection5(void *p)
{

}

static void DSPDrv1701_InitSection6(void *p)
{

     /*
     *   The input BCLK polarity has to match the output polarity of WM8805,
     *   which is "data changes on rising edge"
     *   This setup is specific to Marley One Foundation platform.
     *   DO NOT apply this setting to other platforms unless you clearly understand the hardware configuration
     */
}

static void DSPDrv1701_InitSection7(void *p)
{

#ifdef BGC_ENABLED
    //increase the bgc sine tone gain, default is GAIN_1
    adau1701_set_sine_tone_gain(GAIN_4);
#endif
    //adau1701_testToneGain(me);
    //adau1701_testToneOn(me);
    // adau1701_testToneOff(me);
    //adau1701_i2s_output(me, FALSE);
    //DSPDrv1701_I2sOutput(me, FALSE);
}



/**
 * Get the controller address(page + register number) from the
 * DSP_Tunable_Tab in ROM
 *
 * @param      tTunableInfo    caller needs to provide the tab start addr
 *                             and the controller type
 *
 * @return     void
 */
static void DSPDrv1701_GetCtrlAddr(tTunableInfo *p)
{
    const uint8* curr_ptr;
    uint16       array_num, currIdx;
    uint8        array_len, block_num;

    curr_ptr = p->head + TABLE_TYPE_INIT_OFF;
    /* go through the table to find the ctrl */
    ASSERT(*curr_ptr == TABLE_TYPE_TUNABLE_LSB);

    curr_ptr = p->head + CHIP_MODEL_NO_OFF;
    ASSERT(*curr_ptr == MODEL_ADAU1701);

    /* get the array number */
    curr_ptr = p->head + ARRAY_NUM_OFF;
    array_num =  *curr_ptr;
    curr_ptr++;
    array_num += (*curr_ptr << 8);

    ASSERT(array_num);

    /* go through all the arrays */
    curr_ptr = (p->head) + ARRAY_START_OFF;
    for(currIdx = 0; currIdx < array_num; currIdx++)
    {
        array_len = *curr_ptr;
        curr_ptr++;
        if(*curr_ptr == (p->type))
        {
            /* get the number of the controller block in the same type in one array */
            curr_ptr++;
            block_num = *curr_ptr;
            ASSERT(p->id < block_num);

            /* get the address of the controller blok */
            /* the id0 address */
            curr_ptr++;
            p->addr = *(curr_ptr + 2*(p->id));
            p->addr = (p->addr) << 8;
            p->addr |= *(curr_ptr + 2*(p->id) + 1);

            return;
        }

        curr_ptr += array_len;
    }

    /* can't find the ctrl info */
    ASSERT(currIdx < array_num);
}


#endif /* #ifdef USE_DSP_COMPRESS */
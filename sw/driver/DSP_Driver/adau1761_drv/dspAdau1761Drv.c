/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  dsp 1761 driver
                  -------------------------

                  SW Module Document




@file        dsp_adau1761_driver.c
@brief       This file implements the drivers for adau1761 
@author      Jerry Guo,Edmond Sung, Bob.Xu 
@date        2014-08-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-17     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 

Change History:
VERSION    : 2    DRAFT      2014-09-28     Daniel.Duan, Bob.Xu  
DESCRIPTION: Refactor audio sever, to add BT tone support
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include <stdio.h>
#include <math.h>
#include "trace.h"
#include "cplus.h"
#include "commonTypes.h"
#include "I2CDrv.h"
#include "SettingSrv.h"
#include "./dspAdau1761Drv_priv.h"
#include "DspInitTab.h"
#include "DspTunableTab.h"

#ifndef NULL
#define NULL                             (0)
#endif

#ifndef DSPDRV_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif
static cI2CDrv dspI2c;

static int16 *pSettData;

static tInitTableTXCtrl initTableTxCtrl = 
{
    .pOffset = NULL,
    .NumOfDataInRow = 0,
    .tableRowNum    = 0,
    .dataSegment    = INIT_DATA_SEGMENT_1
};

static tDspInitSection DspInitSection[] =
{
    {&DSPDrv_InitSection0, 50},
    {&DSPDrv_InitSection1, 100},
};


#define POS_DATA_BYTE_LEN   (4)

static tCtrIdEQIdMap ctrIdEQIdMap[] = 
{
   /* DSP setting ID  index of setting db*/
   {DSP_EQ_CTRL_USER_LP, DB_INDEX_OF_LP},
   {DSP_EQ_CTRL_RGC,     DB_INDEX_OF_RGC},
   {DSP_EQ_CTRL_PEQ1,    DB_INDEX_OF_PEQ1},
   {DSP_EQ_CTRL_PEQ2,    DB_INDEX_OF_PEQ2},
   {DSP_EQ_CTRL_PEQ3,    DB_INDEX_OF_PEQ3},
   {DSP_PHASE_SETT_ID,   DB_INDEX_OF_PHASE},
   {DSP_VOLUME_SETT_ID,  DB_INDEX_OF_VOL},
   {DSP_POLARITY_SETT_ID,DB_INDEX_OF_POLARITY}
};

void DSPDrv_Ctor(cDSPDrv* me)
{
    tI2CDevice * conf = (tI2CDevice *) getDevicebyId(DSP_DEV_ID, NULL);
    ASSERT(conf);
    me->pInitTable    = DspInitSection;
    me->sectionSize   = ArraySize(DspInitSection);
    me->initPhase     = 0;
    me->max_vol       = MAX_VOLUME;
    me->default_vol   = DEFAULT_VOLUME;
    me->pI2CConfig    = (tI2CDevice*)conf;
    me->isCreated     = TRUE;
#ifdef HAS_MENU
    pSettData         = (int16*)Setting_Get(SETID_MENU_DATA);
#endif
}

void DSPDrv_Xtor(cDSPDrv* me)
{
    me->pInitTable    = NULL;
    me->sectionSize   = 0;
    me->initPhase     = 0;
    me->isCreated     = FALSE;
}


uint16 DSPDrv_Init(cDSPDrv* me)
{
    uint16 delaytime;
    ASSERT(me);
    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
        return 0;
    }
    return (delaytime);
}

/**
 * Mutes the DSP DAC output
 *
 * @param      void
 * @return     void
 */
void DSPDrv_MuteDACOut(cDSPDrv *me)
{
    uint8 mixer_value = 0;
    uint8  temp[3] = {0};
    ASSERT(me->pI2CConfig->address);
    DSPDrv_I2cRead(me->pI2CConfig->address, PLAYBACK_LR_LEFT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_value);
    
    mixer_value = (mixer_value & 0xFD); //Disable Mixer
   
    temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
    temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
    temp[2] = mixer_value;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
    
    DSPDrv_I2cRead(me->pI2CConfig->address, PLAYBACK_LR_RIGHT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_value);
    mixer_value = (mixer_value & 0xF7); //Disable Mixer;
    temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
    temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
    temp[2] = mixer_value;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
}

/**
 * Unmutes the DSP DAC output, by clearing the bit3 and bit2 of Page0 Reg64.
 *
 * @param      void
 * @return     void
 */
void DSPDrv_UnMuteDACOut(cDSPDrv *me)
{
    uint8 mixer_value = 0;
    uint8 temp[3] = {0};
    ASSERT(me->pI2CConfig->address);
    DSPDrv_I2cRead(me->pI2CConfig->address, PLAYBACK_LR_LEFT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_value);
    mixer_value = (mixer_value | 0x02); //Eanble Mixer
    temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
    temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
    temp[2] = mixer_value;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
    
    DSPDrv_I2cRead(me->pI2CConfig->address, PLAYBACK_LR_RIGHT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_value);
    mixer_value = (mixer_value | 0x08); //Eanble Mixer
    temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
    temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
    temp[2] = mixer_value;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
}

/**
 * Set volume
 *
 * @param      uint8        target volume
 * @return     void
 */
void DSPDrv_SetVol(cDSPDrv *me, uint8 vol)
{
    /* write DSP register */
    uint8        vol_iic[4] = {0};
    tTunableInfo tunable_info;
    uint16       reg;

    tunable_info.head = (uint8*)dsp_tunable_tab;
    tunable_info.type = ARRAY_TYPE_VOL_CTRL;
    tunable_info.id   = 0;    /* suppose there are only 1 volume controller that is changeable */
    DSPDrv_GetCtrlAddr(&tunable_info);

    if(vol > MAX_VOLUME)
    {
        vol = MAX_VOLUME;
    }

    reg = tunable_info.addr;
    vol_iic[0] = 0;
    vol_iic[1] = 0;
    vol_iic[2] = 0;
    vol_iic[3] = vol;

    DspDrv_SafeLoadData(me, 1, vol_iic, reg);
}
/**
* Audio related setting intrance
* @param[in]    me             dsp object
* @param[in]    dspSettId      dsp setting ID
* @param[in]    enable         disable or enable the settings
*/
void DSPDrv_SetAudio(cDSPDrv *me, eDspSettId dspSettId, BOOL enable)
{
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
        {
            break;
        }
    }
    ASSERT(dspSettId < DSP_SETT_ID_MAX);
    switch(dspSettId)
    {
      case DSP_VOLUME_SETT_ID:
        {
          if(enable)
          {
            /* Convert it to positive */
            uint8 volume = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION+MAX_VOLUME;
            DSPDrv_SetVol(me,volume);
          }
          else
          {
            DSPDrv_SetVol(me,0);
          }
        }
        break;
      case DSP_EQ_CTRL_RGC:
        {
          uint16        freq;
          eUserRGCSlope slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserRGCSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
          DSPDrv_SetRGC(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_USER_LP:
        {
          uint16         freq;
          eUserLpSlope  slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserLpSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
          DSPDrv_SetUserLp(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_USER_HP:
        {
          uint16         freq;
          eUserHpSlope  slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserHpSlope)((pSettData[ctrIdEQIdMap[i].dbIndex+1])/VALUE_MAGNIFICATION);
          DSPDrv_SetUserHp(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_PEQ1:
      case DSP_EQ_CTRL_PEQ2:
      case DSP_EQ_CTRL_PEQ3:
        DSPDrv_SetPeq(me, DSP_EQ_CTRL_PEQ1, i, enable);
        break;
      case DSP_PHASE_SETT_ID:
        DSPDrv_SetPhase(me, (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION);
        break;
      case DSP_POLARITY_SETT_ID:
         DSPDrv_SetPolarity(me, (ePolarityType)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
         break;
      case DSP_TUNNING_SETT_ID:
        DSPDrv_SetTuning(me, (eTuningRange)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
        break;
      default:break;
    }
}

/************************************************************
**************private functions******************************
*************************************************************/

static void DSPDrv_Delay(uint16 count)
{
    while(count--)
    {
        asm("nop");
        asm("nop");
    }

}

static void DSPDrv_I2cRead(uint8 device_add, uint32 regAddr, uint16 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = device_add,
        .regAddr = regAddr,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };
    I2CDrv_MasterRead(&dspI2c, &i2cMsg);
}


/**
 * Write data to DSP by I2C.
 *
 * @param      uint8           device I2C address
 *
 * @param      uint8           data byte number
 *
 * @param      const uint8*    pointer to data array
 *
 * @return     void
 */
static void DSPDrv_I2cWrite(uint8 device_add, uint8 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = device_add,
        .regAddr = NULL,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };

    I2CDrv_MasterWrite(&dspI2c, &i2cMsg);
}

/**
 * Safeload process
 *
 * @param      uint8                data length in word(4 bytes)
 * @param      uint8*               data array
 * @param      uint16               target address
 * @return     void
 */
static void DspDrv_SafeLoadData(cDSPDrv *me, uint8 num, const uint8 *array, uint16 addr)
{
    uint8  temp[6] = {0};
    uint16 curr_ptr;
    uint8  currIdx, curr_cnt;
    ASSERT(me->pI2CConfig->address);
    ASSERT((num <= SAFE_LOAD_DATA_SIZE_MAX) && (num > 0));
    /* step1: set modulo size */
    curr_ptr = SAFE_LOAD_MODULO_SIZE_ADD;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);

    curr_ptr++;
    currIdx = 0;
    /* step2: write safeload data */
    while(currIdx < num * 4)
    {
        temp[0] = (curr_ptr & 0xff00) >> 8;
        temp[1] = curr_ptr & 0x00ff;
        for(curr_cnt = 0; curr_cnt < 4; curr_cnt++)
        {
            temp[curr_cnt + 2] = array[currIdx];
            currIdx++;
        }
        curr_ptr++;
        DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
    }

    curr_ptr = SAFE_LOAD_ADD_FOR_TARGET_ADD;
    
    /* step3: write target addr */
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[2] = 0;
    temp[3] = 0;
    temp[4] = (((addr - 1)& 0xff00) >> 8);
    temp[5] = (addr - 1) & 0x00ff;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);

    /* step4: trigger safeload */
    curr_ptr++;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DSPDrv_I2cWrite(me->pI2CConfig->address, sizeof(temp), temp);
}

/**
 * Get the controller address(page + register number) from the
 * DSP_Tunable_Tab in ROM
 *
 * @param      tTunableInfo    caller needs to provide the tab start addr
 *                             and the controller type
 *
 * @return     void
 */
static void DSPDrv_GetCtrlAddr(tTunableInfo *p)
{
    const uint8* curr_ptr;
    uint16       array_num, currIdx;
    uint8        array_len, block_num;

    curr_ptr = p->head + TABLE_TYPE_INIT_OFF;
    /* go through the table to find the ctrl */
    ASSERT(*curr_ptr == TABLE_TYPE_TUNABLE_LSB);

    curr_ptr = p->head + CHIP_MODEL_NO_OFF;
    ASSERT(*curr_ptr == MODEL_AIC3254);

    /* get the array number */
    curr_ptr = p->head + ARRAY_NUM_OFF;
    array_num =  *curr_ptr;
    curr_ptr++;
    array_num += (*curr_ptr << 8);

    ASSERT(array_num);

    /* Go through all the arrays */
    curr_ptr = (p->head) + ARRAY_START_OFF;
    for(currIdx = 0; currIdx < array_num; currIdx++)
    {
        array_len = *curr_ptr;
        curr_ptr++;
        if(*curr_ptr == (p->type))
        {
            /* get the number of the controller block in the same type in one array */
            curr_ptr++;
            block_num = *curr_ptr;
            ASSERT(p->id < block_num);

            /* get the address of the controller blok */
            /* the id0 address */
            curr_ptr++;
            p->addr = *(curr_ptr + 2*(p->id));
            p->addr = (p->addr) << 8;
            p->addr |= *(curr_ptr + 2*(p->id) + 1);

            return;
        }

        curr_ptr += array_len;
    }

    /* can't find the ctrl info */
    ASSERT(currIdx < array_num);
}

/**
 * Check the magic number in head of the DSP_Init_Tab or DSP_Tunable_Tab
 *
 * @param      uint8*          pointer to the table head
 *
 * @return     void
 */
static void DSPDrv_ChkMagicNum(const uint8 *p)
{
    uint8 magic_num[MAGIC_NUMBER_NUM];

    memcpy(magic_num, p, MAGIC_NUMBER_NUM);

    ASSERT((magic_num[0] == MAGIC_NUMBER_EVEN) && (magic_num[2] == MAGIC_NUMBER_EVEN)
           && (magic_num[4] == MAGIC_NUMBER_EVEN) && (magic_num[6] == MAGIC_NUMBER_EVEN)
           && (magic_num[1] == MAGIC_NUMBER_ODD) && (magic_num[3] == MAGIC_NUMBER_ODD)
           && (magic_num[5] == MAGIC_NUMBER_ODD) && (magic_num[7] == MAGIC_NUMBER_ODD));
}

static void DSPDrv_DispatchRawData(cDSPDrv *me)
{
    uint16  regAddress;
    uint8   dly_arr[8];
    uint8   data_arr[PROGRAM_RAM_PAGE_SIZE*PROGRAM_RAM_DATA_LEN+REG_ADDRESS_LEN];

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_1)||(initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_4))
    {
        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        regAddress = (*(initTableTxCtrl.pOffset + 1))&0x0F;
        regAddress <<= 8;
        regAddress |= *((initTableTxCtrl.pOffset)+2);
    
        if (initTableTxCtrl.tableRowNum == 0)          /* for STAGE_4 or in case slot_num is equal to 0 */
        {
            break;
        }

       if ((regAddress <= PROGRAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(regAddress >= PROGRAM_RAM_ADDRESS_LOW_BOUNDARY))        /* go to PROGRAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_2;
            break;
        }
        initTableTxCtrl.pOffset++;
        /* check whether it is a slot of time delay */
        if ((*(initTableTxCtrl.pOffset) == DELAY_SLOT_DATA0) && (*(initTableTxCtrl.pOffset-1) == DELAY_SLOT_NUM))
        {
            /* copy all the data */
            memcpy(dly_arr, initTableTxCtrl.pOffset, DELAY_SLOT_NUM);

            if((dly_arr[1] == DELAY_SLOT_DATA0) && (dly_arr[2] == DELAY_SLOT_DATA0)
               && (dly_arr[4] == DELAY_SLOT_DATA0) && (dly_arr[5] == DELAY_SLOT_DATA0)
               && (dly_arr[6] == DELAY_SLOT_DATA0) && (dly_arr[7] == DELAY_SLOT_DATA1))
            {
                DSPDrv_Delay(RESET_DELAY_PER_UNIT * dly_arr[3]);
                initTableTxCtrl.tableRowNum--;
            }
        }
        else
        {
            ASSERT(*(initTableTxCtrl.pOffset) <= sizeof(data_arr));
            memcpy(data_arr, initTableTxCtrl.pOffset, initTableTxCtrl.NumOfDataInRow);
            DSPDrv_I2cWrite(me->pI2CConfig->address, initTableTxCtrl.NumOfDataInRow, data_arr);
            initTableTxCtrl.tableRowNum--;
        }
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;
    }
}

static void DSPDrv_DispatchZipProgramData(cDSPDrv *me)
{
    const uint8* curr_ptr;
    uint32 pos_data = 0;
    uint8 curr_array[PROGRAM_RAM_PAGE_SIZE*PROGRAM_RAM_DATA_LEN+REG_ADDRESS_LEN] = {0, 0};
    uint8 cnt = 0;
    uint8 tail_zero_num;
    int16 reg_address;

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_2))
    {
        memset(curr_array, 0, sizeof(curr_array));
        
        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        /* get the first byte as the start address */
        curr_ptr = initTableTxCtrl.pOffset;
        curr_ptr++;
        tail_zero_num = ((*curr_ptr & 0xF0) >> 4);

        reg_address = (*curr_ptr)&0x0F;
        reg_address <<= 8;
        curr_ptr++;
        reg_address |= *(curr_ptr);

        if ((reg_address <= PARAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(reg_address >= PARAM_RAM_ADDRESS_LOW_BOUNDARY))        /* go to PARAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_3;
            break;
        }

        initTableTxCtrl.pOffset++;

        /* get the pos data */
        curr_ptr++;
        memcpy((uint8*)(&pos_data), curr_ptr, POS_DATA_BYTE_LEN);
        curr_ptr += POS_DATA_BYTE_LEN;

        if(!pos_data)
        {
            /* There is something wrong with the coef data!!*/
            ASSERT(0);
            return;
        }

        cnt = 0;
        curr_array[cnt] = (reg_address >> SHIFT_EIGHT_BIT);
        cnt++;
        curr_array[cnt] = (reg_address & MASK_LOW_BYTE);
        cnt++;

        /* go throught the pos_data, copy the data according to the pos_data */
        while (cnt < 32*5+2)
        {
            if(!pos_data)
            {
                /* There is something wrong with the coef data!!*/
                ASSERT(0);
                break;
            }
            if(pos_data & 0x01)
            {
                /* if this bit is 1 */
                memcpy(&(curr_array[cnt]), curr_ptr, PROGRAM_RAM_DATA_LEN);
                curr_ptr += PROGRAM_RAM_DATA_LEN;
            }

            pos_data = (pos_data >> 1);
            cnt += PROGRAM_RAM_DATA_LEN;
        }

        /* sends out by I2C */
        cnt += tail_zero_num * PROGRAM_RAM_DATA_LEN;
        DSPDrv_I2cWrite(me->pI2CConfig->address, cnt, curr_array);
        initTableTxCtrl.tableRowNum--;
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;
    }
}


static void DSPDrv_DispatchZipPARAMData(cDSPDrv *me)
{
    const uint8* curr_ptr;
    uint32 pos_data = 0;
    uint8 curr_array[PARAM_RAM_PAGE_SIZE*PARAM_RAM_DATA_LEN+REG_ADDRESS_LEN] = {0, 0};
    uint8 cnt = 0;
    uint8 tail_zero_num;
    int16 reg_address;

    while ((initTableTxCtrl.dataSegment == INIT_DATA_SEGMENT_3))
    {
        memset(curr_array, 0, sizeof(curr_array));
        
        initTableTxCtrl.NumOfDataInRow = *(initTableTxCtrl.pOffset);

        /* get the first byte as the start address */
        curr_ptr = initTableTxCtrl.pOffset;
        curr_ptr++;
        tail_zero_num = ((*curr_ptr & 0xF0) >> 4);

        reg_address = (*curr_ptr)&0x0F;
        reg_address <<= 8;
        curr_ptr++;
        reg_address |= *(curr_ptr);

        if (!((reg_address <= PARAM_RAM_ADDRESS_HIGH_BOUNDARY)&&(reg_address >= PARAM_RAM_ADDRESS_LOW_BOUNDARY)))        /* go to PARAM DATA */
        {
            initTableTxCtrl.dataSegment = INIT_DATA_SEGMENT_4;
            break;
        }

        initTableTxCtrl.pOffset ++;

        /* get the pos data */
        curr_ptr++;
        memcpy((uint8*)(&pos_data), curr_ptr, POS_DATA_BYTE_LEN);
        curr_ptr += POS_DATA_BYTE_LEN;

        if(!pos_data)
        {
            /* There is something wrong with the coef data!!*/
            ASSERT(0);
            return;
        }

        cnt = 0;
        curr_array[cnt] = (reg_address >> SHIFT_EIGHT_BIT);
        cnt++;
        curr_array[cnt] = (reg_address & MASK_LOW_BYTE);
        cnt++;

        /* go throught the pos_data, copy the data according to the pos_data */
        while (cnt < PARAM_RAM_PAGE_SIZE*PARAM_RAM_DATA_LEN+REG_ADDRESS_LEN)
        {
            if(!pos_data)
            {
                /* There is something wrong with the coef data!!*/
                ASSERT(0);
                break;
            }
            if(pos_data & 0x01)
            {
                /* if this bit is 1 */
                memcpy(&(curr_array[cnt]), curr_ptr, PARAM_RAM_DATA_LEN);
                curr_ptr += PARAM_RAM_DATA_LEN;
            }

            pos_data = (pos_data >> 1);
            cnt += PARAM_RAM_DATA_LEN;
        }

        /* sends out by I2C */
        cnt += tail_zero_num * PARAM_RAM_DATA_LEN;
        DSPDrv_I2cWrite(me->pI2CConfig->address, cnt, curr_array);
        initTableTxCtrl.tableRowNum--;
        initTableTxCtrl.pOffset += initTableTxCtrl.NumOfDataInRow;
    }
}

/**
 * Load the DSP_Init_Tab into DSP
 *
 * @param      void
 *
 * @return     void
 */
static void DSPDrv_DispatchDspConfigData(cDSPDrv *me)
{
    ASSERT(me->pI2CConfig->address);
    /* check magic number in the head */
    DSPDrv_ChkMagicNum((uint8*)dsp_init_tab);

    /* Got the number of slot from DSP data */
    initTableTxCtrl.tableRowNum = dsp_init_tab[ARRAY_NUM_OFF]; // get the lower byte
    initTableTxCtrl.tableRowNum += (dsp_init_tab[ARRAY_NUM_OFF + 1] << 8);

    initTableTxCtrl.pOffset = dsp_init_tab + ARRAY_START_OFF;

    DSPDrv_DispatchRawData(me);
    DSPDrv_DispatchZipProgramData(me);
    DSPDrv_DispatchZipPARAMData(me);
    DSPDrv_DispatchRawData(me);
}

static void DSPDrv_InitSection0(void *p)
{
    cDSPDrv* me = (cDSPDrv*)p;
    /* If the device type is I2C, create the DSP I2C object */
    if (me->pI2CConfig->deviceInfo.deviceType == I2C_DEV_TYPE)
    {
        I2CDrv_Ctor(&dspI2c,me->pI2CConfig);
    }
}

static void DSPDrv_InitSection1(void *p)
{
    cDSPDrv* me = (cDSPDrv*)p;
    DSPDrv_DispatchDspConfigData(me);
}

/**
 * Format input int32 data array into array of uint8, according to the designated number of int32
 *
 * @param      int32*          start address of the input int32 array
 *
 * @param      uint8*          output data array pointer
 *
 * @param      uint8           number of input int32 data
 *
 * @return     void
 */
static void DSPDrv_FormatFiltData(int32* in, uint8* out, uint8 num)
{
    uint32        temp;
    uint8          cnt;
    int32*        ptr0;
    uint8*        ptr1;

    ptr0 = in;
    ptr1 = out;

    for(cnt = 0; cnt < num; cnt++)
    {
        temp  = (uint32)(*ptr0);
        *ptr1 = (uint8)((temp >> 24) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 16) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 8) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)(temp & 0xFF);
        ptr1++;
        ptr0++;
    }
}

/**
 * This function is used to convert filter Parameter (Q factor, center freq, etc) into 5 DSP parameters
 *
 * @param   tDspFiltRawParam                 the filter parameter raw input
 * @param   uint8*                           pointer to the output data
 * @return  void
 */
static void DSPDrv_CalFiltParam(tDspFiltRawParam in, uint8* out)
{
    /* calculate common param for all filter */
    double w0 = 2.0*PI*in.freq/DSP_SAMPLING_FREQ;
    double A = pow(10.0, in.boost/40.0);
    double gainLinear = pow(10.0, in.gain/20.0);
    double a0, a1, a2, b0, b1, b2, S, alpha;
    int32  temp[EQ_CTRL_RAM_SLOT_NUM];

    S = in.q;
    if(in.en == FALSE)
    {
        temp[0] = 0x00800000;
        temp[1] = 0x00000000;
        temp[2] = 0x00000000;
        temp[3] = 0x00000000;
        temp[4] = 0x00000000;
        /* change the data from int32 to uint8 */
        DSPDrv_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
        return;
    }
    else if(in.q == 0)
    {
        S = 0.05;
    }

    switch(in.type)
    {
#ifdef HAS_PEAKING_FILTER
        case FILTER_TYPE_PEAKING:
        {
            alpha = sin(w0) / (2.0 * S);

            a0 = 1.0 + alpha / A;
            a1 = -2.0 * cos(w0);
            a2 = 1.0 - alpha / A;
            b0 = (1.0 + alpha * A) * gainLinear;
            b1 = - ( 2.0 * cos(w0)) * gainLinear;
            b2 = ( 1.0 - A * alpha) * gainLinear;
            
            /*  speical behavior when speical inputs
             *  (inspired by Sigma Studio outputs)
             * */
            if(in.boost == 0.00)
            {
                b1=0;
                b2=0;
                a1=0;
                a2=0;
            }
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_LOW_SHELF_FILTER
        case FILTER_TYPE_TONE_LOW_SHELF:
        {
            alpha = (sin(w0)/ 2 ) * sqrt( ( A + 1/A ) * ( 1 / S - 1) + 2);
            a0 = (A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 =  -2*( (A-1) + (A+1)*cos(w0) );
            a2 = (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha;
            b0 =  A*( (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha ) * gainLinear;
            b1 = 2*A*( (A-1) - (A+1)*cos(w0) ) * gainLinear;
            b2 =  A*( (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha ) * gainLinear;
            
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_HIGH_SHELF_FILTER
        case FILTER_TYPE_TONE_HIGH_SHELF:
        {
            alpha = (sin(w0)/2)*sqrt((A+1/A)*(1/S-1)+2);
            a0 = (A+1)-(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 = 2*((A-1)-(A+1)*cos(w0));
            a2 = (A+1)-(A-1)*cos(w0)-2*sqrt(A)*alpha;
            b0 = A*((A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha)*gainLinear;
            b1 = -2*A*((A-1)+(A+1)*cos(w0))*gainLinear;
            b2 = A*((A+1)+(A-1)*cos(w0)-2*sqrt(A)*alpha)*gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_LOW_PASS_FILTER
        case FILTER_TYPE_GENERAL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = (1-cos(w0))*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_HIGH_PASS_FILTER
        case FILTER_TYPE_GENERAL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_LOW_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_LOW_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_HIGH_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_HIGH_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2.0*cos(w0);
            a2 = 1.0-alpha;
            b0 = (1.0+cos(w0))*gainLinear/2.0;
            b1 = -(1.0+cos(w0))*gainLinear;
            b2 = (1.0+cos(w0))*gainLinear/2.0;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_LOW_PASS_FILTER
        case FILTER_TYPE_BESSEL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_HIGH_PASS_FILTER
        case FILTER_TYPE_BESSEL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_LOW_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_LOW_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * (1.0 - a1);
            b1 = 0;
            b2 = 0;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_HIGH_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_HIGH_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * a1;
            b1 = 0 - b0;
            b2 = 0;
        }
        break;
#endif
        default:
        {
            /* wrong data in */
            ASSERT(0);
        }
        break;
    }

    /* check data */
    ASSERT((a1 > -16.0) && (a1 < 15.99));
    ASSERT((a2 > -16.0) && (a2 < 15.99));
    ASSERT((b0 > -16.0) && (b0 < 15.99));
    ASSERT((b1 > -16.0) && (b1 < 15.99));
    ASSERT((b2 > -16.0) && (b2 < 15.99));

    /* feed into output structure */
    temp[0] = (int32)(b0*(1L << 23));
    temp[1] = (int32)(b1*(1L << 23));
    temp[2] = (int32)(b2*(1L << 23));
    temp[3] = (int32)(a1*(1L << 23));
    temp[4] = (int32)(a2*(1L << 23));

     /* change the data from int32 to uint8 */
    DSPDrv_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}

/**
 * Set BGC
 *
 * @param      int8            boost
 * @param      bool            enable or disable
 * @return     void
 */
static void DSPDrv_SetRGC(cDSPDrv *me, uint16 freq, eUserRGCSlope slope, bool en)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];
    tTunableInfo      tunData;
    uint8             currIdx;

    tunData.head     = dsp_tunable_tab;
    tunData.type     = ARRAY_TYPE_EQ;
    rawData.freq     = freq;
    rawData.boost    = RGC_BOOST;
    rawData.gain     = RGC_GAIN;
    rawData.q        = RGC_QFACTOR;
    rawData.en       = en;

    /* get the start addr */
    for(currIdx = 0; currIdx < EQ_CTRL_NUM; currIdx++)
    {
        if(EQ_TRANS_TAB[currIdx].name== DSP_EQ_CTRL_RGC)
        {
            rawData.type = EQ_TRANS_TAB[currIdx].type;
            tunData.id   = EQ_TRANS_TAB[currIdx].id;

            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    DSPDrv_GetCtrlAddr(&tunData);

    /* cal out the EQ data */
    DSPDrv_CalFiltParam(rawData, finalData);
        /* check slope */
    switch(slope)
    {
        case USER_RGC_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_RGC_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        default:
            ASSERT(0);
            break;
    }

    uint8 i = 0;
    for(i = 0; i < NUM_OF_RGC_SET_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv_SafeLoadData(me,EQ_CTRL_RAM_SLOT_NUM, finalData, tunData.addr);
        }
        else
        {
            DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, tunData.addr);
        }
        tunData.addr += EQ_CTRL_RAM_SLOT_NUM;
    }
}

/**
 * Set User LP
 *
 * @param      int8            boost
 * @param      eUserLpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DSPDrv_SetUserLp(cDSPDrv *me, uint16 freq, eUserLpSlope slope, bool en)
{
    tDspFiltRawParam     rawData;
    uint8                finalData[EQ_CTRL_RAM_BYTE_NUM];
    tTunableInfo         tunData;
    uint8                currIdx;

    tunData.head        = dsp_tunable_tab;
    tunData.type        = ARRAY_TYPE_EQ;
    rawData.freq        = freq;
    rawData.boost       = USER_LP_BOOST;
    rawData.gain        = USER_LP_GAIN;
    rawData.q           = USER_LP_QFACTOR;
    rawData.en          = en;

    /* get the start addr */
    for(currIdx = 0; currIdx < EQ_CTRL_NUM; currIdx++)
    {
        if(EQ_TRANS_TAB[currIdx].name== DSP_EQ_CTRL_USER_LP)
        {
            rawData.type = EQ_TRANS_TAB[currIdx].type;
            tunData.id   = EQ_TRANS_TAB[currIdx].id;

            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    DSPDrv_GetCtrlAddr(&tunData);

    /* cal out the EQ data */
    DSPDrv_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_LP_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_LP_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        case USER_LP_SLOPE_18DB:
            currIdx = CTR_ADDR_GROUP_3;
            break;

        case USER_LP_SLOPE_24DB:
            currIdx = CTR_ADDR_GROUP_4;
            break;

        default:
            ASSERT(0);
            break;
    }

    uint8 i = 0;
    for(i = 0; i < NUM_OF_FILTER_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, tunData.addr);
        }
        else
        {
            DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, tunData.addr);
        }
        tunData.addr += EQ_CTRL_RAM_SLOT_NUM;
    }
}

/**
 * Set User HP
 *
 * @param      int8            boost
 * @param      eUserHpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DSPDrv_SetUserHp(cDSPDrv *me, uint16 freq, eUserHpSlope slope, bool en)
{
    tDspFiltRawParam     rawData;
     uint8               finalData[EQ_CTRL_RAM_BYTE_NUM];
    tTunableInfo         tunData;
    uint8                currIdx;

    tunData.head         = dsp_tunable_tab;
    tunData.type         = ARRAY_TYPE_EQ;
    rawData.freq         = freq;
    rawData.boost        = USER_HP_BOOST;
    rawData.gain         = USER_HP_GAIN;
    rawData.q            = USER_HP_QFACTOR;
    rawData.en           = en;

    /* get the start addr */
    for(currIdx = 0; currIdx < EQ_CTRL_NUM; currIdx++)
    {
        if(EQ_TRANS_TAB[currIdx].name== DSP_EQ_CTRL_USER_HP)
        {
            rawData.type = EQ_TRANS_TAB[currIdx].type;
            tunData.id   = EQ_TRANS_TAB[currIdx].id;

            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    DSPDrv_GetCtrlAddr(&tunData);

    /* cal out the EQ data */
    DSPDrv_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_HP_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_HP_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        case USER_HP_SLOPE_18DB:
            currIdx = CTR_ADDR_GROUP_3;
            break;

        case USER_HP_SLOPE_24DB:
            currIdx = CTR_ADDR_GROUP_4;
            break;

        default:
            ASSERT(0);
            break;
    }

    uint8 i = 0;
    for(i = 0; i < NUM_OF_FILTER_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, tunData.addr);
        }
        else
        {
            DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, tunData.addr);
        }
        tunData.addr += EQ_CTRL_RAM_SLOT_NUM;
    }
}

/**
 * Set Tuning
 *
 * @param      eTuningRange           range
 * @return     void
 */
static void DSPDrv_SetTuning(cDSPDrv *me, eTuningRange range)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];
    tTunableInfo      tunData;
    uint8             currIdx;

    tunData.head      = dsp_tunable_tab;
    tunData.type      = ARRAY_TYPE_EQ;
    rawData.freq      = TUNING_FREQ;
    rawData.gain      = TUNING_GAIN;
    rawData.q         = TUNING_QFACTOR;

    /* get the start addr */
    for(currIdx = 0; currIdx < EQ_CTRL_NUM; currIdx++)
    {
        if(EQ_TRANS_TAB[currIdx].name== DSP_EQ_CTRL_TUNING)
        {
            rawData.type = EQ_TRANS_TAB[currIdx].type;
            tunData.id   = EQ_TRANS_TAB[currIdx].id;
            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    DSPDrv_GetCtrlAddr(&tunData);

    /* check range */
    switch(range)
    {
        case TUNING_RANGE_20HZ:
            rawData.boost = TUNING_BOOST0;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_16HZ:
            rawData.boost = TUNING_BOOST1;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_SEALED:
            rawData.en    = FALSE;
            break;

        default:
            ASSERT(0);
            break;
    }

    /* cal out the EQ data */
    DSPDrv_CalFiltParam(rawData, finalData);
    DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, tunData.addr);
}

/**
 * Set PEQ
 *
 * @param      eDspSettId       dsp setting ID
 * @param      uint8            the setting position in ctrIdEQIdMap
 * @param      enable           Enable or disable the settings
 */
static void DSPDrv_SetPeq(cDSPDrv *me, eDspSettId dspSettId,uint8 settIndex, BOOL enable)
{
    tDspFiltRawParam rawData;
    uint8            finalData[EQ_CTRL_RAM_BYTE_NUM];
    tTunableInfo     tunData;
    uint8            currIdx;

    tunData.head  = dsp_tunable_tab;
    tunData.type  = ARRAY_TYPE_EQ;
    rawData.gain  = PARAM_EQ_GAIN;

    rawData.freq = (pSettData[ctrIdEQIdMap[settIndex].dbIndex])/VALUE_MAGNIFICATION;
    rawData.boost = (pSettData[ctrIdEQIdMap[settIndex].dbIndex+1])/VALUE_MAGNIFICATION;;
    rawData.q = (pSettData[ctrIdEQIdMap[settIndex].dbIndex+2])/VALUE_MAGNIFICATION;;
    rawData.en = enable;
    /* get the start addr */
    for(currIdx = 0; currIdx < EQ_CTRL_NUM; currIdx++)
    {
        if(EQ_TRANS_TAB[currIdx].name== dspSettId)
        {
            rawData.type = EQ_TRANS_TAB[currIdx].type;
            tunData.id   = EQ_TRANS_TAB[currIdx].id;
            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);

    DSPDrv_GetCtrlAddr(&tunData);
    DSPDrv_CalFiltParam(rawData, finalData);

    switch(dspSettId)
    {
        case DSP_EQ_CTRL_PEQ1:
          {
            currIdx = ADDR_OFFSET_0;
          }
            break;
        case DSP_EQ_CTRL_PEQ2:
          {
            currIdx = ADDR_OFFSET_1;
          }
            break;

        case DSP_EQ_CTRL_PEQ3:
          {
            currIdx = ADDR_OFFSET_2;
          }
            break;

        default:
            ASSERT(0);
            break;
    }
    uint8 i = 0;
    while(i < PARAMETRIC_EQ_MAX)
    {
      if(i == currIdx)
      {
          /* Set the right parametric EQ */
          DspDrv_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, tunData.addr);
      }
      tunData.addr += EQ_CTRL_RAM_SLOT_NUM;
      i++;
    }
}

static void DSPDrv_SetPolarity(cDSPDrv *me, ePolarityType polarityType)
{
    uint8    temp[4] = {0};
    /* get addr */
    tTunableInfo    tun_info;

    tun_info.head = dsp_tunable_tab;
    tun_info.type = ARRAY_TYPE_POL;
    tun_info.id   = 0;
    DSPDrv_GetCtrlAddr(&tun_info);
    temp[0] = 0x00;
    temp[1] = 0x80;
    temp[2] = 0x00;
    temp[3] = 0x00;
    if(polarityType == POLARITY_NEGATIVE)
    {
        temp[0] = 0xFF;
    }
    DspDrv_SafeLoadData(me, 1, temp, tun_info.addr);
}

/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */
static void DSPDrv_SetPhase(cDSPDrv *me, uint8 phaseShift)
{
    uint8    temp[4] = {0};
    uint16       tmp = 0;
    /* get addr */
    tTunableInfo    tun_info;

    tun_info.head = dsp_tunable_tab;
    tun_info.type = ARRAY_TYPE_DELAY;
    tun_info.id   = 0;
    DSPDrv_GetCtrlAddr(&tun_info);

    /* set data */
    tmp = phaseShift * MAX_DELAY_SAMPLES;
    temp[0] = 0x00;
    temp[1] = 0x00;
    temp[2] = ((tmp/180)& 0xff00) >> 8;
    temp[3] = (tmp/180)& 0x00ff;
    if(phaseShift == 0)
    {
        temp[3] = NO_PHASE_SHIFT;
    }

    DspDrv_SafeLoadData(me, 1, temp, tun_info.addr);
}

/* 
 * Below are the public functions which are not used in SVS but have to
 * be declared to supress compiling errors
 */

BOOL DSPDrv_IsAuxin(cDSPDrv *me)                                                                                                                                                                                                                                                                                                              
{
    return FALSE;
}

/**
 * Detect whether there is a input present
 *
 * @param
 * @return     bool    If the music is present either source depending on the DSP flow design
 */

BOOL DSPDrv_HasMusicStream(cDSPDrv *me)
{
    BOOL         ret = FALSE;
    uint8        readDataFromDsp[ADAU1761_AUDIO_DETECT_LEN + 1] = {0};
    tTunableInfo tunData;

    tunData.head        = dsp_tunable_tab;
    tunData.type        = ARRAY_TYPE_MUS_DET;
    tunData.id          = 0;// There is only one control ID

    /* get the addr */
    DSPDrv_GetCtrlAddr(&tunData);
    /* read audio detection */
    DSPDrv_I2cRead(me->pI2CConfig->address, tunData.addr, ADAU1761_AUDIO_DETECT_LEN, (uint8*)&readDataFromDsp);

    if (AUDIO_DETECTED == readDataFromDsp[1])
    {
        ret = TRUE;
    }
    else if (AUDIO_NOT_DETECTED == readDataFromDsp[1])
    {
        ret = FALSE;
    }
    else
    {
        ret = FALSE;
    }

    return ret;
}


void DSPDrv_set_Input(cDSPDrv *me, eAudioCtrlDriverInput input)
{
}

int DSPDrv_setStereoMux(cDSPDrv *me, eDspMuxChannel ch)
{
    return 0;
}

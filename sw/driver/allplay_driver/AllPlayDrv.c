/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  AllPlay Driver
                  -------------------------

                  SW Module Document




@file        AllPlayDrv.c
@brief       The all play driver provides low-level connectivity to the allplay/alljoyn module
@author      Chris Alexander 
@date        2014-02-10
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-02-10     Chris Alexander 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :  
-------------------------------------------------------------------------------
*/

#include "./AllPlayDrv_priv.h"
#include "trace.h"
#include "UartDrv.h"
#if defined(HAS_LEDS_RGB_REMOTE_CTRL) || defined(HAS_GRAPHICAL_EQ_REMOTE_CTRL)
#include "SettingSrv.h"
#endif

/* Private functions / variables. Declare and drivers here */
allplay_ctx_t* apctx;   // keep this for cli / debug server
static uint8_t*     allPlayDrv_CurBuf;
static uint32_t     allPlayDrv_CurBufSize;
static AJ_SerIORxCompleteFunc   allPlayDrv_RxCb = NULL;

static uint32_t     allplayDrv_delimiterCnt = 0;




/* Sample AllJoyn interface to show how to expose a method and send a signal
*
*
*
*
*
 */

#define MCU_SERVICE_NAME_PREFIX "com.allplay.mcu.service.sample"
#define MCU_SERVICE_PATH "/samplePath"
#define SERVICE_PORT ((uint16_t)101)

#define AUTH_PIN 654321

AJ_BusAttachment *bus;
uint32_t sessionId = 0;
char* serviceName = NULL;

static const char* ledInterface[] = {
    "$com.allplay.mcu.service.interface.led", //Secure interface
    "?setLedColor <i gValue<i bValue<i",
    "!aSignal value>i",
    "?getLedColor colors>i",
    NULL
};

static const char* eqInterface[] = {
    "$com.allplay.mcu.service.interface.eq", //Secure interface
    "?setGraphicalEq gain1<i gain2<i gain3<i gain4<i gain5<i",
    "!aEqSignal gain1>i gain2>i gain3>i gain4>i gain5>i",
    "?getGraphicalEq gain1>ai",
    NULL
};

static const AJ_InterfaceDescription mucServiceInterfaces[] = {
    ledInterface,
        eqInterface,
    NULL
};

static const AJ_Object MyObjects[] = {
    { MCU_SERVICE_PATH, mucServiceInterfaces, 0 },
    { NULL, NULL, 0 }
};

#define SET_LED_COLOR AJ_APP_MESSAGE_ID(0, 0, 0)
#define A_SIGNAL AJ_APP_MESSAGE_ID(0, 0, 1)
#define GET_LED_COLOR AJ_APP_MESSAGE_ID(0, 0, 2)

#define SET_GRAPHICAL_EQ AJ_APP_MESSAGE_ID(0, 1, 0)
#define A_EQ_SIGNAL AJ_APP_MESSAGE_ID(0, 1, 1)
#define GET_GRAPHICAL_EQ AJ_APP_MESSAGE_ID(0, 1, 2)
/* End of AllJoyn service setup
 *
 *
 *
 */

void sendLedSignal(int color)
{
    AJ_Message msg;
    AJ_Status status;

    // Check that we have someone connected, IE the sessionId has been set in our multipoint session
    if (sessionId == 0) {
        return;
    }
    AJ_Printf("Sending a color update signal on session id: %u, color: %d\n", sessionId, color);

    status = AJ_MarshalSignal(bus, &msg, A_SIGNAL, NULL, sessionId, 0, 0);
    if (status == AJ_OK) {
        status = AJ_MarshalArgs(&msg, "i", color);
    }
    if (status == AJ_OK) {
        status = AJ_DeliverMsg(&msg);
    }
    /*
    if (status != AJ_OK) {
        AJ_Printf("Failed to send the signal %d\n", status);
    } else {
        AJ_Printf("Sent the signal\n");
    }
    */
}

void sendEqSignal(const int *gains)
{
    AJ_Message msg;
    AJ_Status status;

    // Check that we have someone connected, IE the sessionId has been set in our multipoint session
    if (sessionId == 0) {
        return;
    }
    AJ_Printf("Sending a eq update signal on session id: %u, gain0: %d gain1: %d gain2: %d gain3: %d gain4: %d\n",
                sessionId, gains[0], gains[1], gains[2], gains[3], gains[4]);

    status = AJ_MarshalSignal(bus, &msg, A_EQ_SIGNAL, NULL, sessionId, 0, 0);
    if (status == AJ_OK) {
        status = AJ_MarshalArgs(&msg, "iiiii", gains[0], gains[1], gains[2], gains[3], gains[4]);
    }
    if (status == AJ_OK) {
        status = AJ_DeliverMsg(&msg);
    }

    if (status != AJ_OK) {
        AJ_Printf("Failed to send the signal %d\n", status);
    } else {
        AJ_Printf("Sent the signal\n");
    }

}

/* AllJoyn callback to setup the service and process the messages */
static uint32_t PasswordCallback(uint8_t* buffer, uint32_t bufLen)
{
    char pinStr[16];
    size_t pinLength = 0;

    pinLength = sprintf(pinStr, "%06d", AUTH_PIN);

    if(pinLength < bufLen) {
        memcpy(buffer, pinStr, pinLength+1);
        return (uint32_t)pinLength;
    }
    return 0;
}

void AuthCallback(const void* UNUSED(context), AJ_Status status)
{
    AJ_Printf("AuthCallback: %d - %s\n", status, AJ_StatusText(status));
}



bool_t myProcessMessage(AJ_Message *ajMsg)
{
    AJ_Status status;
    if (ajMsg->hdr == NULL) {
        return FALSE;
    }
    switch(ajMsg->msgId)
    {
        case AJ_REPLY_ID(AJ_METHOD_BIND_SESSION_PORT):
            if (ajMsg->hdr->msgType == AJ_MSG_ERROR) {
                AJ_ErrPrintf(("AJ_METHOD_BIND_SESSION_PORT: AJ_ERR_FAILURE\n"));
                //Setup the sessoin options
                AJ_SessionOpts opts;
                opts.isMultipoint = 1;
                opts.traffic = 0x1;
                opts.transports = 0xFFFF;
                opts.proximity = 0xFF;

                //Start the process of setting up the service (Bind -> RequestName -> AdvertiseName)
                AJ_BusBindSessionPort(bus, SERVICE_PORT, &opts, 0);

            } else {
                status = AJ_BusRequestName(bus, serviceName, AJ_NAME_REQ_DO_NOT_QUEUE);
            }
            return TRUE;
        case AJ_REPLY_ID(AJ_METHOD_REQUEST_NAME):
            if (ajMsg->hdr->msgType == AJ_MSG_ERROR) {
                AJ_ErrPrintf(("AJ_METHOD_REQUEST_NAME: AJ_ERR_FAILURE\n"));
            } else {
                status = AJ_BusAdvertiseName(bus, serviceName, AJ_TRANSPORT_ANY, AJ_BUS_START_ADVERTISING, 0);
            }
            return TRUE;
        case AJ_REPLY_ID(AJ_METHOD_ADVERTISE_NAME):
            if (ajMsg->hdr->msgType == AJ_MSG_ERROR) {
                AJ_ErrPrintf(("AJ_METHOD_ADVERTISE_NAME: AJ_ERR_FAILURE\n"));
            } else {
                //Now set the password callback since we are using a secure interface
                AJ_BusSetPasswordCallback(bus, PasswordCallback);
            }
            return TRUE;
        case AJ_METHOD_ACCEPT_SESSION:
        {
            uint16_t port;
            char* joiner;
            AJ_UnmarshalArgs(ajMsg, "qus", &port, &sessionId, &joiner);
            if (port == SERVICE_PORT) {
                status = AJ_BusReplyAcceptSession(ajMsg, TRUE);
                //Authenticate with the other side so they can receive signals right away
                status = AJ_BusAuthenticatePeer(bus, joiner, AuthCallback, NULL);
            } else {
                status = AJ_BusReplyAcceptSession(ajMsg, FALSE);
            }
            return TRUE;
        }
#ifdef HAS_LEDS_RGB_REMOTE_CTRL
        case SET_LED_COLOR:
        {
            uint32_t rValue;
            uint32_t gValue;
            uint32_t bValue;
            {
                AJ_Message reply;
                AJ_UnmarshalArgs(ajMsg, "iii", &rValue, &gValue, &bValue);
                AJ_Printf("Received someMethod call from a remote device with arg: %d, %d, %d\n", rValue, gValue, bValue);

                {
                    /* publish the event for system mode change */
                    AllPlayLedIndEvt* p = Q_NEW(AllPlayLedIndEvt, ALLPLAY_LED_SIG);
                    assert(p);
                    p->rValue = rValue;
                    p->gValue = gValue;
                    p->bValue = bValue;
                    QF_PUBLISH(&p->super, 0);
                }

                //now send the reply back
                AJ_MarshalReplyMsg(ajMsg, &reply);
                AJ_DeliverMsg(&reply);
            }
            {
                /* send out AJ signal to inform color change */
                uint32_t color = rValue<<16 | gValue<<8 | bValue<<0;
                sendLedSignal(color);
            }
            return TRUE;
        }
        case GET_LED_COLOR:
        {
            Color color = *(Color*)Setting_Get(SETID_RGB_LED_COLOR);
            int rtnval =    GET_RED(color) << 16 |
                            GET_GREEN(color) << 8 |
                            GET_BLUE(color) << 0;
            //now send the reply back
            {
                AJ_Status status;
                AJ_Message reply;
                AJ_Arg arg;

                AJ_InitArg(&arg, AJ_ARG_INT32, 0, &rtnval, 0);

                status = AJ_MarshalReplyMsg(ajMsg, &reply);

                if (AJ_OK == status) {
                    /*
                     * Just return the arg we received
                     */
                    status = AJ_MarshalArg(&reply, &arg);

                    if (AJ_OK == status) {
                        status = AJ_DeliverMsg(&reply);
                    }
                }
            }
            return TRUE;
        }
#endif // #ifdef HAS_LEDS_RGB_REMOTE_CTRL
#ifdef HAS_GRAPHICAL_EQ_REMOTE_CTRL
        case SET_GRAPHICAL_EQ:
        {
            uint32_t gains[5] = {0};
            {
                AJ_Message reply;
                AJ_UnmarshalArgs(ajMsg, "iiiii", &gains[0], &gains[1], &gains[2], &gains[3], &gains[4]);
                AJ_Printf("Received setGraphicalEq call from a remote device with arg: %d, %d, %d %d, %d\n", gains[0], gains[1], gains[2], gains[3], gains[4]);
                {
                    /* publish the event for system mode change */
                    AllPlayEqIndEvt* p = Q_NEW(AllPlayEqIndEvt, ALLPLAY_EQ_SIG);
                    assert(p);
                    memcpy(p->gains, gains, sizeof(gains));   //update the stored state in me instance
                    QF_PUBLISH(&p->super, 0);
                }

                //now send the reply back
                AJ_MarshalReplyMsg(ajMsg, &reply);
                AJ_DeliverMsg(&reply);
            }
            {
                /* send out AJ signal to inform eq change */
                sendEqSignal((const int *)gains);
            }
            return TRUE;
        }
        case GET_GRAPHICAL_EQ:
        {
            uint8* gains = (uint8*)Setting_Get(SETID_DSP_EQ_GAINS);

            //now send the reply back
            {
                AJ_Status status;
                AJ_Message reply;
                AJ_Arg arg;

                AJ_InitArg(&arg, AJ_ARG_INT32, AJ_ARRAY_FLAG, gains, GRAPHICAL_EQ_BANDS_NUM * sizeof(uint8));

                status = AJ_MarshalReplyMsg(ajMsg, &reply);

                if (AJ_OK == status) {
                    /*
                     * Just return the arg we received
                     */
                    status = AJ_MarshalArg(&reply, &arg);

                    if (AJ_OK == status) {
                        status = AJ_DeliverMsg(&reply);
                    }
                }
            }
            return TRUE;
        }
#endif // #ifdef HAS_GRAPHICAL_EQ
    }
    return FALSE;
}


void mySetupService(AJ_BusAttachment* theBus, const char *deviceId)
{
    AJ_SessionOpts opts;
    uint32_t deviceIdLen = 0;
    //Store off and save the BusAttachment so that we can use it in our service code
    bus = theBus;

    deviceIdLen = strlen(deviceId);
    AJ_Printf("deviceId: %s, deviceIdLen: %d\n", deviceId, deviceIdLen);
    //Setup our advertisement name
    serviceName = AJ_Malloc(strlen(MCU_SERVICE_NAME_PREFIX) + deviceIdLen + 1);

    strcpy(serviceName, MCU_SERVICE_NAME_PREFIX);
    strcpy(serviceName+strlen(MCU_SERVICE_NAME_PREFIX), deviceId);
    AJ_Printf("prefix: %s, device: %s, serviceName: %s\n", MCU_SERVICE_NAME_PREFIX, deviceId, serviceName);

    //Setup the sessoin options
    opts.isMultipoint = 1;
    opts.traffic = 0x1;
    opts.transports = 0xFFFF;
    opts.proximity = 0xFF;

    //Start the process of setting up the service (Bind -> RequestName -> AdvertiseName)
    AJ_BusBindSessionPort(bus, SERVICE_PORT, &opts, 0);
}




/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AllPlayDrv_Ctor(cAllPlayDrv *me, bool bAssertSamResetLine)
{
    me->initPhase       = 0;
    me->bAllplayConnected = FALSE;
    me->bAllplayBtConnected = FALSE;
    me->contentSource   = ALLPLAY_AP;
    me->eSystemMode     = ALLPLAY_SYSTEM_MODE_CONFIGURED;
    me->ePlayerState    = ALLPLAY_PLAYER_STATE_UNKNOWN;

    SAM_RESET_PIN_ANSEL = 0;    // set RESET pin as a non-analog pin
    SAM_RESET_PIN_IO    = 0;    // Set RESET pin as output
    AllPlayDrv_assertReset(bAssertSamResetLine);
    allplayDrv_delimiterCnt = 0;
}

void AllPlayDrv_Xtor(cAllPlayDrv *me)
{
    me->initPhase       = 0;
    me->bAllplayConnected = FALSE;
    me->bAllplayBtConnected = FALSE;
    me->contentSource   = ALLPLAY_AP;
    me->eSystemMode     = ALLPLAY_SYSTEM_MODE_CONFIGURED;
    me->ePlayerState    = ALLPLAY_PLAYER_STATE_UNKNOWN;
    AllPlayDrv_assertReset(1);
}

void AllPlayDrv_assertReset(bool bAssert)
{
    if(bAssert)
    {
        SAM_RESET_PIN_LAT = 0;      // output low to have SAM in reset state
    }
    else
    {
        SAM_RESET_PIN_LAT = 1;      // output high to activate SAM
    }
}

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
eTpRet AllPlayDrv_newCtx(cAllPlayDrv* me)
{
    /* SAM will check PRODUCT_VERSION_MCU, and determine to upgrade or not
     * When set reboot methods to ALLPLAY_REBOOT_MCU, SAM's behavior is:
     * - Upgrade MCU+SAN firmware  ==> Wait MCU to reboot system
     * - Upgrade MCU firmware only ==> Wait MCU to reboot system
     * - Upgrade SAM firmware only ==> Sent ALLPLAY_EVENT_FIRMWARE_UPDATE_STATUS to MCU, then reboot itself
     */
    //apctx = allplay_new(PRODUCT_VERSION_MCU, ALLPLAY_REBOOT_SAM);
    apctx = allplay_new_with_mcu_service(PRODUCT_VERSION_MCU, ALLPLAY_REBOOT_SAM, MyObjects, myProcessMessage, mySetupService);

    if (!apctx)
        return TP_FAIL;

    me->apctx = apctx;
    return TP_SUCCESS;
}

void AllPlayDrv_freeCtx(cAllPlayDrv* me)
{
    me->apctx = NULL;
    allplay_free(&apctx);
}

enum allplay_message_type AllPlayDrv_cmd(cAllPlayDrv* me, const AllPlayCmdEvt* e)
{
    switch(e->allPlayCmd)
    {
        case ALLPLAY_CMD_VOL_INC:
            allplay_volume_adjust(me->apctx, (void*)0, e->payload.volStep);
            break;
        case ALLPLAY_CMD_VOL_DEC:
            allplay_volume_adjust(me->apctx, (void*)0, e->payload.volStep);
            break;
        case ALLPLAY_CMD_SET_VOL:
            allplay_set_volume(me->apctx, (void*)0, e->payload.setVol);
            if(e->sender)
            {
                CommonEvtResp((QActive*)me, e->sender ,RET_SUCCESS, ALLPLAY_RESP_SIG);
            }
            break;
        case ALLPLAY_CMD_PLAY:
            allplay_play(me->apctx, (void*)0);
            break;
        case ALLPLAY_CMD_NET_RESET:
            allplay_start_setup(me->apctx, (void*)0);
            break;
        case ALLPLAY_CMD_DIRECT_MODE_ENABLE:
        {
            allplay_directmode_enable(me->apctx, (void*)0, e->payload.bEnableDirect);
            break;
        }
        case ALLPLAY_CMD_RESET_TO_FACTORY:
        {
            allplay_status status;
            status = allplay_reset_to_factory(me->apctx, (void*)0, ALLPLAY_RESET_ACTION_REBOOT);
            TRACE(status);
        }
            break;
        case ALLPLAY_CMD_PLAY_PAUSE:
        {
            switch (me->ePlayerState)
            {
                case ALLPLAY_PLAYER_STATE_PLAYING:
                case ALLPLAY_PLAYER_STATE_TRANSITIONING:
                case ALLPLAY_PLAYER_STATE_BUFFERING:
                    allplay_pause(me->apctx, (void*)0);
                    me->ePlayerState = ALLPLAY_PLAYER_STATE_PAUSED;
                    break;
                case ALLPLAY_PLAYER_STATE_PAUSED:
                case ALLPLAY_PLAYER_STATE_STOPPED:
                    allplay_play(me->apctx, (void*)0);
                    me->ePlayerState = ALLPLAY_PLAYER_STATE_PLAYING;
                    break;
                default:
                    break;
            }
            return ALLPLAY_EVENT_PLAYER_STATE_CHANGED;
        }
        break;
        case ALLPLAY_CMD_PREV:
            allplay_previous(me->apctx, (void*)0);
            break;
        case ALLPLAY_CMD_NEXT:
            allplay_next(me->apctx, (void*)0);
            break;
        case ALLPLAY_CMD_SET_MCU_IDLE:
        {
            allplay_set_mcu_idle(me->apctx, (void*)0, e->payload.bIsIdle);
            break;
        }
        case ALLPLAY_CMD_SET_BATTERY_STATE:
        {
            tBatteryState batteryState = e->payload.batteryState;
            allplay_set_battery_state(me->apctx, (void*)0, batteryState.onBattery,
                    batteryState.chargeLevel, batteryState.batteryAutonomy, batteryState.timeToFullCharge);
            break;
        }
        case ALLPLAY_CMD_SET_EXTERNAL_SOURCE:
        {
            tExternalSourceInfo externalSourceInfo = e->payload.externalSourceInfo;
            allplay_set_external_source(me->apctx, (void*)0, externalSourceInfo.name,
                    externalSourceInfo.interruptible, externalSourceInfo.volumeCtrlEnabled);
            break;
        }
#ifdef HAS_ALLPLAY_BT
        case ALLPLAY_CMD_BT_ENABLE:
        {
            allplay_bluetooth_enable(me->apctx, (void*)0, e->payload.bBtEnable);
            break;
        }
        case ALLPLAY_CMD_BT_PAIRABLE:
        {
            allplay_bluetooth_enable_pairing(me->apctx, (void*)0, e->payload.bBtPairable);
            break;
        }
#endif /* HAS_ALLPLAY_BT */
        default:
            break;
    }
    return ALLPLAY_ERROR;
}

// Alljoyn library interface
void AllPlayDrv_SetRx(uint8_t* buf, uint32_t len)
{
    allPlayDrv_CurBuf       = buf;
    allPlayDrv_CurBufSize   = len;
}

void AllPlayDrv_SetRxCB(AJ_SerIORxCompleteFunc rx_cb)
{
    allPlayDrv_RxCb         = rx_cb;
}

// ISR call-back
extern cUartDrv aj_uart;


#define CONT_MEM_SIZE 1000
uint8_t contMem[CONT_MEM_SIZE] = {0};

void AllPlayDrv_RxIntCb(void* p)
{
    (void) p;
    static uint32_t allPlayDrv_delimiterCnt = 0;
    data d = RingBuf_TopData(aj_uart.pRx);

    /* do as little as possible in this function as 
     * this func. would be invoked in every
     * Uart Rx byte received
     */
    if (d == FRAME_DELIMITER)
    {
        ++allPlayDrv_delimiterCnt;
        //post a signal to the server if the the delimiter encountered
        if ( allPlayDrv_delimiterCnt == 2 )
        {
            uint32_t bytesRead;
            bytesRead = RingBuf_GetUsedSize(aj_uart.pRx);
            uint32_t s = MIN(bytesRead, allPlayDrv_CurBufSize);
            if(s > 2)
            {
                RingBuf_Pop(aj_uart.pRx, allPlayDrv_CurBuf, s);

                assert(s <= CONT_MEM_SIZE);
                memcpy(contMem, allPlayDrv_CurBuf, s);

                if (allPlayDrv_RxCb)
                {
                    allPlayDrv_RxCb(contMem, s);
                }
                //free(rxBuf);
                allPlayDrv_delimiterCnt = 0;
            }
            else /* s <= 2 */
            {
                /* in this case, our code sees 2 consecutive 0xC0 delimiter
                 * we should now pop one byte out so only one 0xC0 delimiter
                 * is left in the ring buf, then set our
                 * 'allPlayDrv_delimiterCnt' to 1
                 */

                /*
                 * This could be tested and verified on SAM using the following commands
                 *  #stop the AJ daemon such that we are the only one that uses the SAM serial interface
                 *  $ killall -9 alljoyn-daemon     
                 *  #send out a sample AJ message, notice for the 2 0xC0 in the beginning
                 *  $ echo -n -e "\xC0\xC0\x00\x0e\x00\x04\x43\x4f\x4e\x4e\x5e\xfb\xc0" > /dev/ttyATH0
                 */
                data tmp;
                RingBuf_Pop(aj_uart.pRx, &tmp, 1);
                allPlayDrv_delimiterCnt = 1;
            }
        }
    }
}

const char* AllPlayDrvHelper_convertSysmodeToString(enum allplay_system_mode_value systemMode)
{
    const char* rtn;
    switch(systemMode)
    {
        case ALLPLAY_SYSTEM_MODE_CONFIGURED: //!<Device is in configured/normal mode
            rtn = "ALLPLAY_SYSTEM_MODE_CONFIGURED";
            break;
        case ALLPLAY_SYSTEM_MODE_CONFIGURING: //!<Device is being configured
            rtn = "ALLPLAY_SYSTEM_MODE_CONFIGURING";
            break;
        case ALLPLAY_SYSTEM_MODE_UNCONFIGURED: //!<Device is unconfigured
            rtn = "ALLPLAY_SYSTEM_MODE_UNCONFIGURED";
            break;
        case ALLPLAY_SYSTEM_MODE_DIRECT: //!<Device is in direct mode
            rtn = "ALLPLAY_SYSTEM_MODE_DIRECT";
            break;
        case ALLPLAY_SYSTEM_MODE_UPDATING: //!<Device is being updated
            rtn = "ALLPLAY_SYSTEM_MODE_UPDATING";
            break;
        default:
            rtn= "";
            assert(0);
            break;
    }
    return rtn;
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/

/*
-------------------------------------------------------------------------------
TYMPHANY LTD
                  Bluetooth Driver
                  -------------------------
                  SW Module Document

@file        BluetoothDrv.c
@brief       It's the bluetooth driver to control the ROM base CSR module by toggling GPIO
@author      Johnny Fan
@date        2014-05-13
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-05-13     Johnny Fan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "stm32f0xx.h"
#include "trace.h"
#include "attacheddevices.h"
#include "./BluetoothDrv_priv.h"
#include "BluetoothDrv.config"
#include "BluetoothSrv.config"
#include "BluetoothSrv.h"
#include "bsp.h"
#ifdef HAS_SYSTEM_CONTROL
#include "SystemDrv.h"
#endif
#ifdef HAS_BT_AUDIO_CUE
#include "AudioDrv.h"
#endif

#ifdef HAS_FIX_VOL_AUDIO_CUE
const static uint16 bt_audio_cue_time[BT_COMMON_MAX_CMD] =
{
    BT_AUDIO_CUE_PAIRING_TIME,                  //BT_ENTER_PAIRING_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_ENTER_CONNECTABLE_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_RESET_PAIR_LIST_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_ANSWER_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_REJECT_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_CANCEL_END_CMD,
    BT_AUDIO_CUE_BAT_LOW_TIME,              //BT_BAT_LOW_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_AVRCP_PAUSE_CMD,
    BT_AUDIO_CUE_NULL,                              //BT_AVRCP_PLAY_CMD,
    BT_AUDIO_CUE_BAT_CRITICAL_TIME,     //BT_BAT_CRITICAL_CMD,
    BT_AUDIO_CUE_CONNECTED_TIME,        //BT_CONNECTED_CMD,
};
#endif

#ifdef HAS_SYSTEM_CONTROL
const static SystemUpSeq_t bt_startup_seq[] =
{
#ifdef FENDER_ORANGE
    { &BtDrv_Stage1,      100},   // power on BT module
    { &BtDrv_Stage2,         100 },   // wait for a while to wait the other module(e.g DSP...) ready.
    { &BtDrv_Stage3,    100 },       // turn on amp for audio cue play
    { &BtDrv_Stage4,    500 },       // turn on amp for audio cue play
#ifdef HAS_BT_AUDIO_CUE
    { &BtDrv_Stage5,         (2800+500) },   // do something else you wanted, e.g : audio cue etc...
#endif
#else
    // watermelon board
    { &BtDrv_Stage1,    100 },
    { &BtDrv_Stage2,    100 },
    { &BtDrv_Stage3,    100 },
    { &BtDrv_Stage4,    900 },
#ifdef HAS_BT_AUDIO_CUE
    { &BtDrv_Stage5,    2800 },   // do something else you wanted, e.g : audio cue etc...
#endif
#endif
};

const static tSeqSection bt_power_off_seq[] =
{
    { &BtDrv_DeStage1,    100 },
    { &BtDrv_DeStage2,    100 },   // power off process
    { &BtDrv_DeStage3,    100 },
};

#endif

#define BT_DEBUG_ENABLE
#ifndef BT_DEBUG_ENABLE
#undef  TP_PRINTF
#define TP_PRINTF(...)
#endif

static cBluetoothDrv* pBluetoothDrv;
static cGpioDrv btGpioDrv;
static bool isBtInterruptEnable = FALSE;

static tGPIODevice *p_GPIOForBT=NULL;

#ifdef HAS_FIX_VOL_AUDIO_CUE
static uint16 bluetooth_audio_cue_playing_time = 0;
static uint16 bluetooth_delay_start_audio_cue = 0;
static bool bluetooth_audio_cue_is_pairing = FALSE;
#endif

#ifdef BT_FASTER_CMD_STATE
#define BT_STATUS_GAP_MS    30
const static uint16_t BT_status_timing[]=
{
    (BT_STATUS_GAP_MS + 50),
    (BT_STATUS_GAP_MS + 100),
    (BT_STATUS_GAP_MS + 150),
    (BT_STATUS_GAP_MS + 200),
    (BT_STATUS_GAP_MS + 250),
    (BT_STATUS_GAP_MS + 300),
    (BT_STATUS_GAP_MS + 350),
    (BT_STATUS_GAP_MS + 400),
    (BT_STATUS_GAP_MS + 450),
    (BT_STATUS_GAP_MS + 500),
    (BT_STATUS_GAP_MS + 550),
    (BT_STATUS_GAP_MS + 600),
    (BT_STATUS_GAP_MS + 650),
    (BT_STATUS_GAP_MS + 700),
    (BT_STATUS_GAP_MS + 750),
    (BT_STATUS_GAP_MS + 800),
};

const static uint16_t BT_status_timing_size = (sizeof(BT_status_timing)/sizeof(BT_status_timing[0]));
#endif

/* Private functions / variables. Declare and drivers here */
/* internal use for excuting the BT comand*/
const tBtGpioPressConfig GPIO_PRESS_CONFIG[BT_MAX_PRESS] =
{
    {1,  SHORT_PRESS_TIME_MS,          0                           },  //BT_SINGLE_PRESS
    {1,  LONG_PRESS_TIME_MS,           0                           },  //BT_LONG_PRESS
    {1,  VERY_LONG_PRESS_TIME_MS,      0                           },  //BT_VLONG_PRESS
    {1,  VERYVERY_LONG_PRESS_TIME_MS,  0                           },  //BT_VVLONG_PRESS
    {3,  DOUBLE_PRESS_TIME_MS,         DOUBLE_PRESS_INTERAL_TIME_MS},  //BT_DOUBLE_PRESS
};

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void BluetoothDrv_Ctor(cBluetoothDrv *me)
{
    p_GPIOForBT = (tGPIODevice *) getDevicebyIdAndType(BT_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(p_GPIOForBT);

    /* Fill me in! */
    GpioDrv_Ctor(&btGpioDrv, p_GPIOForBT);

    BluetoothDrv_TurnOffBT(me);

    me->pTimeReq = NULL;
    pBluetoothDrv = me;
}

void BluetoothDrv_Xtor(cBluetoothDrv *me)
{
    // never mind the XTor, it is useless on tymphany platform
    (void)me;
}

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
#ifdef HAS_FIX_VOL_AUDIO_CUE
void BluetoothDrv_AudioCueHold(uint16 delay_time)
{
    bluetooth_audio_cue_playing_time = delay_time;
}

void BluetoothDrv_SetDelayStartAudioCue(uint16 delay_time)
{
    if (bluetooth_audio_cue_is_pairing == TRUE)
    {
        bluetooth_delay_start_audio_cue = AUDIO_CUE_START_DELAY_TIME_FOR_PAIRING;
    }
    else
    {
        bluetooth_delay_start_audio_cue = delay_time;
    }
}

bool BluetoothDrv_CheckAudioCuePlaying(uint16 interval)
{
    bool ret = FALSE;

    if (bluetooth_audio_cue_playing_time == 0)
    {
        // ignore
    }
    else if (bluetooth_audio_cue_playing_time <= interval)
    {
        bluetooth_audio_cue_playing_time = 0;
        ret = TRUE;
    }
    else
    {
        bluetooth_audio_cue_playing_time -= interval;
    }

    return (ret);
}


bool BluetoothDrv_DelayStartAudioCue(uint16 interval)
{
    bool ret = FALSE;

    if (bluetooth_delay_start_audio_cue == 0)
    {
        // ignore
    }
    else if (bluetooth_delay_start_audio_cue <= interval)
    {
        bluetooth_delay_start_audio_cue = 0;
        ret = TRUE;
    }
    else
    {
        bluetooth_delay_start_audio_cue -= interval;
    }

    return (ret);
}
#endif

void BluetoothDrv_PowerEnable(bool enable)
{
    if (enable)
    {
        BT_PWR_ENABLE(btGpioDrv);
    }
    else
    {
        BT_PWR_DISABLE(btGpioDrv);
    }
}

#ifdef HAS_BT_RESET_PIN
static void BluetoothDrv_ResetEnable(bool enable)
{
    if (enable)
    {
        BT_RESET_ENABLE(btGpioDrv);
    }
    else
    {
        BT_RESET_DISABLE(btGpioDrv);
    }
}
#endif

/* same as "enter pairing" command but used as disconnect BT before power off if BT already connected */
void BluetoothDrv_DisconnectBT(void)
{
    tBtGpioPressConfig* pPressConfig = (tBtGpioPressConfig*)&GPIO_PRESS_CONFIG[BT_CMD_CONFIG[BT_ENTER_PAIRING_CMD].pressType];
    SET_GPIO(&btGpioDrv, BT_CMD_CONFIG[BT_ENTER_PAIRING_CMD].gpio);
    BSP_BlockingDelayMs(pPressConfig->onTime);
    CLEAR_GPIO(&btGpioDrv, BT_CMD_CONFIG[BT_ENTER_PAIRING_CMD].gpio);
}

void BluetoothDrv_TurnOnBT(cBluetoothDrv *me)
{
    /*initial and turn on the LED interrupt*/
    EXTI_Config(TRUE);
    /*enable BT power*/
    BT_PWR_ENABLE(btGpioDrv);
}

void BluetoothDrv_TurnOffBT(cBluetoothDrv *me)
{
    uint8_t i=0;

    me->step = 0;
#ifdef HAS_SYSTEM_CONTROL
    me->startup_step = 0;
#endif
    for(; i<p_GPIOForBT->usedGPIOPinNum; i++)
    {
        /* clear the output GPIO status */
        if(p_GPIOForBT->pGPIOPinSet[i].gpioDirection == GPIO_DIGITAL_OUTPUT)
        {
            CLEAR_GPIO(&btGpioDrv, p_GPIOForBT->pGPIOPinSet[i].gpioId);
        }
    }

    /*enable BT power*/
    BT_PWR_DISABLE(btGpioDrv);
    /*turn off the LED interrupt*/
    EXTI_Config(FALSE);
}

void BluetoothDrv_ExecuteCmd(cBluetoothDrv *me, eBtCmd cmd)
{
    tBtGpioPressConfig* pPressConfig = (tBtGpioPressConfig*)
                                       &GPIO_PRESS_CONFIG[BT_CMD_CONFIG[cmd].pressType];
    me->cmd = cmd;
    if(me->step!=INITIAL_STEP)
    {
        TP_PRINTF("start exe command but step is not initial\r\n");
        ASSERT(0);
    }
    me->step = INITIAL_STEP;
    SET_GPIO(&btGpioDrv, BT_CMD_CONFIG[cmd].gpio);
//    TP_PRINTF("start exe cmd %d, the step is %d\r\n", cmd, me->step);
    me->pTimeReq(BT_SET_TIME, pPressConfig->onTime);
}

void BluetoothDrv_TimeIsUp(cBluetoothDrv *me)
{
    tBtGpioPressConfig* pPressConfig = (tBtGpioPressConfig*)
                                       &GPIO_PRESS_CONFIG[BT_CMD_CONFIG[me->cmd].pressType];
    me->step++;
//    TP_PRINTF("time is up for cmd %d, the step is %d\r\n", me->cmd, me->step);
    if(me->step == pPressConfig->maxStep)
    {
        /* if reaching max step, clear GPIO and set delayTime to 0*/
        me->step = INITIAL_STEP;
        CLEAR_GPIO(&btGpioDrv, BT_CMD_CONFIG[me->cmd].gpio);
        BluetoothDrv_SendCmdDoneToServer(pBluetoothDrv,me->cmd);
    }
    else if ((me->step%2) == 0)
    {
        /* if even number step, then set GPIO on*/
        SET_GPIO(&btGpioDrv, BT_CMD_CONFIG[me->cmd].gpio);
        me->pTimeReq(BT_SET_TIME, pPressConfig->onTime);
    }
    else
    {
        /* if odd number step, then clear GPIO, for double press type*/
        CLEAR_GPIO(&btGpioDrv, BT_CMD_CONFIG[me->cmd].gpio);
        me->pTimeReq(BT_SET_TIME, pPressConfig->internalTime);
    }
}

void BluetoothDrv_RegisterTimeReqCb(cBluetoothDrv* me, timeReqCb fCb)
{
    ASSERT(me);
    ASSERT(fCb);
    /* clent can reset the callback if it needs */
    me->pTimeReq = fCb;
}

void BluetoothDrv_RegisterDriverSig(cBluetoothDrv* me, QActive* req)
{
    ASSERT(me);
    ASSERT(req);
    /* clent can reset the receiver if it needs */
    me->pRequester = req;
}

void BluetoothDrv_UnRegisterDriverSig(cBluetoothDrv* me)
{
    ASSERT(me);
    me->pRequester = NULL;
}

void BluetoothDrv_Led0_IRQ_Handler(void)
{
    if( isBtInterruptEnable )
        BluetoothDrv_ReadBtLedStatus(BT_INPUT0);
}

void BluetoothDrv_Led1_IRQ_Handler(void)
{
    if( isBtInterruptEnable )
        BluetoothDrv_ReadBtLedStatus(BT_INPUT1);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/* initial the pin interrupt for PA0*/
static void EXTI_Config(bool isTurnOnInterrupt)
{
    EXTI_InitTypeDef   EXTI_InitStructure;
    NVIC_InitTypeDef   NVIC_InitStructure;

    /* Enable SYSCFG clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

    /* Connect EXTI14 Line to PB14 pin */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource14);
    /* Connect EXTI15 Line to PB15 pin */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource15);
    EXTI_InitStructure.EXTI_Line = EXTI_Line14 | EXTI_Line15;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
    if(isTurnOnInterrupt)
    {
        isBtInterruptEnable = TRUE;
        EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    }
    else
    {
        isBtInterruptEnable = FALSE;
        EXTI_InitStructure.EXTI_LineCmd = DISABLE;
    }
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

static void BluetoothDrv_ReadBtLedStatus(eGPIOId btInputId)
{
    if(GpioDrv_ReadBit(&btGpioDrv, btInputId))
    {
        /* if input 0, then it is rising edge */
        if(pBluetoothDrv)
        {
            uint32 pulseTime, bt_status;
            pulseTime = pBluetoothDrv->pTimeReq(BT_END_TIME, 0);
#ifdef BT_FASTER_CMD_STATE
            bt_status = BluetoothDrv_GetBTModuleStatus(pulseTime, btInputId);
            if( bt_status != BT_MAX_STA )
                BluetoothDrv_SendStatusToSever(pBluetoothDrv, bt_status);
#else
            if(pulseTime>=BT_STATE_START_TIME_MS)
            {
                /* only send status when the pusle time is valid*/
                BluetoothDrv_SendStatusToSever(pBluetoothDrv,
                                               BluetoothDrv_GetBTModuleStatus(pulseTime, btInputId));
            }
#endif
        }
    }
    else
    {
        /* if falling edge */
        if(pBluetoothDrv)
        {
            pBluetoothDrv->pTimeReq(BT_START_TIME, 0);
        }
    }
}

static uint8 BluetoothDrv_GetBTModuleStatus(uint32 pulseTime, eGPIOId ledId)
{
#ifdef BT_FASTER_CMD_STATE
    uint8_t bt_status=BT_MAX_STA;
    uint16_t i;

    if( pulseTime < BT_STATUS_GAP_MS )  // rubbish, ignore it
        return bt_status;

    for(i=0; i<BT_status_timing_size; i++)
    {
        if( pulseTime < BT_status_timing[i] )
            break;
    }

    if( i >= BT_MAX_STA )
        return bt_status;

    bt_status = i;
    if( BT_INPUT1 == ledId )    // event LED(LED1) from BT module
    {
        bt_status += (BT_MAX_STA + 1);
    }

    TP_PRINTF("\n\r LED[%d] = %dms, bt status = %d\n\r", (ledId-BT_INPUT0), pulseTime, bt_status);

    return bt_status;
#else
    uint8 status = BT_MAX_EVT;
    uint8 i = pulseTime / BT_STATE_STEP_TIME_MS;
    if(ledId == BT_INPUT0)
    {
        if(i>= BT_MAX_LED0_STA)
        {
            status = BT_MAX_LED0_STA;
        }
        else
        {
            TP_PRINTF("BT_INPUT0: get the status, and pulseTime is %d\r\n", pulseTime);
            status = i;
        }
    }
    else
    {
        i= i+ BT_MAX_LED0_STA +1;
        if(i >= BT_MAX_EVT)
        {
            /* not valid*/
            status = BT_MAX_EVT;
        }
        else
        {
            status = i;
            TP_PRINTF("BT_INPUT1: get the status, and pulseTime is %d\r\n", pulseTime);
        }
    }
    return status;
#endif
}

static void BluetoothDrv_SendStatusToSever(cBluetoothDrv *me, uint8 btStatus)
{
    if(me->pRequester)
    {
        BtDrvStatusEvt* pEvt = Q_NEW(BtDrvStatusEvt, BT_STATUS_SIG);
        pEvt->btStatus = btStatus;
        QACTIVE_POST(me->pRequester,(QEvt*)pEvt,0);
    }
}

static void BluetoothDrv_SendCmdDoneToServer(cBluetoothDrv *me, eBtCmd cmd)
{
    if(me->pRequester)
    {
        BtDrvCmdEvt* pEvt = Q_NEW(BtDrvCmdEvt, BT_CMD_DONE_SIG);
        pEvt->cmd = cmd;
        QACTIVE_POST(me->pRequester,(QEvt*)pEvt,0);
        // do something after BT command executed.
        switch( pEvt->cmd )
        {
            case BT_RESET_PAIR_LIST_CMD:
#ifdef SYSTEM_RESTART_AFTER_FACTORY_RESET
                SystemDrv_SystemRestart(1000);    // unit : MS, wait the BT module finish.
#endif
                break;

            case BT_ENTER_PAIRING_CMD:
#ifdef HAS_FIX_VOL_AUDIO_CUE
                bluetooth_audio_cue_is_pairing = TRUE;
                BluetoothDrv_AudioCueHold(bt_audio_cue_time[pEvt->cmd]);
#endif
                break;

            case BT_BAT_LOW_CMD:
            case BT_BAT_CRITICAL_CMD:
            case BT_CONNECTED_CMD:
#ifdef HAS_FIX_VOL_AUDIO_CUE
                bluetooth_audio_cue_is_pairing = FALSE;
                BluetoothDrv_AudioCueHold(bt_audio_cue_time[pEvt->cmd]);
#endif
                break;
            default:
#ifdef HAS_FIX_VOL_AUDIO_CUE
                bluetooth_audio_cue_is_pairing = TRUE;
#endif
                break;
        }
    }
}


#ifdef HAS_SYSTEM_CONTROL


static void BtDrv_Stage1(void)
{
    BluetoothDrv_TurnOnBT(pBluetoothDrv);
#ifdef HAS_BT_RESET_PIN
    BluetoothDrv_ResetEnable(FALSE);
#endif
}

static void BtDrv_Stage2(void)
{
#ifdef HAS_BT_RESET_PIN
    BluetoothDrv_ResetEnable(TRUE);
#endif
}

static void BtDrv_Stage3(void)
{
#ifdef HAS_BT_RESET_PIN
    BluetoothDrv_ResetEnable(FALSE);
#endif
}

static void BtDrv_Stage4(void)
{
#ifdef FENDER_ORANGE
    AudioDrv_SetDspVol(DEFAULT_AUDIO_CUE_VOLUME);
#endif
#ifdef FENDER_WATERMELON_DSP_FLOW
    AudioDrv_SetDspVol(AUDIO_CUE_FIX_VOLUME);
#endif
}



#ifdef HAS_BT_AUDIO_CUE
static void BtDrv_Stage5(void)
{
#ifdef QUICKLY_POWER_DOWN
    if( SystemDrv_IsPowerSwitchOn() )
    {
        AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, FALSE);
    }
    else
    {
        AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, TRUE);
    }
    SystemDrv_SetAmpMuteEnable(TRUE);
#else
    AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, FALSE);
#endif
}
#endif

static void BtDrv_DeStage1(void* me)
{

}

static void BtDrv_DeStage2(void* me)
{

}

static void BtDrv_DeStage3(void* me)
{

}

int32_t BluetoothDrv_StartupInit(cBluetoothDrv* me)
{
    int32_t delay_time, total_steps;

    if( POWER_STAGE_POWER_OFF == SystemDrv_GetPowerStage() )    // if power is not ready, waiting...
        return BT_SRV_PER_TICK_TIME_MS;

    total_steps = sizeof(bt_startup_seq) / sizeof(bt_startup_seq[0]);
    if(me->startup_step < total_steps)
    {
        /* call the power up function according to step*/
        bt_startup_seq[me->startup_step].SystemUpStepFunc();
        /* get delay time*/
        delay_time = bt_startup_seq[me->startup_step].delay_time;
        me->startup_step ++;
    }
    else
    {
        // initial done
        delay_time = 0;
    }

    if( delay_time == 0 )
        SystemDrv_NextPowerStage();

    return delay_time;
}


int32_t BluetoothDrv_PowerOffInit(cBluetoothDrv* me)
{
    int32_t delay_time, total_steps;

    total_steps = sizeof(bt_power_off_seq) / sizeof(bt_power_off_seq[0]);
    if(me->startup_step < total_steps)
    {
        /* call the power off function according to step*/
        bt_power_off_seq[me->poweroff_step].pfSect((void*)me);
        /* get delay time*/
        delay_time = bt_power_off_seq[me->poweroff_step].seqDelay;
        me->poweroff_step ++;
    }
    else
    {
        // initial done
        delay_time = 0;
    }


    return delay_time;
}
#endif


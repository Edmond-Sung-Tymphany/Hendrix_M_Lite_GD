/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Tm1629 Driver
                  -------------------------

                  SW Module Document




@file        Tm1629Drv.c
@brief       It's the driver for TM1609 7-seg LED display chip, modified from old driver
@author      Edmond Sung, Johnny Fan, Bob.Xu 
@date        2014-03-10
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-03-10     Edmond Sung
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./Tm1629Drv_priv.h"
#include "trace.h"
#include "attachedDevices.h"

/* Private functions / variables. Declare and drivers here */
static void Tm16290Drv_SetSTB(cDisplayDrv *me);
static cGpioDrv DisplayGpioDrv;
static uint8 currBrt;
/*******************************************************************************
 *
 * Start-up / shut-down functions
 *
 ******************************************************************************/
void DisplayDrv_Ctor(cDisplayDrv *me)
{
    ASSERT(me);
    me->gpioDrv = &DisplayGpioDrv;
    tGPIODevice *pDisplayConf;
    pDisplayConf = (tGPIODevice*)getDevicebyId(DISPLAY_DEV_ID,NULL);
    GpioDrv_Ctor(&DisplayGpioDrv,pDisplayConf);
    DisplayDrv_CleanScrean(me);
}

void DisplayDrv_Xtor(cDisplayDrv *me)
{
    ASSERT(me);
    GpioDrv_Xtor(me->gpioDrv);
}

/*******************************************************************************
 *
 * Public functions
 *
 ******************************************************************************/
void DisplayDrv_SendChar(cDisplayDrv *me, uint8 charPos, uint8 ch)
{
    ASSERT(me && (charPos * 2 <  MAX_DISPLAY_ADDR));
    uint8 index = Tm1629Drv_GetCharTableIndex (me, ch);
    Tm16290Drv_SendDisplayCmd(me,charPos,&(s_CharTable[index][0]));
}

void DisplayDrv_SendChar_WithDot (cDisplayDrv *me, uint8 charPos, uint8 ch)
{
    ASSERT(charPos * 2 <  MAX_DISPLAY_ADDR);
    uint8 index = Tm1629Drv_GetCharTableIndex (me, ch);

    Tm16290Drv_SetSTB(me);
    Tm1629Drv_SendData(me, W_REG_FIX_ADD_CMD);

    Tm16290Drv_SetSTB(me);
    Tm1629Drv_SendData(me, SET_DISPLAY_ADDR_CMD | (charPos * 2));
    Tm1629Drv_SendData(me, s_CharTable[index][0] | _CODE_DOT_H);
    
    Tm16290Drv_SetSTB(me);
    Tm1629Drv_SendData(me, SET_DISPLAY_ADDR_CMD | (charPos * 2 + 1));
    Tm1629Drv_SendData(me, s_CharTable[index][1] | _CODE_DOT_L);
    
    Tm16290Drv_SetSTB(me);
    Tm1629Drv_SendData(me, (SET_DISPLAY_CMD | DISPLAY_ON_CMD | currBrt));
}

void DisplayDrv_SendString(cDisplayDrv *me, const uchar* pStr)
{
    uint8 i;
    BOOL hasDot = FALSE;
    const uchar * pCur=pStr;
    for (i = 0; i * 2 < MAX_DISPLAY_ADDR; i++)
    {
        /* 
         * handler the case if the string has a '.', this case particulaly exit
         * when user want to print the data which has fraction
        */
        if('.' == *(pCur + 1))
        {
            hasDot = TRUE;
            DisplayDrv_SendChar_WithDot(me, i, *pCur);
        }
        else if('.' == *pCur)
        {
            pCur++;
            continue;
        }
        else
        {
            if(hasDot && i > 0)
            {
                DisplayDrv_SendChar(me, i-1, *pCur);
            }
            else
            {
                DisplayDrv_SendChar(me, i, *pCur);
            }
        }
        pCur++;
    }
    if(hasDot)
    {
        /* One digital has been shifted to the left, clean the last digital */
        DisplayDrv_SendChar(me, i - 1, *pCur);
    }
}

 /* brightness off when >= 8 , min..max = 0..7*/
void DisplayDrv_SetBrightness(cDisplayDrv *me, uint8 brtLevel)
{
    ASSERT(me && (brtLevel <= MAX_BRIGHTNESS_LEVEL));
    currBrt = brtLevel;
    Tm16290Drv_SetSTB(me);    
    Tm1629Drv_SendData(me, (SET_DISPLAY_CMD | DISPLAY_ON_CMD | brtLevel));
}

void DisplayDrv_SetDebugType(cDisplayDrv *me, int8 chPosition, int8 segId)
{
    ASSERT((chPosition < NUM_OF_SCREEN_DIGIT) && segId < NUM_OF_SEGMENT);
    if(segId >= 0 && segId < SEGMENT_MAX_ID && chPosition >= 0 && chPosition < NUM_OF_SCREEN_DIGIT)
    {
      Tm16290Drv_SendDisplayCmd(me,chPosition,&segmentTable[segId][0]);
    }
}

/*******************************************************************************
 *
 * private functions
 *
 ******************************************************************************/

static void Tm16290Drv_SendDisplayCmd(cDisplayDrv *me, uint8 screenPosition, const uint8 *pMapArray)
{
    /* send command to display the data */
    Tm16290Drv_SetSTB(me);
    Tm1629Drv_SendData(me, W_REG_FIX_ADD_CMD);

    /* set STB to indicate that data transferring is going to be started */
    Tm16290Drv_SetSTB(me);
    /* send the lower seg address */
    Tm1629Drv_SendData(me, SET_DISPLAY_ADDR_CMD | (screenPosition * 2));
    /* send the data */
    Tm1629Drv_SendData(me, *pMapArray);
    
    Tm16290Drv_SetSTB(me);
    /* send the higher seg address */
    Tm1629Drv_SendData(me, SET_DISPLAY_ADDR_CMD | (screenPosition * 2 + 1));
    /* send the data */
    Tm1629Drv_SendData(me, *(pMapArray+1));
    
    Tm16290Drv_SetSTB(me);
    /* send the dsipaly control CMD */
    Tm1629Drv_SendData(me, (SET_DISPLAY_CMD | DISPLAY_ON_CMD | currBrt));
}

static void Tm16290Drv_SetSTB(cDisplayDrv *me)
{
    ASSERT(me);
    GpioDrv_SetBit(me->gpioDrv, TM1629_PIN_STB);
    delay_1us();
    GpioDrv_ClearBit(me->gpioDrv, TM1629_PIN_STB);
    delay_1us();
}

void DisplayDrv_CleanScrean(cDisplayDrv *me)
{   
    ASSERT(me);
    Tm16290Drv_SetSTB(me);
    /* send command to display the data */
    Tm1629Drv_SendData(me, W_REG_FIX_ADD_CMD);
    
    uint8 addr;
    /* clear the display register */
    for (addr = 0; addr <= MAX_DISPLAY_ADDR; addr++)
    {
        Tm16290Drv_SetSTB(me);
        Tm1629Drv_SendData(me, (SET_DISPLAY_ADDR_CMD | addr));
        Tm1629Drv_SendData(me, 0x00);
    }
    
    Tm16290Drv_SetSTB(me);
    DisplayDrv_SetBrightness(me,currBrt);
}

/**
 * \brief   Send command to TM1609
 * \param   none
 * \return  none
 */
static void Tm1629Drv_SendData(cDisplayDrv *me, uint8 segdata)
{
    ASSERT(me);
    uint8 maskData=0x01; //write from low to high ( LSB-->MSB)

    while (maskData)
    {
        GpioDrv_ClearBit(me->gpioDrv, TM1629_PIN_CLK);
        delay_1us();
        if (segdata & maskData)
        {
            GpioDrv_SetBit(me->gpioDrv, TM1629_PIN_DIO);
            delay_1us();
        }
        else
        {
            GpioDrv_ClearBit(me->gpioDrv, TM1629_PIN_DIO);
            delay_1us();
        }
        delay_1us();
        GpioDrv_SetBit(me->gpioDrv, TM1629_PIN_CLK);
        delay_1us();
        delay_1us();

        maskData <<= 1; /* change mask data */
    }
}

/**
 *
 * \brief   give the position for the required ascii char to
 *          be displayed
 * \param   the required ascii char to be displayed
 * \return  a . Return the table index of space if
 *          invalid range is inputted
 *          b. small letter is auto converted to capital letter
 *
 */
static uint8 Tm1629Drv_GetCharTableIndex (cDisplayDrv *me, uchar ch)
{
    ASSERT(me);
    uint8 ret = NOT_SUPPORT_CHAR_MAP_ADDR;
    if ((ch >= CHAR_TABLE_MIN_ENTRY)
      &&(ch <= CHAR_TABLE_MAX_ENTRY))
    {
        ret = ch - CHAR_TABLE_MIN_ENTRY;
    }

    return ret;
}
/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Dma Driver
                  -------------------------

                  SW Module Document




@file        DmaDrv.c
@brief       This file declare the DMA interface and define the DMA interface implementation
 *           Six steps for DMA data transfer.
 *           Step1: DmaDrv_Ctor()
 *           Step2: DmaDrv_InitChannel()
 *           Step3: UartDrv_RegisterIntHandlerCb()
 *           Step4: DmaDrv_SetTxBuffer()
 *           Step5: DmaDrv_TriggerTransfer()
 *           Step6: DmaDrv_Xtor()
 *           note:  user decide when to distroy the dma obj(free the dma channel)
 *                  user must ensure that the dma object is destroied when DMA
 *                  is not needed anymore, otherwise this dma obj will not be available
 *                  for other users.
@author      Bob.Xu 
@date        2014-04-01
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-04-01     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#ifdef DMA_DRV_ENABLE
#include "./DmaDrv_priv.h"
#include "trace.h"
#include "attachedDevices.h"

/* Private functions / variables. Declare and drivers here */
static uint32 channelStatusPool = 0; /* bit setted means channel is occupied */
static cDmaDrv dmaObjPool[NUM_OF_AVAILABLE_DMA_CHANNEL];

static eDmaChannel DmaDrv_GetIdleChannel(void);

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
cDmaDrv *DmaDrv_Ctor()
{
    eDmaChannel dmaChannel;
    dmaChannel = DmaDrv_GetIdleChannel();
    if(MAX_DMA_CHANNEL_ID == dmaChannel)
    {
        return NULL;
    }
    else
    {
        dmaObjPool[dmaChannel].channel = dmaChannel;
        dmaObjPool[dmaChannel].channelBusy = FALSE;
    }
    return &dmaObjPool[dmaChannel];
}

void DmaDrv_Xtor(cDmaDrv* me)
{
    ASSERT(me);
    me->pIntHandlerCb = NULL;
    channelStatusPool &= ~(1 << (me->channel)); //free channel
    me->channel = MAX_DMA_CHANNEL_ID;
}

void DmaDrv_InitDmaObj(cDmaDrv *me, uint32 triggerIRQ)
{
    ASSERT(me);
    ASSERT(me->channel < MAX_DMA_CHANNEL_ID);
    DmaChnOpen(me->channel, DMA_CHN_PRI2, DMA_OPEN_DEFAULT);
    DmaChnSetEventControl(me->channel, DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|((triggerIRQ)<<_DCH0ECON_CHSIRQ_POSITION));
    //DmaChnSetEventControl(me->channel, DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_TX_IRQ));
    /* enable the transfer done interrupt, when all buffer transferred */
    DmaChnSetEvEnableFlags(me->channel, DMA_EV_BLOCK_DONE);
    /* enable system wide multi vectored interrupts */
    INTEnableSystemMultiVectoredInt();
    /* set INT controller priority */
    INTSetVectorPriority(INT_VECTOR_DMA(me->channel), INT_PRIORITY_LEVEL_5);
    /* set INT controller sub-priority */
    INTSetVectorSubPriority(INT_VECTOR_DMA(me->channel), INT_SUB_PRIORITY_LEVEL_3);
    /* enable the chn interrupt in the INT controller */
    DmaChnIntEnable(me->channel);
}

void DmaDrv_SetTxBuffer(cDmaDrv *me,const void* pSourceAdd,void* pDestinationAdd, \
                        uint16 srcSize, uint16 dstSize, uint16 cellSize)
{
    ASSERT(me);
    ASSERT(me->channel < MAX_DMA_CHANNEL_ID);
    ASSERT(pSourceAdd);
    ASSERT(pDestinationAdd);
    ASSERT(srcSize);
    ASSERT(dstSize);
    ASSERT(cellSize);
    DmaChnSetTxfer(me->channel, pSourceAdd, pDestinationAdd, srcSize, dstSize, cellSize);
}

void DmaDrv_TriggerTransfer(cDmaDrv *me)
{
    ASSERT(me);
    ASSERT(me->channel < MAX_DMA_CHANNEL_ID);
    DmaChnEnable(me->channel);
}

void DmaDrv_SetMatchPattern(cDmaDrv *me, int pattern)
{
    ASSERT(me);
    ASSERT(me->channel < MAX_DMA_CHANNEL_ID);
    DmaChnSetMatchPattern(me->channel,pattern);
}

void DmaDrv_DisableInt(cDmaDrv *me)
{
    ASSERT(me);
    DmaChnIntDisable(me->channel);
}

void DmaDrv_EnableInt(cDmaDrv *me)
{
    ASSERT(me);
    DmaChnIntEnable(me->channel);
}
void DmaDrv_RegisterIntHandlerCb(cDmaDrv* me, dmaIntHandlerCb fCb)
{
    ASSERT(me);
    ASSERT(fCb);
    me->pIntHandlerCb = fCb;
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/**
* get a available channel
* @param[in]    me               the dma Driver object
*/
static eDmaChannel DmaDrv_GetIdleChannel()
{
    int i;
    for(i = 0; i < NUM_OF_AVAILABLE_DMA_CHANNEL; i++)
    {
        if(!(channelStatusPool & (1 << i)))
        {
            /* set channel state to occupied state */
            channelStatusPool |= 1<<i;
            return (eDmaChannel)i;
        }
    }
    /* no idle channel */
    return MAX_DMA_CHANNEL_ID;
}

void __ISR(_DMA0_VECTOR, ipl5) DmaCh0_Handler(void)
{
    int evFlags;
    INTDisableInterrupts();
    INTClearFlag(INT_SOURCE_DMA(DMA_CHANNEL0));
    evFlags = DmaChnGetEvFlags(DMA_CHANNEL0);
    if(NULL != dmaObjPool[0].pIntHandlerCb)
    {
        dmaObjPool[0].pIntHandlerCb(DMA_CHANNEL0);
    }
    if (evFlags & DMA_EV_BLOCK_DONE)
    {
        DmaChnClrEvFlags(DMA_CHANNEL0, DMA_EV_BLOCK_DONE);
    }
    INTEnableInterrupts();
}

void __ISR(_DMA1_VECTOR, ipl5) DmaCh1_Handler(void)
{
    int evFlags;
    INTDisableInterrupts();
    INTClearFlag(INT_SOURCE_DMA(DMA_CHANNEL1));
    evFlags = DmaChnGetEvFlags(DMA_CHANNEL1);
    if(NULL != dmaObjPool[1].pIntHandlerCb)
    {
        dmaObjPool[1].pIntHandlerCb(DMA_CHANNEL1);
    }
    if (evFlags & DMA_EV_BLOCK_DONE)
    {
        DmaChnClrEvFlags(DMA_CHANNEL1, DMA_EV_BLOCK_DONE);
    }
    INTEnableInterrupts();
}

void __ISR(_DMA2_VECTOR, ipl5) DmaCh2_Handler(void)
{
    int evFlags;
    INTClearFlag(INT_SOURCE_DMA(DMA_CHANNEL2));
    evFlags = DmaChnGetEvFlags(DMA_CHANNEL2);
    if(NULL != dmaObjPool[2].pIntHandlerCb)
    {
        dmaObjPool[2].pIntHandlerCb(DMA_CHANNEL2);
    }
    if (evFlags & DMA_EV_BLOCK_DONE)
    {
        DmaChnClrEvFlags(DMA_CHANNEL2, DMA_EV_BLOCK_DONE);
    }
}

void __ISR(_DMA3_VECTOR, ipl5) DmaCh3_Handler(void)
{
    int evFlags;
    INTClearFlag(INT_SOURCE_DMA(DMA_CHANNEL3));
    evFlags = DmaChnGetEvFlags(DMA_CHANNEL3);
    if(NULL != dmaObjPool[3].pIntHandlerCb)
    {
        dmaObjPool[3].pIntHandlerCb(DMA_CHANNEL3);
    }
    if (evFlags & DMA_EV_BLOCK_DONE)
    {
        DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_BLOCK_DONE);
    }
}
#endif /* End of DMA_DRV_ENABLE */
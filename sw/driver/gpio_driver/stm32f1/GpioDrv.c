/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Gpio Driver
                  -------------------------

                  SW Module Document




@file        GpioDrv.c
@brief       The GPIO interfaces and implementation for stm
             Note:The GPIO_Pin parameter can be GPIO_Pin_x where x can be: (0..15) for 
             GPIOA GPIOB or GPIOC,(0..2) for GPIOD and(0..3) for GPIOF. 
@author      Bob.Xu 
@date        2014-03-10
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-03-10     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "trace.h"
#include "./GpioDrv_priv.h"

static const tStmIOInfo ioInfo[] =
{
    {GPIOA,         RCC_APB2Periph_GPIOA},
    {GPIOB,         RCC_APB2Periph_GPIOB},
    {GPIOC,         RCC_APB2Periph_GPIOC},
    {GPIOD,         RCC_APB2Periph_GPIOD},
    {GPIO_INVALIDD, GPIO_AHPPreiph_Invalid},
    {GPIOF,         RCC_APB2Periph_GPIOF},
};


/******************************************************************************
 *
 * Start-up / shut-down functions
 *
 ******************************************************************************/
void GpioDrv_Ctor(cGpioDrv *me, const tGPIODevice *pConfig )
{
    ASSERT(me && pConfig);
    GPIO_InitTypeDef GPIOInitStr;
    uint8 i = 0;
    me->gpioConfig = pConfig;
    GPIOInitStr.GPIO_Speed = GPIO_Speed_50MHz;
    /* GPIOC Periph clock enable */
    for(i = 0; i < pConfig->usedGPIOPinNum; i++)
    {
        RCC_APB2PeriphClockCmd(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].rccAhbPeriph, ENABLE);
        GPIOInitStr.GPIO_Pin = (1<<pConfig->pGPIOPinSet[i].gpioBit);       
        switch(pConfig->pGPIOPinSet[i].gpioDirection)
        {
            case GPIO_DIGITAL_INPUT:
            {                
                 if(GPIO_ACTIVE_LOW == pConfig->pGPIOPinSet[i].gpioInitAttr)
                 {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_IPU;
                 }
                 else if (GPIO_ACTIVE_HIGH == pConfig->pGPIOPinSet[i].gpioInitAttr)
                 {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_IPD;
                 }
                 else
                 {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_IN_FLOATING;
                 }
                 break;
            }
            case GPIO_DIGITAL_OUTPUT:
            {
                 if(ODC_ENABLE == pConfig->pGPIOPinSet[i].openDrainControl)
                 {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_Out_OD;
                 }
                 else
                 {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_Out_PP;
                 }
                 break;
            }
            case GPIO_ANALOG_INPUT:
            {
                GPIOInitStr.GPIO_Mode = GPIO_Mode_AIN;
                break;
            }
            case GPIO_ANALOG_OUTPUT:
            {/* what is analog output ?? */                
                GPIOInitStr.GPIO_Mode = GPIO_Mode_AIN;
                break;
            }
            case GPIO_BIDIRECTION:
            {
                /* what is BIDIRECTION ?? */   
                /**
                 * the defualt direction is the the CPU defualt direction when
                 * MCU is power on, user need to call the public functions to
                 * set the direction if it is required.
                 */
                if(GPIO_ACTIVE_LOW == pConfig->pGPIOPinSet[i].gpioInitAttr)
                {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_IPU;                    
                }
                else if (GPIO_ACTIVE_HIGH == pConfig->pGPIOPinSet[i].gpioInitAttr)
                {
                    GPIOInitStr.GPIO_Mode = GPIO_Mode_IPD;
                }
                break;
            }
            default:break;
        }
        GPIO_Init(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, &GPIOInitStr);
    }
    me->isCreated = TRUE;
}

/**
* Disable GPIO object
* project
* @param[in]    me              GPIO object
*/
void GpioDrv_Xtor(cGpioDrv *me)
{
    ASSERT(me);
    GPIO_InitTypeDef GPIOInitStr;
    uint8 i = 0;
    me->isCreated = FALSE;
    GPIOInitStr.GPIO_Speed = GPIO_Speed_50MHz;
    for(i = 0; i < me->gpioConfig->usedGPIOPinNum; i++)
    {
        GPIOInitStr.GPIO_Pin = (1 << (me->gpioConfig->pGPIOPinSet[i].gpioBit));       
        //GPIOInitStr.GPIO_PuPd = GPIO_PuPd_NOPULL;
        //GPIOInitStr.GPIO_Mode = GPIO_Mode_IN;
        GPIO_Init(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, &GPIOInitStr);
    }
}

/******************************************************************************
 *
 * Public functions
 *
 ******************************************************************************/
void GpioDrv_SetDigitalIn(cGpioDrv *me, eGPIOId gpioId)
{
    GPIO_InitTypeDef GPIOInitStr;
    uint8 i = 0;
    for(i = 0; i < me->gpioConfig->usedGPIOPinNum; i++)
    {
        /* only the gpio pin which has GPIO_BIDIRECTION feature has the access
         * to this function, otherwise, return fail. */
        if (gpioId == me->gpioConfig->pGPIOPinSet[i].gpioId && \
            GPIO_BIDIRECTION == me->gpioConfig->pGPIOPinSet[i].gpioDirection)
        {
            GPIOInitStr.GPIO_Speed = GPIO_Speed_50MHz;
            GPIOInitStr.GPIO_Pin = (1 << (me->gpioConfig->pGPIOPinSet[i].gpioBit));
            if(GPIO_ACTIVE_LOW == me->gpioConfig->pGPIOPinSet[i].gpioInitAttr)
            {
                GPIOInitStr.GPIO_Mode = GPIO_Mode_IPU;
            }
            else if(GPIO_ACTIVE_HIGH == me->gpioConfig->pGPIOPinSet[i].gpioInitAttr)
            {
                GPIOInitStr.GPIO_Mode = GPIO_Mode_IPD;
            }
            else
            {
                GPIOInitStr.GPIO_Mode = GPIO_Mode_IN_FLOATING;
            }
            GPIO_Init(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, &GPIOInitStr);
            return;
        }
    }
    ASSERT(0); /* gpioId doesn't belong to me,somewhere is seriously wrong */
}

void GpioDrv_SetDigitalOut(cGpioDrv *me, eGPIOId gpioId)
{
    GPIO_InitTypeDef GPIOInitStr;
    uint8 i = 0;
    for(i = 0; i < me->gpioConfig->usedGPIOPinNum; i++)
    {
        /* only the gpio pin which has GPIO_BIDIRECTION feature has the access
         * to this function, otherwise, return fail. */
        if (gpioId == me->gpioConfig->pGPIOPinSet[i].gpioId && \
            GPIO_BIDIRECTION == me->gpioConfig->pGPIOPinSet[i].gpioDirection)
        {
            GPIOInitStr.GPIO_Speed = GPIO_Speed_50MHz;
            GPIOInitStr.GPIO_Pin = (1 << (me->gpioConfig->pGPIOPinSet[i].gpioBit));
            GPIOInitStr.GPIO_Mode = GPIO_Mode_Out_PP;
            GPIO_Init(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, &GPIOInitStr);
            return;
        }
    }
    ASSERT(0); /* gpioId doesn't belong to me,somewhere is seriously wrong */
}

void GpioDrv_SetBit(cGpioDrv *me, eGPIOId gpioId)
{
    uint32 gpioPinBit = 0;
    uint8 i = 0;
    for(i = 0; i < me->gpioConfig->usedGPIOPinNum; i++)
    {
        gpioPinBit = (1<<(me->gpioConfig->pGPIOPinSet[i].gpioBit));
        if (gpioId == me->gpioConfig->pGPIOPinSet[i].gpioId)
        {
            GPIO_SetBits(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort,gpioPinBit);
            return;
        }
    }
    ASSERT(0); /* gpioId doesn't belong to me,somewhere is seriously wrong */
}

int8 GpioDrv_ReadBit(cGpioDrv *me, eGPIOId gpioId)
{
    int8 rtnValue = TP_ACCESS_ERROR;
    uint8 i       = 0;
    for(i = 0; i < (me->gpioConfig->usedGPIOPinNum); i++)
    {
        if (gpioId == me->gpioConfig->pGPIOPinSet[i].gpioId)
        {
            rtnValue = GPIO_ReadInputDataBit(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, \
                                  (1<<me->gpioConfig->pGPIOPinSet[i].gpioBit));
            break;
        }
    }
    /* gpioId doesn't belong to me,somewhere is seriously wrong */
    ASSERT(TP_ACCESS_ERROR != rtnValue);
    return rtnValue;
}

void GpioDrv_ClearBit(cGpioDrv *me, eGPIOId gpioId)
{
    uint16 gpioPinBit;
    uint8 i = 0;
    for(i = 0; i < me->gpioConfig->usedGPIOPinNum; i++)
    {
        if (gpioId == me->gpioConfig->pGPIOPinSet[i].gpioId)
        {
            gpioPinBit = (1 << (me->gpioConfig->pGPIOPinSet[i].gpioBit));
            GPIO_WriteBit(ioInfo[(me->gpioConfig->pGPIOPinSet[i].gpioPort)].pMCUgpioPort, gpioPinBit,Bit_RESET);
            return;
        }
    }
    ASSERT(0); /* gpioId doesn't belong to me,somewhere is seriously wrong */
}

#ifdef HW_GPIO_DEBUG
void GpioDrv_DirectPinAccessSet(eIoPort ioPort, eIoBit ioBit, eGPIOInitAttr act)
{
    if (act == GPIO_ACTIVE_HIGH)
    {
        GPIO_SetBits(ioInfo[ioPort].pMCUgpioPort,(1 << ioBit));
    }
    else
    {
        GPIO_WriteBit(ioInfo[ioPort].pMCUgpioPort, (1 << ioBit),Bit_RESET);
    }
}
uint8 GpioDrv_DirectPinAccessRead(eIoPort ioPort, eIoBit ioBit, eGPIODrection direction)
{
  uint8 value = INVALID_GPIO_READING;
    switch (direction)
    {
    case GPIO_DIGITAL_OUTPUT:
      {
         value = GPIO_ReadOutputDataBit(ioInfo[ioPort].pMCUgpioPort,(1 << ioBit));
         break;
      }
    case GPIO_DIGITAL_INPUT:
      {
         value = GPIO_ReadInputDataBit(ioInfo[ioPort].pMCUgpioPort,(1 << ioBit));
         break;
      }
        default:
      break;
    }
    return value;
}

#endif



void GpioDrv_DisableIntOfWakeUpKeyPin()
{
    /* Need to be implemented */
}

void GpioDrv_EnableIntOfWakeUpKeyPin()
{
    /* Need to be implemented */
}

/*****************************************************************************
* Model: tym_platform.qm
* File:  F:\Project_Atmos\tymphany_platform\sw/driver\hdmi_driver\HdmiDrv.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${F:\Project_Atmos~::driver\hdmi_driver\HdmiDrv.c} .......................*/
/**
 *  @file      hdmi_driver.c
 *  @brief     This file contains the EP91A6S HDMI driver implementation.
 *  @author    Albert
 *  @date      23-May-2016
 *  @copyright Tymphany Ltd.
 */
#include "HdmiDrv_priv.h"
#include "HdmiDrv.h"
#include "GPIODrv.h"
#include "deviceTypes.h"
#include "attachedDevices.h"
#include "trace.h"
#include "product.config"
#include "stdbool.h"
bool abc=false;     
/*${AOs::HdmiDrv} ..........................................................*/
/*${AOs::HdmiDrv::GPIO_initial} ............................................*/
void HdmiDrv_GPIO_initial(HdmiDrv * const me) {
    uint16_t attached_device_index = 0;
    ASSERT(me);
    tDevice *pDev = NULL;
    pDev = (tDevice*)getDevicebyId(EP_HDMI_DEV_ID,&attached_device_index);
    ASSERT(pDev!=NULL);
    GpioDrv_Ctor(&me->m_gpioDrv,(tGPIODevice*)pDev);
    //[TBD] GpioDrv_EnableExtInterrupt(&me->m_gpioDrv,GPIO_IN_HDMI_AMUTE,ExtiIntTri_Rising);
    //[TBD] GpioDrv_EnableExtInterrupt(&me->m_gpioDrv,GPIO_IN_HDMI_INTB,ExtiIntTri_Rising);
}

/*${AOs::HdmiDrv::I2C_initial} .............................................*/
void HdmiDrv_I2C_initial(HdmiDrv * const me) {
    int retry=50;
    ASSERT(me);
    me->m_i2cDrv.pConfig = (stSWi2cDevice_t *) getDevicebyIdAndType(HDMI_DEV_I2C_GPIO_ID, SWI2C_DEV_TYPE, NULL);
    ASSERT(me->m_i2cDrv.pConfig !=NULL);
    SWi2cDrv_Ctor(&me->m_i2cDrv,me->m_i2cDrv.pConfig);
    me->m_isReady = HDMI_DISABLE;
    while(retry>0)
    {
        if(SWi2cDrv_DeviceAvailable(&me->m_i2cDrv,1)) {
            me->m_isReady = HDMI_ENABLE;
            break;
        }    
        HdmiDrv_delay(me,100);
		retry--;
        TP_PRINTF("HdmiDrv_I2C_initial...\n\r");
    }
}
/*${AOs::HdmiDrv::I2C_read} ................................................*/
uint8_t HdmiDrv_I2C_read(
    HdmiDrv * const me,
    uint8_t addr,
    uint8_t *data)
{
    ASSERT(me);
    if(me->m_isReady != HDMI_ENABLE)
        return 0;
    return SWi2cDrv_ReadByte(&me->m_i2cDrv, addr, data);
}
/*${AOs::HdmiDrv::I2C_write} ...............................................*/
uint8_t HdmiDrv_I2C_write(
    HdmiDrv * const me,
    uint8_t addr,
    uint8_t data)
{
    ASSERT(me);
    if(me->m_isReady != HDMI_ENABLE)
        return 0;
    return SWi2cDrv_WriteByte(&me->m_i2cDrv, addr, data);
}

/**
 * Construct the driver instance.
 * @param me - instance of the driver
 * @param - None
 */
/*${AOs::HdmiDrv::ctor} ....................................................*/
void HdmiDrv_ctor(HdmiDrv * const me) {
    ASSERT(me);
    //HdmiDrv_reset(me);
    HdmiDrv_GPIO_initial(me);
    HdmiDrv_I2C_initial(me);
    if(me->m_isReady == HDMI_ENABLE)
    {    
        HdmiDrv_writeRegister(me,0x10,0xa0); //Default: Power=1 , Audio_Path=1             
        /* Cache register */
        HdmiDrv_I2C_read(me, HDMI_REG_X10,&me->m_register_x10);
        HdmiDrv_I2C_read(me, HDMI_REG_X10,&me->m_register_x11);
        HdmiDrv_I2C_read(me, HDMI_REG_X10,&me->m_register_x12);
        HdmiDrv_I2C_read(me, HDMI_REG_X10,&me->m_register_x13);
        HdmiDrv_I2C_read(me, HDMI_REG_X10,&me->m_register_x14);

        TP_PRINTF("HDMI Vender ID:%04x\n\r",HdmiDrv_getVenderID(me));
        TP_PRINTF("HDMI Device ID:%04x\n\r",HdmiDrv_getDeviceID(me));
        TP_PRINTF("HDMI Version:%04x\n\r",HdmiDrv_getVersion(me));
        HdmiDrv_dump(me,__FUNCTION__);
    }    
    else
    {
        TP_PRINTF("%s: HdmiDrv_I2C_initial() return fail.\n\r",__FUNCTION__);
    }    
        
}

/**
 * Deconstruct the driver instance.
 * @param me - instance of the driver
 * @param - None
 */
/*${AOs::HdmiDrv::xtor} ....................................................*/
void HdmiDrv_xtor(HdmiDrv * const me) {
    ASSERT(me);
    HdmiDrv_setPower(me,HDMI_OFF);  
    GpioDrv_Xtor(&me->m_gpioDrv);
    SWi2cDrv_Xtor(&me->m_i2cDrv);
}

/**
 * Enable/Disable system power.
 * @param me - instance of the driver
 * @param enable- enable or disable power
 */
/*${AOs::HdmiDrv::setPower} ................................................*/
void HdmiDrv_setPower(HdmiDrv * const me, uint8_t setting) {
    ASSERT(me);
    me->m_register_x10 &= ~HDMI_BITMASK_POWER;
    me->m_register_x10 |= (setting ? HDMI_BITMASK_POWER : 0);
    HdmiDrv_I2C_write(me, HDMI_REG_X10,me->m_register_x10);
    HdmiDrv_dump(me,__FUNCTION__);
}

/**
 * Return power status.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getPower} ................................................*/
uint8_t HdmiDrv_getPower(HdmiDrv * const me) {
    REG_10 *reg;
    ASSERT(me);
    HdmiDrv_I2C_read(me, HDMI_REG_X10, (uint8_t *)&me->m_register_x10);
    reg=(REG_10 *)me->m_register_x10;
    return reg->Power;
}

/**
 * Return ARC status.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getCEC} ..................................................*/
uint8_t HdmiDrv_getCEC(HdmiDrv * const me) {
    REG_10 *reg;
    ASSERT(me);
    HdmiDrv_I2C_read(me, HDMI_REG_X10, (uint8_t *)&me->m_register_x10);
    reg=(REG_10 *)me->m_register_x10;
    return reg->CEC_DIS;

}
/**
 * Set HDMI CEC.
 * @param me - instance of the driver
 * @param enable- enable or disable ARC
 */
/*${AOs::HdmiDrv::setCEC} ..................................................*/
void HdmiDrv_setCEC(HdmiDrv * const me, uint8_t setting) {
    ASSERT(me);
    me->m_register_x10 &= ~HDMI_BITMASK_CEC_DISABLE;
    me->m_register_x10 |= ((!setting) ? HDMI_BITMASK_CEC_DISABLE : 0);
    HdmiDrv_I2C_write(me, HDMI_REG_X10,me->m_register_x10);
    HdmiDrv_dump(me,__FUNCTION__);
}

/**
 * Set HDMI ARC.
 * @param me - instance of the driver
 * @param enable- enable or disable ARC
 */
/*${AOs::HdmiDrv::setARC} ..................................................*/
void HdmiDrv_setARC(HdmiDrv * const me, uint8_t setting) {    
    ASSERT(me);
    me->m_register_x10 &= ~HDMI_BITMASK_ARC_ENABLE;
    me->m_register_x10 |= (setting ? HDMI_BITMASK_ARC_ENABLE : 0);
    HdmiDrv_I2C_write(me, HDMI_REG_X10,me->m_register_x10);
    HdmiDrv_dump(me,__FUNCTION__);
}
/**
 * Return ARC status.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getARC} ..................................................*/
uint8_t HdmiDrv_getARC(HdmiDrv * const me) {
    REG_10 *reg;
    ASSERT(me);
    HdmiDrv_I2C_read(me, HDMI_REG_X10, (uint8_t *)&me->m_register_x10);
    reg=(REG_10 *)me->m_register_x10;
    return reg->ARC_EN;

}
/**
 * Set HDMI mute/unmute.
 * @param me - instance of the driver
 * @param setting- 1:enable mute or 0:disable mute
 */
/*${AOs::HdmiDrv::setMute} .................................................*/
void HdmiDrv_setMute(HdmiDrv * const me, uint8_t setting) {
    ASSERT(me);
    me->m_register_x10 &= ~HDMI_BITMASK_CEC_MUTE;
    me->m_register_x10 |= (setting ? HDMI_BITMASK_CEC_MUTE : 0);
    HdmiDrv_I2C_write(me, HDMI_REG_X10,me->m_register_x10);
    HdmiDrv_dump(me,__FUNCTION__);

}
/*${AOs::HdmiDrv::getMute} .................................................*/
uint8_t HdmiDrv_getMute(HdmiDrv * const me) {
    REG_10 *reg;
    ASSERT(me);
    HdmiDrv_I2C_read(me, HDMI_REG_X10, (uint8_t *)&me->m_register_x10);
    reg=(REG_10 *)me->m_register_x10;
    return reg->CEC_Mute;

}

/**
 * Set HDMI volume.
 * @param me - instance of the driver
 * @param level- volume level
 */
/*${AOs::HdmiDrv::setVolume} ...............................................*/
void HdmiDrv_setVolume(HdmiDrv * const me, uint8_t level) {
    ASSERT(me);    
    me->m_volume=level;
    me->m_register_x13 = me->m_volume;
    HdmiDrv_I2C_write(me, HDMI_REG_X13,me->m_register_x13);
    HdmiDrv_dump(me,__FUNCTION__);
}

/**
 * Return current HDMI volume.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getVolume} ...............................................*/
uint8_t HdmiDrv_getVolume(HdmiDrv * const me) {
    ASSERT(me);
    HdmiDrv_I2C_read(me, HDMI_REG_X13, (uint8_t *)&me->m_register_x13);
    return me->m_register_x13;
}

/**
 * Set HDMI source.
 * @param me - instance of the driver
 * @param port - 1:HDMI_Port1, 6:HDMI_ARC
 */
/*${AOs::HdmiDrv::setSource} ...............................................*/
void HdmiDrv_setSource(HdmiDrv * const me, uint8_t port) {
    ASSERT(me);
    me->m_source=port;
    switch(port)
    {
        case HDMI_PORT_1:   
            //Reg 0x10: Power=1, Audio_Path=1 , ARC_EN=0
            me->m_register_x10|=(HDMI_BITMASK_POWER | HDMI_BITMASK_AUDIO_PATH);
            me->m_register_x10&=~(HDMI_BITMASK_ARC_ENABLE);                  
            HdmiDrv_writeRegister(me,0x10,me->m_register_x10);              
            //Reg 0x11: HDMI_PORT_1=1
            HdmiDrv_setPort(me,HDMI_PORT_1);
            break;
        case HDMI_PORT_ARC:
            //Reg 0x10: Power=1, Audio_Path=1 , ARC_EN=1
            me->m_register_x10|=(HDMI_BITMASK_POWER | HDMI_BITMASK_AUDIO_PATH | HDMI_BITMASK_ARC_ENABLE);
            HdmiDrv_writeRegister(me,0x10,me->m_register_x10);                     
            //Reg 0x11: HDMI_PORT_ARC=6
            HdmiDrv_setPort(me,HDMI_PORT_ARC);
            break;
        default:
            //Reg 0x10:Audio_Path=0 , ARC_EN=0
            me->m_register_x10&=~(HDMI_BITMASK_AUDIO_PATH | HDMI_BITMASK_ARC_ENABLE);
            HdmiDrv_writeRegister(me,0x10,me->m_register_x10);     
            //Reg 0x11: HDMI_PORT_NONE=0xf [TBD]
            HdmiDrv_setPort(me,HDMI_PORT_NONE);
            break;
    }
    HdmiDrv_dump(me,__FUNCTION__);
}

/**
 * Return current HDMI source.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getSourec} ...............................................*/
uint8_t HdmiDrv_getSourec(HdmiDrv * const me) {
    ASSERT(me);
    return me->m_source;
}

/**
 * Return Video Latency.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getVideoLatency} .........................................*/
uint16_t HdmiDrv_getVideoLatency(HdmiDrv * const me) {
    ASSERT(me);
    return me->m_videoLatency;
}

/**
 * Return Interlaced Video Latency.
 * @param me - instance of the driver
 * @param - NONE
 */
/*${AOs::HdmiDrv::getInterlacedVideoLatency} ...............................*/
uint16_t HdmiDrv_getInterlacedVideoLatency(HdmiDrv * const me) {
    ASSERT(me);
    return me->m_interlacedVideoLatency;
}
/*${AOs::HdmiDrv::reset} ...................................................*/
void HdmiDrv_reset(HdmiDrv * const me) {
    ASSERT(me);
    GpioDrv_ClearBit(&me->m_gpioDrv,GPIO_OUT_HDMI_RSTB);
    HdmiDrv_delay(me,500); //TBD: spec. >=10 ms
    GpioDrv_SetBit(&me->m_gpioDrv,GPIO_OUT_HDMI_RSTB);
}
/*${AOs::HdmiDrv::power} ...................................................*/
void HdmiDrv_power(HdmiDrv * const me) {
    ASSERT(me);
    //[TO DO]
    //if(rst)
    //    HDMI_POWT_H;
    //else
    //    HDMI_POW_L;
}
/*${AOs::HdmiDrv::isI2cReady} ..............................................*/
uint8_t HdmiDrv_isI2cReady(HdmiDrv * const me) {
    REG_9 reg;
    ASSERT(me);
    HdmiDrv_I2C_read(me, 0x9, (uint8_t *)&reg);
    return reg.I2C_Ready;
}
/*${AOs::HdmiDrv::isPortAvailable} .........................................*/
uint8_t HdmiDrv_isPortAvailable(HdmiDrv * const me, uint32_t port) {
    REG_8  reg8;
    REG_14 reg14;

    ASSERT(me);

    HdmiDrv_I2C_read(me, HDMI_REG_X8, (uint8_t *)&reg8);
    HdmiDrv_I2C_read(me, HDMI_REG_X14,(uint8_t *)&reg14);
    if(port == HDMI_PORT_1 && reg8.Tx_Hot_Plug && reg14.LinkON1)
        return HDMI_ENABLE;

    if(port == HDMI_PORT_ARC && reg8.Tx_Hot_Plug && reg8.TV_ARC_ON)
        return HDMI_ENABLE;

    return HDMI_DISABLE;
}
/*${AOs::HdmiDrv::getVenderID} .............................................*/
uint16_t HdmiDrv_getVenderID(HdmiDrv * const me) {
    uint8_t value=0x00;
    uint16_t result=0x0000;

    ASSERT(me);

    HdmiDrv_I2C_read(me,0x00,&value);
    result=(value <<8);

    HdmiDrv_I2C_read(me,0x01,&value);
    result|=value;

    return result;
}
/*${AOs::HdmiDrv::getDeviceID} .............................................*/
uint16_t HdmiDrv_getDeviceID(HdmiDrv * const me) {
    uint8_t value=0x00;
    uint16_t result=0x0000;

    ASSERT(me);

    HdmiDrv_I2C_read(me,0x02,&value);
    result=(value <<8);


    HdmiDrv_I2C_read(me,0x03,&value);
    result|=value;

    return result;
}
/*${AOs::HdmiDrv::getVersion} ..............................................*/
uint32_t HdmiDrv_getVersion(HdmiDrv * const me) {
    uint8_t value=0x00;

    ASSERT(me);

    HdmiDrv_I2C_read(me,0x04,&value);
    return  value;
}
/*${AOs::HdmiDrv::setPort} .................................................*/
void HdmiDrv_setPort(HdmiDrv * const me, uint8_t port) {
    HdmiDrv_I2C_read(me, HDMI_REG_X11,&me->m_register_x11);
    me->m_register_x11 &= ~HDMI_BITMASK_PORT;
    me->m_register_x11 |= (port & HDMI_BITMASK_PORT);
    HdmiDrv_I2C_write(me, HDMI_REG_X11, me->m_register_x11);

}
/*${AOs::HdmiDrv::setMaxVolumeLimit} .......................................*/
void HdmiDrv_setMaxVolumeLimit(HdmiDrv * const me, uint16_t level) {
    ASSERT(me);
    me->m_volumeLimit=level;

}
/*${AOs::HdmiDrv::getMaxVolumeLimit} .......................................*/
uint16_t HdmiDrv_getMaxVolumeLimit(HdmiDrv * const me) {
    ASSERT(me);
    return me->m_volumeLimit;
}
/*${AOs::HdmiDrv::readRegister} ............................................*/
uint8_t HdmiDrv_readRegister(HdmiDrv * const me, uint8_t registerAddr) {
    uint8_t value=0x00;
    ASSERT(me);
    HdmiDrv_I2C_read(me, registerAddr,&value);
    return  value;
}
/*${AOs::HdmiDrv::writeRegister} ...........................................*/
uint8_t HdmiDrv_writeRegister(HdmiDrv * const me, uint8_t regAddr, uint8_t value) {
    ASSERT(me);
    return HdmiDrv_I2C_write(me, regAddr,value);
}

/*${AOs::HdmiDrv::delay} ...................................................*/
void HdmiDrv_delay(HdmiDrv * const me, uint16_t cnt) {
    while(cnt--)
    {
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
    }

}

/* Following is for debug. */
/*${AOs::HdmiDrv::ctor} ....................................................*/
void HdmiDrv_dump(HdmiDrv * const me,char const *info) 
{
    if(info)
        TP_PRINTF("%s-----------------------\n\r",info);
    else
        TP_PRINTF("-----------------------\n\r");
    TP_PRINTF("HDMI REG(0x08):%02x\n\r",HdmiDrv_readRegister(me,0x08));
    TP_PRINTF("HDMI REG(0x10):%02x\n\r",HdmiDrv_readRegister(me,0x10));
    TP_PRINTF("HDMI REG(0x11):%02x\n\r",HdmiDrv_readRegister(me,0x11));
    TP_PRINTF("HDMI REG(0x12):%02x\n\r",HdmiDrv_readRegister(me,0x12));
    TP_PRINTF("HDMI REG(0x13):%02x\n\r",HdmiDrv_readRegister(me,0x13));          
    TP_PRINTF("HDMI REG(0x14):%02x\n\r",HdmiDrv_readRegister(me,0x14));                        
}
extern HdmiDrv hdmi_Drv;
void HdmiDrv_test(void)
{
    TP_PRINTF("%s:START...\n\r",__FUNCTION__);
    HdmiDrv_ctor(&hdmi_Drv);        
    HdmiDrv_writeRegister(&hdmi_Drv,0x10,0xa0);  //{default:10100000}    
    HdmiDrv_dump(&hdmi_Drv,__FUNCTION__);
    TP_PRINTF("%s:END\n\r",__FUNCTION__);
}

/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  NBI2C Driver
                  -------------------------

                  SW Module Document




@file        NBI2CDrv.c
@brief       This file defines the implementation of non-blcoking I2C driver
@author      Bob.Xu 
@date        2014-04-25
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-04-25     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "NBI2CDrv.h"
#include "./NBI2CDrv_priv.h"
#include "trace.h"
#include "assert.h"
#include "deviceTypes.h"

/* Private data*/
#define NBI2C_DEV_MAX   2
#define I2C_W   0x00
#define I2C_R   0x01
static tNBI2CMsg *msgToSend[NBI2C_DEV_MAX];
static tNBI2CMsg *msgToRead[NBI2C_DEV_MAX];
static cNBI2CDrv  *nbI2CDrvList[NBI2C_DEV_MAX] = {0};

/* PUBLIC FUNCTIONS */
void NBI2CDrv_Reset(const cNBI2CDrv * me);
/**
 * Construct the i2c driver instance.
 * @param me - instance of the driver
 * @param pConfig pointer to the config structure
 */
void NBI2CDrv_Ctor(cNBI2CDrv * me, const tI2CDevice * pConfig)
{
    uint8 tempBuf;
    if (NULL != me)
    {
        memcpy((void *)&me->config, (const void*)pConfig, sizeof(tI2CDevice));
        me->config.pvSlaveCallback = NULL;

        switch (me->config.i2cMode)
        {
            case I2C_MASTER_MODE:
            {
                SET_I2C1_SCL_OUTPUT;
                SET_I2C1_SDA_OUTPUT;
                I2CEnable(me->config.channel, FALSE);
                nbI2CDrvList[pConfig->channel] = me;
                me->i2cDataMode = I2C_DATA_INVALID_MODE;
                switch(me->config.channel)
                {
                    case I2C1:
                        I2C_CLEAR_INTERRUPT(I2C_ONE);
                        I2C_BAUDRATE_SET(I2C_ONE, me->config.baudRate);
                        I2CEnable(me->config.channel, TRUE);
                        tempBuf = I2C_RECEIVE_BUF(I2C_ONE);
                        i2c1IntEnable();
                        break;
                    case I2C2:
                        I2C_CLEAR_INTERRUPT(I2C_TWO);
                        I2C_BAUDRATE_SET(I2C_TWO, me->config.baudRate);
                        I2CEnable(me->config.channel, TRUE);
                        tempBuf = I2C_RECEIVE_BUF(I2C_TWO);
                        i2c2IntEnable();
                        break;
                    default:
                        return;
                }
                NBI2CDrv_Reset(me);
                break;
            }
            case I2C_SLAVE_MODE: /*TODO: to be implemented*/
                return;
                break;
            default:
                /* i2c mode have to be set as either master or slave*/
                return;
                break;
        }
        me->isIdle = TRUE;
    }
}

/**
 * Exit & clean up the driver.
 * @param me - instance of the driver
 */
void NBI2CDrv_Xtor(cNBI2CDrv * me)
{
    I2CEnable(me->config.channel, FALSE);
    /* set the I2C pin to tri-state to save power*/
    SET_I2C1_SCL_INPUT;
    SET_I2C1_SDA_INPUT;
}


/**
 * Get i2c baud rate - value of I2C1BRG register
 * @param  me - pointer to driver instance
 * return I2C1BRG value
 */
uint32 NBI2CDrv_GetBR(cNBI2CDrv * me)
{
    switch (me->config.channel)
    {
        case I2C1:
        {
            me->config.baudRate = I2C_BAUDRATE_GET(I2C_ONE);
            break;
        }
        case I2C2:
        {
            me->config.baudRate = I2C_BAUDRATE_GET(I2C_TWO);
            break;
        }
        default:{}
    }
    return me->config.baudRate;
}

/**
 * Set i2c baud rate - update register
 * @param  me - pointer to driver instance
 * @param update value
 */
void NBI2CDrv_SetBR(cNBI2CDrv * me, uint32 baudrate)
{
    me->config.baudRate = baudrate;
    switch (me->config.channel)
    {
        case I2C1:
        {
            I2C_BAUDRATE_SET(I2C_ONE, me->config.baudRate);
            break;
        }
        case I2C2:
        {
            I2C_BAUDRATE_SET(I2C_TWO, me->config.baudRate);
            break;
        }
        default:{}
    }

}

/**
 * Check if the driver is in a ready state.
 * @param me - instance of the driver
 * return driver instance status
 * TRUE  : driver is on and ready for read\write etc commands
 * FALSE : driver is off\or busy
 */
bool NBI2CDrv_isReady(const cNBI2CDrv * me)
{
    return me->isIdle;
}

/**
 * Reset the i2c channel
 * @param me - instance of the driver
 */
void NBI2CDrv_Reset(const cNBI2CDrv * me)
{
    switch (me->config.channel)
    {
        case I2C1:
        {
            I2C_HW_STOP_COND_ENABLE(I2C_ONE);
            /* wait for hardware clear of stop bit */
            while (I2C_IS_HW_STOP_COND_ENABLED(I2C_ONE));

            I2C_DISABLE_RECEIVE_MODE(I2C_ONE);
            I2C_CLEAR_INTERRUPT(I2C_ONE);
            I2C_CLEAR_WRITECOLLISION_DBIT(I2C_ONE);
            I2C_CLEAR_MASTERBUSCOLLISION_DBIT(I2C_ONE);
            break;
        }
        case I2C2:
        {
            I2C_HW_STOP_COND_ENABLE(I2C_TWO);
            /* wait for hardware clear of stop bit */
            while (I2C_IS_HW_STOP_COND_ENABLED(I2C_TWO));

            I2C_DISABLE_RECEIVE_MODE(I2C_TWO);
            I2C_CLEAR_INTERRUPT(I2C_TWO);
            I2C_CLEAR_WRITECOLLISION_DBIT(I2C_TWO);
            I2C_CLEAR_MASTERBUSCOLLISION_DBIT(I2C_TWO);
            break;
        }
    }
}

/**
 * This function triggers the master to write the start bit and the
 * I2C intterupt handler will take over the rest of the steps
 * @param me - instance of the driver
 * @param tI2CMsg * const  msg representing structure: length of the array to be sent.
 * and pointer to a uint8 array of size length to be sent over the I2C bus
 */
void NBI2CDrv_MasterWrite(cNBI2CDrv * me, tNBI2CMsg * const  msg)
{
    assert(me);
    assert(msg);
    /* remember the message, this is used for the interrup handler */
    msgToSend[me->config.channel] = msg;
    /* interrupt handler will reset isIdle to True once data TRM is done */
    me->isIdle = FALSE;
    me->i2cDataMode = I2C_DATA_WRITE_MODE;
    me->eI2CFault = I2C_NO_FAULT;
    me->I2CTrmStage = I2C_TRM_STAGE_WRITE_DEV_ADDRESS_W;
    me->dataIndex = 0;
    /* write the start bit */
    I2CStart(me->config.channel);
}

/**
 * This function triggers the master to write the start bit and the
 * I2C intterupt handler will take over the rest of the steps
 * @param me - instance of the driver
 * @param tI2CMsg * const  msg representing structure: length of the array to be read
 * and pointer to a uint8 array of size length to be read from the I2C bus
 */
void NBI2CDrv_MasterRead(cNBI2CDrv * const  me, tNBI2CMsg *  msg)
{
    assert(me);
    assert(msg);
    assert(msg->pMsg);
    me->isIdle = FALSE;
    msgToRead[me->config.channel] = msg;
    me->i2cDataMode = I2C_DATA_READ_MODE;
    me->eI2CFault = I2C_NO_FAULT;
    me->I2CTrmStage = I2C_TRM_STAGE_WRITE_DEV_ADDRESS_W;
    me->dataIndex = 0;
    I2CStart(me->config.channel);
}
/*
 * This function shoud be called everytime before you call NBI2CDrv_MasterRead
 * It means you have to tell the interrupt handler a way of handling the situation
 * once the trasmission is done
 */
void NBI2CDrv_RegisterIntReadCb(cNBI2CDrv * const  me, pNBI2CCb pCb)
{
    assert(me);
    assert(pCb);
    me->nbI2CReadCb = pCb;
}

/*
 * This function shoud be called everytime before you call NBI2CDrv_MasterWrite
 * It means you have to tell the interrupt handler a way of handling the situation
 * once the trasmission is done
 */
void NBI2CDrv_RegisterIntWriteCb(cNBI2CDrv * const  me, pNBI2CCb pCb)
{
    assert(me);
    assert(pCb);
    me->nbI2CWriteCb = pCb;
}

/**
 * Interrup handler will call this function to process the trasmission stage
 * @param channel - channel
 */
static void dataHandler(uint8 channel)
{
    switch (nbI2CDrvList[channel]->i2cDataMode)
    {
        case I2C_DATA_WRITE_MODE:
        {
            switch (nbI2CDrvList[channel]->I2CTrmStage)
            {
                case I2C_TRM_STAGE_WRITE_DEV_ADDRESS_W:
                {
                     /*Send slave address first*/
                    I2CSendByte(channel,(msgToSend[channel]->devAddr));
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_WRITE_DATA;
                    break;
                }
                case I2C_TRM_STAGE_WRITE_DATA:
                {
                    if(!I2CByteWasAcknowledged(channel))
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_ACK_ERROR;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                        break;
                    }
                    if (nbI2CDrvList[channel]->dataIndex == msgToSend[channel]->length)
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_NO_FAULT;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                    }
                    else /* there is more data bytes to send */
                    {
                        I2CSendByte(channel,msgToSend[channel]->pMsg[nbI2CDrvList[channel]->dataIndex]);
                        nbI2CDrvList[channel]->dataIndex++;
                    }
                    break;
                 }
                 case I2C_TRM_STAGE_DONE:
                 {
                    /* the callback function is responsible to handler I2C fault */
                     if(NULL != nbI2CDrvList[channel]->nbI2CWriteCb)
                     {
                        nbI2CDrvList[channel]->nbI2CWriteCb(nbI2CDrvList[channel]->eI2CFault);
                     }
                     nbI2CDrvList[channel]->isIdle = TRUE;
                     break;
                 }
                 default: break;
             }
             break;
        }
        case I2C_DATA_READ_MODE: /* read data from slave */
        {
            switch (nbI2CDrvList[channel]->I2CTrmStage)
            {
                case I2C_TRM_STAGE_WRITE_DEV_ADDRESS_W:
                {
                     /* slave address */
                    I2CSendByte(channel,(msgToRead[channel]->devAddr));
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_WRITE_REG_ADDRESS_H;
                    break;
                }
                case I2C_TRM_STAGE_WRITE_REG_ADDRESS_H:
                {
                    uint32 regAddr;
                    eI2CRegAddLen regAddrLen;
                    uint8 temp;
                    if(!I2CByteWasAcknowledged(channel))/* dev address ack received? */
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_ACK_ERROR;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                        break;
                    }
                    regAddr = msgToRead[channel]->regAddr;
                    regAddrLen = nbI2CDrvList[channel]->config.regAddrLen;
                    switch (regAddrLen)
                    {
                        case REG_LEN_8BITS:
                        {
                            temp = (uint8) regAddr;
                            I2CSendByte(channel,temp);
                            nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_REPEAT_START;
                            break;
                        }
                        case REG_LEN_16BITS:
                        {
                            temp = (regAddr >> 8);
                            I2CSendByte(channel,temp); /* sending register high 8 bits */
                            nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_WRITE_REG_ADDRESS_L;
                            break;
                        }
                        default:break;
                    }
                    break;
                }
                case I2C_TRM_STAGE_WRITE_REG_ADDRESS_L:
                {
                    if(!I2CByteWasAcknowledged(channel))/* reg high address ack received? */
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_ACK_ERROR;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                        break;
                    }
                    I2CSendByte(channel,(uint8)(msgToRead[channel]->regAddr));/* send lower 8 bit address */
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_REPEAT_START;
                    break;
                }
                case I2C_TRM_STAGE_REPEAT_START:
                {
                    if(!I2CByteWasAcknowledged(channel))/* reg address ack received? */
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_ACK_ERROR;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                        break;
                    }
                    I2CRepeatStart(channel);
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_WRITE_DEV_ADDRESS_R;
                    break;
                }
                case I2C_TRM_STAGE_WRITE_DEV_ADDRESS_R:
                {
                     /* slave address + R(I2C_R is bit 0 of this byte)*/
                    I2CSendByte(channel,(msgToRead[channel]->devAddr)|I2C_R);
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_CHECK_I2C_SLAVE_ACK;
                    break;
                }
                case I2C_TRM_STAGE_CHECK_I2C_SLAVE_ACK:
                {
                    if(!I2CByteWasAcknowledged(channel))/* ack for device address I2C_R */
                    {
                        nbI2CDrvList[channel]->eI2CFault = I2C_ACK_ERROR;
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        I2CStop(channel);  /* set Stop Condition bit */
                        break;
                    }
                    /* mandatory step, otherwise slave will not start transmit data*/
                    I2CReceiverEnable(channel,TRUE);
                    nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_READ_DATA;
                    break;
                }
                case I2C_TRM_STAGE_READ_DATA:
                {
                    if(nbI2CDrvList[channel]->dataIndex == msgToRead[channel]->length)
                    {
                        nbI2CDrvList[channel]->I2CTrmStage = I2C_TRM_STAGE_DONE;
                        nbI2CDrvList[channel]->eI2CFault = I2C_NO_FAULT;
                        I2CStop(channel);  /* set Stop Condition bit */
                    }
                    else if (nbI2CDrvList[channel]->dataIndex == (msgToRead[channel]->length-1))
                    {
                        /* The last byte to read */
                        msgToRead[channel]->pMsg[nbI2CDrvList[channel]->dataIndex] = I2CGetByte(channel);
                        nbI2CDrvList[channel]->dataIndex++;
                        I2CAcknowledgeByte(channel,FALSE);
                    }
                    else if(nbI2CDrvList[channel]->dataIndex < (msgToRead[channel]->length-1)) /* there is more data bytes to read */
                    {
                        msgToRead[channel]->pMsg[nbI2CDrvList[channel]->dataIndex] = I2CGetByte(channel);
                        I2CAcknowledgeByte(channel,TRUE);
                        nbI2CDrvList[channel]->dataIndex++;
                    }
                    break;
                }
                case I2C_TRM_STAGE_DONE:
                {
                    /* the callback function is responsible to handler I2C fault */
                    if(NULL != nbI2CDrvList[channel]->nbI2CReadCb)
                    {
                        nbI2CDrvList[channel]->nbI2CReadCb(nbI2CDrvList[channel]->eI2CFault);
                    }
                    nbI2CDrvList[channel]->isIdle = TRUE;
                    break;
                }
                default:break;
            }
            break;
        }
    default:break;
    }
    return nbI2CDrvList[channel]->isIdle;
}

/* To avoid doxygen character overwrite problem, we use the abbreviation as below
typedef enum
{
    I2C_TRM_STAGE_DONE = 0,            ->>>>DONE
    I2C_TRM_STAGE_WRITE_DATA,          ->>>>WRITE_DATA
    I2C_TRM_STAGE_WRITE_DEV_ADDRESS_W, ->>>>DEV_ADDR_W
    I2C_TRM_STAGE_WRITE_DEV_ADDRESS_R, ->>>>DEV_ADDR_R
    I2C_TRM_STAGE_WRITE_REG_ADDRESS_L, ->>>>REG_ADDR_L
    I2C_TRM_STAGE_WRITE_REG_ADDRESS_H, ->>>>REG_ADDR_H
    I2C_TRM_STAGE_REPEAT_START,        ->>>>REPEAT_START
    I2C_TRM_STAGE_CHECK_I2C_SLAVE_ACK, ->>>>SLAVE_ACK
    I2C_TRM_STAGE_MASTER_ACK_TRM,      ->>>>ACK_TRM
    I2C_TRM_STAGE_READ_DATA,           ->>>>READ_DATA
    I2C_TRM_STAGE_MASTER_ACK,          ->>>>MASTER_ACK
    I2C_TRM_STAGE_STOP                 ->>>>STOP
} eNBI2CTrmStage;
*/

/** This doxygen graph illustrates the state machine of writing data from master
 * to slaver
 * \msc
 *    StartBit, DEV_ADDR_W,
 *    WRITE_DATA, DONE,CallBack;
 *    StartBit->DEV_ADDR_W [label="writeStartBit"];
 *    DEV_ADDR_W->WRITE_DATA [label="I2CSendByte(data)"];
 *    DEV_ADDR_W->DONE [label="NoACK"];
 *    WRITE_DATA->WRITE_DATA [label="I2CSendByte(data)"];
 *    WRITE_DATA->DONE [label="NoACK"];
 *    WRITE_DATA->DONE [label="dataTrmDone"];
 *    DONE->CallBack [label="invokeCallBack"];
 * \endmsc
 */

/** This doxygen graph illustrates the state machine of reading data from slaver
 * to master
 *
 * \msc
 *    StartBit, DEV_ADDR_W, REG_ADDR_H,REG_ADDR_L,
 *    REPEAT_START,DEV_ADDR_R,SLAVE_ACK,READ_DATA, DONE,CallBack;
 *    StartBit->DEV_ADDR_W [label="writeStartBit"];
 *    DEV_ADDR_W->REG_ADDR_H [label="I2CSendByte(reg_h)"];
 *    REG_ADDR_H->DONE [label="NoACK"];
 *    REG_ADDR_H->REG_ADDR_L [label="I2CSendByte(reg_l)"];
 *    REG_ADDR_L->DONE [label="NoACK"];
 *    REG_ADDR_L->REPEAT_START [label="repeeat"];
 *    REPEAT_START->DEV_ADDR_R [label="I2CSendByte(devAddr)"];
 *    DEV_ADDR_R->SLAVE_ACK [label="checkACK"];
 *    SLAVE_ACK->DONE [label="NoACK"];
 *    SLAVE_ACK->READ_DATA [label="enableReceive"];
 *    READ_DATA->READ_DATA [label="readData"];
 *    READ_DATA->DONE [label="dataTrmDone"];
 *    DONE->CallBack [label="invokeCallback"];
 * \endmsc
 */
void __ISR( _I2C_1_VECTOR, ipl3) I2C1InterruptHandler(void)
{
    /* check for Slave and Bus events and respond accordingly */
    if (IFS1bits.I2C1SIF == 1)
    {
        mI2C1SClearIntFlag();
        return;
    }
    if (IFS1bits.I2C1BIF == 1)
    {
        /* clear interrup flag for BusCollision */
        mI2C1BClearIntFlag();
        return;
    }
    
    dataHandler(I2C1);

    mI2C1MClearIntFlag();  // clear interrupt flag - from Master
}
#include "stm32f0xx.h"
#include "AdcDrv.h"
#include "KeySrv.h"
#include "SettingSrv.h"
#include "SettingSrv_light.h"
#include "IrLearningDrv.h"
#include "IrLearningDrv_priv.h"
#include "projBSP.h"
#include "trace.h"
#include "IR.Config"

#ifndef IR_LEARNING_DRV_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif


#define MIN_NUMBER_OF_IR_BIT    3
#define MIN_NUMBER_OF_IR_PACKET     4           //3

// 6.4us per step
#define TIME_GAP_300MS          46875
#define TIME_GAP_350MS          54687
#define TIME_GAP_370MS          57812
#define TIME_GAP_400MS          62500

// 2ms per step
#define PENDING_TIME_300MS      150
#define PENDING_TIME_350MS      175
#define PENDING_TIME_370MS      185
#define PENDING_TIME_400MS      200


#define TIME_GAP                TIME_GAP_300MS
#define PENDING_TIME            PENDING_TIME_300MS


#ifndef IR_LEARNING
uint8	Key_sum,Key_sum2;
uint16	tra_num;
uint16 IR_DATA,IR_COM,IR_DATA1,IR_DATA2;
uint32	low_level_time;
uint8	num,tx_value,prex_value,IR2;
uint8	IRB[19],_9148_OK;
uint16	IRB_store[45];
#endif



const uint32 KeyMapTable[]= KEY_MAP;


static IRSTRU IR;		//set IR data to idata ram for fast INT
//IR_BIT_WIDTH IR_new_buff[NUMBER_OF_BIT], IR_prev_buff[NUMBER_OF_BIT];

static cIrLearningDrv* pIrLearningDrvObj;


const IR_MAP eeprom_keymap[NUM_OF_IR_LEARNING_KEY][2]@"SYS_NVM_SECTION"=
{
    {
        {
            .code = DEFAULT_IR_SONY_VOL_INC_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        },
        {
            .code = DEFAULT_IR_SONY_VOL_INC_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        }
    },

    {
        {
            .code = DEFAULT_IR_SONY_VOL_DEC_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        },
        {
            .code = DEFAULT_IR_SONY_VOL_DEC_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        }
    },
    {
        {
            .code = DEFAULT_IR_SONY_MUTE_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        },
        {
            .code = DEFAULT_IR_SONY_MUTE_CODE,
            .format = (IR_FORMAT)IR_FORMAT_SONY
        }
    },

};



static void IrKeyDrv_UpdateKeyStatus(cKeyDrv* me)
{
    uint8 i;
    cIrKeyDrv* pIrKeyObj;
    pIrKeyObj = (cIrKeyDrv*)me;
    for(i = 0; i < (pIrKeyObj->pKeyboardConfig->irKeyboard.keyNum); i++)
    {
        if((pIrKeyObj->super_.keyID) == (pIrKeyObj->pKeyboardConfig->pIrKeySet[i].keyId) && (pIrKeyObj->super_.keyID) == pIrLearningDrvObj->COMMAND)
        {
        
        }
    }
}


void IrKeyDrv_Ctor(cIrKeyDrv *me, const tIrKeyboardDevice *pIrKeyboardConfig, eKeyID keyID)
{
    me->pKeyboardConfig = pIrKeyboardConfig;
    me->super_.KeyGetRawDataCb = NULL;/*IrKeyDrv_ReadRawValue;*/
    me->super_.KeyStartScanCb = NULL;
    me->super_.KeyUpdateStatusCb = IrKeyDrv_UpdateKeyStatus;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_UP;
    me->super_.keyID = keyID;
    me->super_.isCreated = TRUE;
}

void IrRxDrv_Ctor()
{
    /* Enable the Externer interrup to detect the pulse generated by IR */
    ProjBsp_IR_EXTIConfig();
    /* Configure two times to mesure the pulse width */
    ProjBsp_IR_TimerConfig();
}

void IrRxDrv_Xtor()
{
    /* TO DO */
//    TIM_Cmd(TIM2, DISABLE);
//    TIM_Cmd(TIM3, DISABLE);
}

void IrLearningDrv_Ctor(cIrLearningDrv* me)
{
    //IrLearningDrv_SetIRDefault();
    pIrLearningDrvObj = me;
    
}

void IrLearningDrv_Xtor(cIrLearningDrv* me)
{
    pIrLearningDrvObj = NULL;
}


#ifdef ENABLE_DEBUG_PIN
void DEBUG_PIN_CONFIG(void)
{
    mPORTBSetPinsDigitalOut(BIT_5);
}

void TOGGLE_DEBUG_PIN(void)
{
    mPORTBToggleBits(BIT_5);
}
#endif



void CopyIRTimeMap(IR_TIME_MAP* dest, IR_TIME_MAP* src)
{
    for (uint8 i=0; i<TOTAL_DIFF; i++)
    {
        dest->data[i] = src->data[i];
        dest->counter[i] = src->counter[i];
    }

    dest->format = src->format;
    dest->code = src->code;
}


void CopyIRMap(IR_MAP* dest, IR_TIME_MAP* src)
{
    dest->format = src->format;
    dest->code = src->code;
}


bool CompareIRTimeMap(IR_TIME_MAP* src1, IR_TIME_MAP* src2)
{
#ifdef CHECK_IR_TIMING
    uint8 i;
    for (i=0; i<TOTAL_DIFF; i++)
    {
        if (!IsInRange(src1->data[i], src2->data[i]))
        {
            return 0;
        }
        if (src1->counter[i] != src2->counter[i])
        {
            return 0;
        }
    }
#endif

    if (src1->format != src2->format)
    {
        return 0;
    }
    else if (src1->code == src2->code)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

bool CompareIRMap(IR_MAP* src1, IR_TIME_MAP* src2)
{
    if (src1->format != src2->format)
    {
        return 0;
    }

    if (src1->code == src2->code)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


static void IR_decode_universal_code(cIrLearningDrv* me)
{
    uint8 i;
    IR_MAP default_keymap;			// added to support default remote control ANYTIME

    me->COMMAND=INVALID_KEY;

    for (i=0;i<ArraySize(KeyMapTable);i++)
    {
        if ((CompareIRMap((IR_MAP*)&eeprom_keymap[i][0], &(me->ir_keytime))) || (CompareIRMap((IR_MAP*)&eeprom_keymap[i][1], &(me->ir_keytime))))
        {
            me->COMMAND=(eKeyID)KeyMapTable[i];
            break;
        }

        // check also the default remote key
        switch (i)
        {
            case IR_KEY_VOL_UP:
                default_keymap.code = DEFAULT_IR_KLIPSCH_VOL_INC_CODE;
                default_keymap.format = (IR_FORMAT)DEFAULT_IR_VOL_INC_FORMAT;        //0x09;         //0x0a;                 // for test only
                break;
            case IR_KEY_VOL_DOWN:
                default_keymap.code = DEFAULT_IR_KLIPSCH_VOL_DEC_CODE;
                default_keymap.format = (IR_FORMAT)DEFAULT_IR_VOL_DEC_FORMAT;        //0x09;         //0x0a;                 // for test only
                break;
            case IR_KEY_MUTE:
                default_keymap.code = DEFAULT_IR_KLIPSCH_MUTE_CODE;
                default_keymap.format = (IR_FORMAT)DEFAULT_IR_MUTE_FORMAT;
                break;
/*
            case IR_KEY_SOURCE:
                default_keymap.code = DEFAULT_IR_SOURCE_CODE;
                default_keymap.format = (IR_FORMAT)DEFAULT_IR_SOURCE_FORMAT;
                break;
*/
            case IR_KEY_POWER:
                default_keymap.code = DEFAULT_IR_KLIPSCH_POWER_CODE;
                default_keymap.format = (IR_FORMAT)DEFAULT_IR_POWER_FORMAT;
                break;
            default:

                break;
        }
        if (CompareIRMap(&default_keymap, &(me->ir_keytime)))
        {
            me->COMMAND=(eKeyID)KeyMapTable[i];
            break;
        }
    }
    if(me->COMMAND)
    {
        me->bValidIr = 1;
    }
}

static void Set_edge_trigger(EDGE_STATE mode)
{
    EXTI_InitTypeDef   EXTI_InitStructure;
    /* Configure EXTI0 line */
    EXTI_InitStructure.EXTI_Line = EXTI_Line0;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    if(mode == FALLING_EDGE)
    {
        EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
        IR.current_trigger_mode=FALLING_EDGE;
    }
    else if(mode == RISING_EDGE)
    {
        EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
        IR.current_trigger_mode=RISING_EDGE;
    }
    else if(mode == BOTH_EDGE)
    {
        EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
        IR.current_trigger_mode=BOTH_EDGE;
    }
    EXTI_Init(&EXTI_InitStructure);
}

void IRreset(void)
{
    cIrLearningDrv* me=pIrLearningDrvObj;
    IR.RCBitCnt=0;
    IR.RCBits1=0;
    IR.RCBits2=0;
    IR.HeadPulse=0;
    IR.status = IR_IDLE;
    IR.necirholdtime=0;
    IR.just_released=0;
    IR.release_countdown=0;
    Set_edge_trigger(FALLING_EDGE);

    IR.package_number = 0;
    IR.non_repeat_code = 0;
    IR.broken_tail_cnt = 0;
    IR.tail_exist = 0;
    //memset(IR_repeat_buff, 0, sizeof(IR_repeat_buff));
     memset(&(me->IR_prev_buff), 0, sizeof(&(me->IR_prev_buff)));
}


static uint32 FindMax(IR_BIT_WIDTH* buf, uint8 len)
{
    uint32 retVal=0;
    uint8 i;
    for (i=0;i<len;i++)
    {
        if (buf[i].low>retVal)
            retVal=buf[i].low;
        if (buf[i].high>retVal)
            retVal=buf[i].high;
    }
    return retVal;
}

static uint32 FindMin(IR_BIT_WIDTH* buf, uint8 len)
{
    uint32 retVal=buf[0].low;
    uint8 i;
    for (i=0;i<len;i++)
    {
        if (buf[i].low<retVal)
            retVal=buf[i].low;
        if (buf[i].high<retVal)
            retVal=buf[i].high;
    }
    return retVal;
}

static bool IsInRange(uint32 centre, uint32 value, uint8 tolerance)
{
    return (value>=centre-tolerance  && value<=centre+tolerance);
}

uint8 CompareCaptureCode(IR_BIT_WIDTH* buf1, IR_BIT_WIDTH* buf2, uint8 length)
{
    uint8 i;

    for (i=0; i<length; i++)
    {
        if (!((IsInRange(buf1[i].low, buf2[i].low, buf1[i].low/10))&&(IsInRange(buf1[i].high, buf2[i].high, buf1[i].high/10)) ))
        {
            return 0;
        }
    }

    return 1;
}

void CopyCaptureCode(cIrLearningDrv* me)
{
    for (uint16 i=0; i<NUMBER_OF_BIT; i++)
    {
        me->IR_prev_buff[i].low = me->IR_new_buff[i].low;
        me->IR_prev_buff[i].high = me->IR_new_buff[i].high;
    }
}

uint8 IsRC6Format(cIrLearningDrv* me, uint8 len, IR_BIT_WIDTH* buf)
{
    uint8 i;
    uint32 high_2T, low_2T, low_6T, high_3T, low_3T;
    uint8 LowEqual2T = 0, HighEqual2T = 0, LowEqual3T = 0, HighEqual3T = 0, LowEqual6T = 0;
    uint8 ret = 0;        



    low_6T = me->low_T*6;
    low_2T = me->low_T<<1;
    high_2T = me->high_T<<1;
    low_3T = me->low_T*3;
    high_3T = me->high_T*3;

    LowEqual6T = IsInRange(buf[0].low, low_6T, buf[0].low/10);

    for (i=0;i<len;i++)
    {
        HighEqual2T |= IsInRange(high_2T, buf[i].high, high_2T/5);
        LowEqual2T |= IsInRange(low_2T, buf[i].low, low_2T/5);
        HighEqual3T |= IsInRange(high_3T, buf[i].high, high_3T/5); 
        LowEqual3T |= IsInRange(low_3T, buf[i].low, low_3T/5); 
        if ((LowEqual6T)&&(((HighEqual2T)&&(LowEqual2T))||((HighEqual3T)&&(LowEqual3T))))                   // if any time slot equal to low 2T, and  high 2T
        {
            ret = 1;
            break;
        }
    }
    
    return ret;    
}


uint8 IsRC5Format(cIrLearningDrv* me, uint8 len, IR_BIT_WIDTH* buf)
{
    uint8 i;
    uint32 high_2T, low_2T;

    uint8 LowEqual2T = 0, HighEqual2T = 0;
    uint8 ret = 0;

    high_2T = me->high_T << 1;
    low_2T = me->low_T << 1;

    for (i=0;i<len;i++)
    {
        HighEqual2T |= IsInRange(buf[i].high, high_2T, buf[i].high/10);
        LowEqual2T |= IsInRange(buf[i].low, low_2T, buf[i].low/10);

        if (((HighEqual2T)&&(LowEqual2T))&&(i!=0))                   // if any time slot equal to low 2T, and  high 2T
        {
            ret = 1;
            break;
        }
    }
    // if min high and min low is not equal, still not RC-5 extension, otherwise, this may be "SHARP" protocol
    if (!(IsInRange(me->high_T, me->low_T, me->high_T*15/100)))                
    {
        ret = 0;
    }

    return ret;
}

static bool IsManchesterFormat(cIrLearningDrv* me, uint8 len, IR_BIT_WIDTH* buf)
{
    uint32 high_5T, high_4T, high_6T;
    uint8 HighEqual5T, HighEqual4T, HighEqual6T;
    uint8 i;
    bool ret = 0;

    //binary_bit = 1;						// initial value must be "1"
    high_5T = me->high_T*5;
    high_4T = me->high_T*4;
    high_6T = me->high_T*6;


    for (i=0;i<len;i++)
    {
        HighEqual5T = IsInRange(buf[i].high, high_5T, buf[i].high/5);
        HighEqual4T = IsInRange(buf[i].high, high_4T, buf[i].high/5);
        HighEqual6T = IsInRange(buf[i].high, high_6T, buf[i].high/5);

        if (((HighEqual5T)||(HighEqual4T)||(HighEqual6T))&&(i!=0))                   // if equal to 6T, 5T or 4T, fix IN3124
        {
            ret = 1;
            break;
        }
    }

    if (!(IsInRange(me->high_T, me->low_T, me->high_T*15/100)))                // if min high and min low is not equal, still not RC-5 extension, otherwise, this may be "SHARP" protocol
    {
        ret = 0;
    }

    return ret;
}



IR_FORMAT DetermineCaptureFormat(uint8 len, IR_BIT_WIDTH* buf)
{
    uint32 retVal=0x00000000;
    //uint32 retVal_high = 0x00000000;
    //uint32 retVal_low = 0x00000000;

    uint8 i, j, pos;
    uint8 flag_already_record, flag_finished;
    uint8 index[TOTAL_DIFF];
    IR_FORMAT ret;

    cIrLearningDrv* me = pIrLearningDrvObj;
    //find the 2 most common pattern

    // initialize value
    pos = 0;
    flag_finished = 0;
    memset(&(me->ir_keytime), 0, sizeof(me->ir_keytime));
    memset(index, 0, sizeof(index));
/*
    for (i=0; i<TOTAL_DIFF; i++)
    {
        me->ir_keytime.data[i] = 0;
        me->ir_keytime.counter[i] = 0;
        index[i] = 0;
    }
*/
    me->high_T = 0xffff;
    me->low_T = 0xffff;
    i = 0;

    
    while (i<len-1)
    {
        retVal = buf[i].high + buf[i].low;
        if ((me->high_T > buf[i].high)&&(buf[i].high!=0))
            me->high_T = buf[i].high;

        if ((me->low_T > buf[i].low)&&(buf[i].low!=0))
            me->low_T = buf[i].low;

        flag_already_record = 0;
        j=0;
        while (j<pos)		// checked if stored in data[] before
        {
            if (IsInRange(retVal,me->ir_keytime.data[j], retVal*12/100))	// if yes, next ir_buf[]
            {
                flag_already_record = 1;
                i++;
                break;
            }
            j++;
        }

        if (flag_already_record == 0)	// if not,
        {
            me->ir_keytime.data[pos] = retVal;
            me->ir_keytime.counter[pos] = 1;
            for (j=i+1; j<len; j++)
            {
                // found common pattern
                if (IsInRange(retVal, (buf[j].high+buf[j].low),retVal*15/100))      // within 15%
                {
                    me->ir_keytime.counter[pos] ++;
                    retVal=me->ir_keytime.data[pos]=(me->ir_keytime.data[pos]+(buf[j].high+buf[j].low))/2;
                }
                else	// if different pattern, store next position.
                {
                    if (index[pos]==0)
                    {
                        index[pos] = j;
                        if (j >= len)
                        {
                                flag_finished = 1;
                                break;
                        }
                    }
                }
            }

            if (flag_finished)
                    break;

            if (index[pos]==0)		// if no updated, goto next pulse
                    i++;
            else
                    i = index[pos];		// goto that position and start compare again.

            pos++;
            if (pos > TOTAL_DIFF)
                    break;				//
        }	// if (flag_already_record == 0)
    }	// while (i<len-1)

   // Find the mean of high_T and low_T
        for (i=0;i<=len;i++)			// ignore the first pulse to search the min high and min low
        {
            if (IsInRange(me->high_T, buf[i].high, me->high_T/5))
            {
                me->high_T = (me->high_T+buf[i].high)/2;
            }

            if (IsInRange(me->low_T, buf[i].low, me->low_T/5))
            {
                me->low_T = (me->low_T+buf[i].low)/2;
            }
        }


        if (me->ir_keytime.counter[1]==0)
        {
            ret = IR_FORMAT_SAME_WIDTH;
        }
        else if (me->ir_keytime.counter[2]==0)
        {
            ret = IR_FORMAT_NO_HEAD;
        }
        else if ((me->ir_keytime.counter[0]==1)&&(me->ir_keytime.counter[3]==0))
        {
            /* One Header bit and no 4th type of bit find */
            if (IsInRange(IR_SONY_HEADER_WIDTH, me->IR_new_buff[0].low, IR_SONY_HEADER_WIDTH/10))
                ret = IR_FORMAT_SONY;
            else
                ret = IR_FORMAT_HEAD;
        }
        // check if really Manchester/RC-5/RC-5 extension
        else if (IsManchesterFormat(me, len,buf))
        {
            ret = IR_FORMAT_MANCHESTER;
        }
        else if ((me->ir_keytime.counter[0]==1)&&(me->ir_keytime.counter[3]==1))
        {
            ret = IR_FORMAT_DELAY;
        }
        else
        {
            ret = IR_FORMAT_OTHER;
        }



        if (IsRC6Format(me, len,buf))
        {
            ret = IR_FORMAT_RC6;
        }

        if (ret == IR_FORMAT_NO_HEAD)
        {
            if (IsRC5Format(me, len,buf))
            {
                ret = IR_FORMAT_RC5;
            }
        }
    return ret;


}


uint32 QuantifyCapturedCode(IR_BIT_WIDTH* buf1, uint8 len, IR_FORMAT format)
{
    uint32 retVal=0x00000000;
    uint32 one_threshold, zero_threshold, threshold;
    uint8 i;
    cIrLearningDrv* me = pIrLearningDrvObj;

    if (format == IR_FORMAT_RC6)
    {
        uint32 high_2T, low_2T, high_3T, low_3T;
        uint8 LowEqualT, LowEqual2T, HighEqualT, HighEqual2T, LowEqual3T, HighEqual3T;


        high_2T = me->high_T << 1;
        low_2T = me->low_T << 1;
        high_3T = me->high_T*3;
        low_3T = me->low_T*3;

        for (i=4;i<=len;i++)                // ignore i=0 header/leader
        {
            LowEqualT = IsInRange(me->low_T, buf1[i].low, me->low_T/5);             // range of 20%
            HighEqualT = IsInRange(me->high_T, buf1[i].high, me->high_T/5);         // range of 20%
            LowEqual2T = IsInRange(low_2T, buf1[i].low, low_2T/5);                  // range of 20%
            HighEqual2T = IsInRange(high_2T, buf1[i].high, high_2T/5);              // range of 20%
            LowEqual3T = IsInRange(low_3T, buf1[i].high, low_3T/5);                 // range of 20%
            HighEqual3T = IsInRange(high_3T, buf1[i].high, high_3T/5);              // range of 20%

            if (HighEqualT)
            {
                retVal=(retVal<<2)|0x01;
            }
            else if (HighEqual2T)
            {
                retVal=(retVal<<2)|0x10;
            }
            else if (HighEqual3T)
            {
                retVal=(retVal<<2)|0x11;
            }
            else
            {
                retVal=(retVal<<2);
            }
            
            if (LowEqualT)
            {
                retVal=(retVal<<2)|0x01;
            }
            else if (LowEqual2T)
            {
                retVal=(retVal<<2)|0x10;
            }
            else if (LowEqual3T)
            {
                retVal=(retVal<<2)|0x11;
            }
            else
            {
                retVal=(retVal<<2);
            }
                
            
                
        }
    }
    else if ((format == IR_FORMAT_MANCHESTER)||(format == IR_FORMAT_RC5))
    {

        uint32 high_2T, low_2T, high_4T, high_5T, high_6T;

        uint8 binary_bit;
        uint8 LowEqualT, LowEqual2T, HighEqualT, HighEqual2T, HighEqual4T, HighEqual5T, HighEqual6T;


        binary_bit = 1;				    // initial value must be "1"

        high_2T = me->high_T << 1;
        low_2T = me->low_T << 1;
        high_4T = me->high_T<<2;
        high_5T = me->high_T*5;
        high_6T = me->high_T*6;


        for (i=0;i<=len;i++)
        {
            LowEqualT = IsInRange(buf1[i].low, me->low_T, buf1[i].low/5);
            LowEqual2T = IsInRange(buf1[i].low, low_2T, buf1[i].low/5);
            HighEqualT = IsInRange(buf1[i].high, me->high_T,buf1[i].high/5);
            HighEqual2T = IsInRange(buf1[i].high, high_2T, buf1[i].high/5);
            HighEqual4T = IsInRange(buf1[i].high, high_4T, buf1[i].high/5);
            HighEqual5T = IsInRange(buf1[i].high, high_5T, buf1[i].high/5);
            HighEqual6T = IsInRange(buf1[i].high, high_6T, buf1[i].high/5);

            if ((LowEqualT)&&(HighEqualT))
            {
                retVal <<= 1;
                retVal |= binary_bit;
            }
            else if ((LowEqualT)&&(HighEqual2T))
            {
                retVal <<= 1;
                retVal &= ~0x00000001;		// "0"
                binary_bit = 1;
            }
            else if ((LowEqual2T)&&(HighEqualT))
            {
                retVal <<= 2;
                retVal |= 0x00000002;
                binary_bit = 0;
            }
            else if ((LowEqual2T)&&(HighEqual2T))
            {
                retVal <<= 2;
                retVal |= 0x00000002;
                binary_bit = 1;
            }
            else if ((LowEqualT)&&(HighEqual4T))
            {
                retVal <<= 1;
                retVal |= 0x00000001;
                binary_bit = 0;
            }
            else if ((LowEqualT)&&(HighEqual5T))                // keep binary_bit: if it is "1", it also be "1" after this break time; then ver verse
            {
                retVal <<= 1;
                retVal |= binary_bit;
            }
            else if ((LowEqual2T)&&(HighEqual5T))
            {
                retVal <<= 2;
                retVal |= 0x00000002;
                binary_bit = 0;
            }
            else if ((LowEqual2T)&&(HighEqual6T))
            {
                retVal <<= 2;
                retVal |= 0x00000002;
                binary_bit = 1;
            }
            else if ((LowEqualT)&&(HighEqual6T))
            {
                retVal <<= 1;
                retVal &= ~0x00000001;
                binary_bit = 1;
            }
            else if ((LowEqualT)&&(i==len))							// and last bit
            {
                retVal <<= 1;
                //retVal &= ~0x00000001;
                retVal |= binary_bit;
            }
            else if ((LowEqual2T)&&(i==len))							// and last bit
            {
                retVal <<= 2;
                retVal |= 0x00000002;
            }
            else
            {
                // error, does not exist such case
            }
        }
    }
    else if ((format==IR_FORMAT_HEAD)||(format==IR_FORMAT_DELAY)||(format==IR_FORMAT_SAMSUNG))		// with SYN Head, falling trigger width cycle ONLY
    {
        zero_threshold = (me->ir_keytime.data[1] < me->ir_keytime.data[2]) ? me->ir_keytime.data[1] : me->ir_keytime.data[2];
        one_threshold = (me->ir_keytime.data[1] > me->ir_keytime.data[2]) ? me->ir_keytime.data[1] : me->ir_keytime.data[2];

        for (i=0;i<len;i++)
        {
            if (IsInRange((buf1[i].high+buf1[i].low), zero_threshold, (buf1[i].high+buf1[i].low)/10))
                retVal <<= 1;
            else if (IsInRange((buf1[i].high+buf1[i].low), one_threshold, (buf1[i].high+buf1[i].low)/10))
                retVal = (retVal<<1)|0x01;
        }
        if (format==IR_FORMAT_SAMSUNG)
        {
            retVal|=0x80000000;
        }
    }
    else if (format==IR_FORMAT_NO_HEAD)
    {
        zero_threshold = (me->ir_keytime.data[0] < me->ir_keytime.data[1]) ? me->ir_keytime.data[0] : me->ir_keytime.data[1];
        one_threshold = (me->ir_keytime.data[0] > me->ir_keytime.data[1]) ? me->ir_keytime.data[0] : me->ir_keytime.data[1];

        for (i=0;i<len;i++)
        {
            if (IsInRange((buf1[i].high+buf1[i].low), zero_threshold, (buf1[i].high+buf1[i].low)/10))
                retVal <<= 1;
            else if (IsInRange((buf1[i].high+buf1[i].low), one_threshold, (buf1[i].high+buf1[i].low)/10))
                retVal = (retVal<<1)|0x01;
        }
    }
    else if (format==IR_FORMAT_SAME_WIDTH)
    {
        zero_threshold = buf1[0].low;
        for (i=1;i<len;i++)
        {
            if (IsInRange(buf1[i].low, zero_threshold, buf1[i].low/10))
                retVal <<= 1;
            else
                retVal = (retVal<<1)|0x01;
        }
    }
    else	//IR_FORMAT_OTHER, e.g. Machester
    {
        one_threshold = FindMax(&buf1[1],len-1);			// ignore the Header if exist
        zero_threshold = FindMin(&buf1[1],len-1);
        threshold = (one_threshold + zero_threshold)/2;

        for (i=0;i<len;i++)
        {
            if (buf1[i].low<threshold)
                retVal<<=1;
            else
                retVal=retVal<<1|0x01;
            if (buf1[i].high<threshold)
                retVal<<=1;
            else
                retVal=retVal<<1|0x01;
        }
    }
    return retVal;

}

void ResetIRConditions(void)
{
}

void IrLearningDrv_LearningEdgeISR(cIrLearningDrv* me)
{
    static IR_BIT_WIDTH IR_repeat_buff[MIN_NUMBER_OF_IR_BIT];
    static uint8 i=0;
    static uint8 buff_len;
    //uint32 CaptureCode;
    //IR_FORMAT CaptureFormat=IR_FORMAT_NG;
    IR.PulseWidth= ReadTimer2();  //get value from Timer RC
    WriteTimer2(0);
    switch (IR.status)
    {
        case IR_IDLE:
            Set_edge_trigger(RISING_EDGE);
            IR.status=LEADER_ON;
            IR.Ir2ms5Cnt = 0;

            me->ir_keytime.format = IR_FORMAT_NG;
            me->ir_keytime.code = 0xFFFFFFFF;
            {
                //unsigned char k;
                memset(IR_repeat_buff, 0, sizeof(IR_repeat_buff));
                //memset(&(me->IR_prev_buff), 0, sizeof(&(me->IR_prev_buff)));
                //for (k=0;k<MIN_NUMBER_OF_IR_BIT;k++)
                //{
                //    IR_repeat_buff[k].high = 0;
                //    IR_repeat_buff[k].low = 0;
                //}
               
                //for (k=0;k<NUMBER_OF_BIT;k++)
                //{
                //    me->IR_prev_buff[k].low = 0x00;
                //    me->IR_prev_buff[k].high = 0x00;
                //    me->IR_new_buff[k].low = 0x00;
                //    me->IR_new_buff[k].high = 0x00;
                //}
            }
            break;

        case LEADER_ON:
            Set_edge_trigger(FALLING_EDGE);
            me->IR_new_buff[0].low = IR.PulseWidth;         //record the first pulse
            IR.status = LEADER_OFF;

            me->IRDecodeState = BUTTON_IDLE;            // fix repeat key false trigger
            break;

        case LEADER_OFF:
            Set_edge_trigger(RISING_EDGE);
            {
                me->IR_new_buff[0].high = IR.PulseWidth;
                IR.status = CUSTOM_DATA;
                IR.custom_code = 0;
                IR.RCBitCnt = 0;
                if (IR.PulseWidth>TIME_GAP ||(me->IR_new_buff[0].high+me->IR_new_buff[0].low>TIME_GAP))        //if header pulse is >300ms or measure pulse>300ms, reset the FSM
                    IRreset();
                i = 1;
            }
            me->IRDecodeState = BUTTON_IDLE;            // fix repeat key false trigger
            break;

        case CUSTOM_DATA:
            if (IR.current_trigger_mode==FALLING_EDGE)
            {
                me->IR_new_buff[i].high=IR.PulseWidth;
                Set_edge_trigger(RISING_EDGE);
            }
            else //(current_trigger_mode==RISING_EDGE)
            {
                me->IR_new_buff[i].low=IR.PulseWidth;
                me->IR_new_buff[i].high=0;		//after measure the low pulse, clear the high pulse.
                Set_edge_trigger(FALLING_EDGE);
            }
            buff_len=i;
            me->gbBuff_IR_Len = i;

            if (me->IR_new_buff[i].high > 1640)        // (1640 * 6.4us =  10.5ms)
            {
                if (!buff_len)		//error checking
                {
                    IRreset();
                    ResetIRConditions();
                    return;
                }
                IR.repeat_flag=0;
                if (i > MIN_NUMBER_OF_IR_BIT)					// added if any noise in IR, 24-02-2012
                {
                    IR.package_number++;
                    if (IR.package_number >= MIN_NUMBER_OF_IR_PACKET)
                    {
                        me->repHeader=1;
                        me->decodeLen = buff_len;
                        memcpy(me->IR_decode_buff, me->IR_new_buff, sizeof(me->IR_new_buff));

                        //TP_PRINTF("%d\r\n",CaptureCode);
                        me->IR_can_decode=1;	//valid code received, start decode to a key
                        me->IRDecodeState = BUTTON_PRESS;
                        IR.Ir2ms5Cnt=0;
                        IR.status = IR_REP_LEADER;
                        IR.repeat_count = 0;
                        Set_edge_trigger(RISING_EDGE);
                        IR.wait_next_package = 0;           // no need to wait next package, just goto IR_REP_LEADER, the remaining waveform is repeat key waveform.
                    }
                    else 
                    {
                        // HEADER and code are already received
                        me->repHeader=5;
                        me->decodeLen = me->gbBuff_IR_Len;
                        memcpy(me->IR_decode_buff, me->IR_new_buff, sizeof(me->IR_new_buff));
                        CopyCaptureCode(me);
                        me->gbBuff_Prev_IR_Len = me->gbBuff_IR_Len;
                        IR.Ir2ms5Cnt=0;
                        IR.status = LEADER_ON;
                        IR.repeat_count = 0;
                        Set_edge_trigger(RISING_EDGE);
                        IR.wait_next_package = 1;           // wait for next package.
                    }
                }
                else        // buff_len < MIN_NUMBER_OF_IR_BIT
                {
                    // decode last package, set as IR_REP_LEADER;
                    me->repHeader=4;
                    me->decodeLen = me->gbBuff_Prev_IR_Len;
                    memcpy(me->IR_decode_buff, me->IR_prev_buff, sizeof(me->IR_prev_buff));

                    me->IR_can_decode=1;	//valid code received, start decode to a key
                    me->IRDecodeState = BUTTON_PRESS;
                    IR.Ir2ms5Cnt=0;
                    IR.status = IR_REP_LEADER;
                    IR.repeat_count = 0;
                    Set_edge_trigger(RISING_EDGE);
                    IR.wait_next_package = 0;           // no need to wait next package, just goto IR_REP_LEADER, the remaining waveform is repeat key waveform.

                    me->previous_ir_keytime.code = me->ir_keytime.code;
                    me->previous_ir_keytime.format = me->ir_keytime.format;
                    TP_PRINTF(".");
                }
                ResetIRConditions();

                if (IR.TimeGapCnt_Enable == 1)
                {
                    IR.TimeGapCnt = 0;
                    IR.TimeGapCnt_Enable = 0;
                }
                return;
            }

            if (IR.current_trigger_mode==RISING_EDGE)
                i++;
            if (i>NUMBER_OF_BIT-1)
                i=0;
            IR.Ir2ms5Cnt=0;
            break;

        case IR_REP_LEADER:
            Set_edge_trigger(FALLING_EDGE);
            me->IR_new_buff[0].low = IR.PulseWidth;         // record the first low pulse
            IR.status = IR_REP_LEADER_OFF;
            break;

        case IR_REP_LEADER_OFF:
            Set_edge_trigger(RISING_EDGE);
            {
                me->IR_new_buff[0].high = IR.PulseWidth;    // record the first high pulse
                IR.status = IR_REP_CUSTOM_DATA;
                IR.custom_code = 0;
                IR.RCBitCnt = 0;
                if (IR.PulseWidth>TIME_GAP ||(me->IR_new_buff[0].high+me->IR_new_buff[0].low>TIME_GAP))        //if header pulse is >100ms or measure pulse>100ms, reset the FSM
                    IRreset();
                i = 1;
            }
            break;

        case IR_REP_CUSTOM_DATA:
            if (IR.current_trigger_mode==FALLING_EDGE)
            {
                me->IR_new_buff[i].high=IR.PulseWidth;
                Set_edge_trigger(RISING_EDGE);
            }
            else //(current_trigger_mode==RISING_EDGE)
            {
                me->IR_new_buff[i].low=IR.PulseWidth;
                me->IR_new_buff[i].high=0;		//after measure the low pulse, clear the high pulse.
                Set_edge_trigger(FALLING_EDGE);
            }
            buff_len=i;
            me->gbBuff_IR_Len = i;

            if (me->IR_new_buff[i].high > 1640)        // (1640 * 6.4us =  10.5ms)
            {

                if (!buff_len)		//error checking
                {
                    IRreset();
                    ResetIRConditions();
                    return;
                }

                if (i > MIN_NUMBER_OF_IR_BIT)					// added if any noise in IR, 24-02-2012
                {
                    me->repHeader = 2;
/*
                    CaptureFormat=DetermineCaptureFormat(buff_len,me->IR_new_buff);
                    me->ir_keytime.format = CaptureFormat;
                    CaptureCode=QuantifyCapturedCode(me->IR_new_buff, buff_len, CaptureFormat);
                    me->ir_keytime.code = CaptureCode;
                    me->previous_ir_keytime.code = me->ir_keytime.code;
                    me->previous_ir_keytime.format = me->ir_keytime.format;
*/

                    if ((me->ir_keytime.format != me->previous_ir_keytime.format)||(me->ir_keytime.code != me->previous_ir_keytime.code))
                    {
                        IR.non_repeat_code++;
                        //if ((IR.non_repeat_code > 1)&&((ir_keytime.format!=IR_FORMAT_MANCHESTER)&&(ir_keytime.format!=IR_FORMAT_SAME_WIDTH)))
                        if (IR.non_repeat_code > 1)
                        {
                            IRreset();
                        }
                        //else if ((ir_keytime.format!=IR_FORMAT_MANCHESTER)&&(ir_keytime.format!=IR_FORMAT_SAME_WIDTH)&&(previous_ir_keytime.format!=IR_FORMAT_MANCHESTER)&&(previous_ir_keytime.format!=IR_FORMAT_SAME_WIDTH))
                        else if ((me->ir_keytime.format == IR_FORMAT_HEAD)||(me->previous_ir_keytime.format == IR_FORMAT_HEAD)
                            ||(me->ir_keytime.format == IR_FORMAT_SONY)||(me->previous_ir_keytime.format == IR_FORMAT_SONY))
                        {
                            // comment this can help fixing sudden change from "vol+" to "vol-" on default remote
                            //if (IR.tail_exist == 1)
                            {
                                me->IR_can_decode=1;	//valid code received, start decode to a key
                                me->IRDecodeState = BUTTON_PRESS;
                                IR.Ir2ms5Cnt=0;
                                IR.status = IR_REP_LEADER;
                                IR.repeat_count = 0;
                                Set_edge_trigger(RISING_EDGE);
                                IR.wait_next_package = 0;           // no need to wait next package, just goto IR_REP_LEADER, the remaining waveform is repeat key waveform.
                                IR.repeat_flag = 0;

                                //TP_PRINTF("c)");
                            }
                            /*
                            else
                            {
                                IR.repeat_flag = 1;
                                me->IRDecodeState = REPEATED_COMMAND;
                                IR.Ir2ms5Cnt=0;
                                IR.status = IR_REP_LEADER;
                                Set_edge_trigger(RISING_EDGE);
                            }
                             */
                        }
                        // added this for test
                        else
                        {
                            IR.repeat_flag = 1;
                            me->IRDecodeState = REPEATED_COMMAND;
                            IR.Ir2ms5Cnt=0;
                            IR.status = IR_REP_LEADER;
                            Set_edge_trigger(RISING_EDGE);
                            //TP_PRINTF("d)");
                        }
                    }
                    else
                    {

                        //IR.repeat_count=2;
                        IR.repeat_flag = 1;
                        me->IRDecodeState = REPEATED_COMMAND;       // When it is a SONY like repeat pulse, it goes through here.
                        IR.Ir2ms5Cnt=0;
                        IR.status = IR_REP_LEADER;
                        Set_edge_trigger(RISING_EDGE);
                        IR.non_repeat_code = 0;
                        me->bValidIr=1;
                        //TP_PRINTF("SR");
                        //TP_PRINTF("2)REPEATED_COMMAND \r\n");
                    }
                }
                else        // buff_len <= MIN_NUMBER_OF_IR_BIT
                {
                    // Need to check the timing to see if fitting the limit
                    unsigned char k;
                    unsigned char ret=1;
                    for (k=0;k<MIN_NUMBER_OF_IR_BIT;k++)
                    {
                        if (!((IsInRange(IR_repeat_buff[k].high, me->IR_new_buff[k].high, IR_repeat_buff[k].high/10))&&(IsInRange(IR_repeat_buff[k].low, me->IR_new_buff[k].low, IR_repeat_buff[k].low/10))))
                        {
                            ret = 0;
                            break;
                        }
                    }

                    if (ret == 0)           // if not good, update temperary buffer.
                    {
                        IR.broken_tail_cnt++;
                        if (IR.broken_tail_cnt > 1)
                        {
                            ret = 0;
                        }
                        else
                        {
                            ret = 1;
                        }

                        for (k=0;k<3;k++)
                        {
                            IR_repeat_buff[k].high = me->IR_new_buff[k].high;
                            IR_repeat_buff[k].low = me->IR_new_buff[k].low;
                        }
                    }

                    if (ret == 1)       // if the same as previous repeat key pulse
                    {
                        IR.repeat_flag = 1;
                        me->IRDecodeState = REPEATED_COMMAND;
                        IR.Ir2ms5Cnt=0;
                        IR.status = IR_REP_LEADER;
                        Set_edge_trigger(RISING_EDGE);
                        IR.tail_exist = 1;
                        //TP_PRINTF("r");         // When there is a NEC like repeat pulse.
                        me->bValidIr = 1;       // because it is a repeat pulse, treat it as valid pulse.
                    }
                }
                ////// add below low driver below leave
                ResetIRConditions();
                //////////
                //if (IR.TimeGapCnt_Enable == 1)
                {
                    IR.TimeGapCnt = 0;
                //    IR.TimeGapCnt_Enable = 0;
                }
                return;
            }

            if (IR.current_trigger_mode==RISING_EDGE)
                i++;
            if (i>NUMBER_OF_BIT-1)
                i=0;
            IR.Ir2ms5Cnt=0;
            break;

        default:
            break;
    }

    // Setup Timer 23 (timer 2 + timer 3, 32bit time)
    ResetIRConditions();

}

void IrLearningDrv_getFormatCode(cIrLearningDrv* me)
{
    me->ir_keytime.format=DetermineCaptureFormat(me->decodeLen, me->IR_decode_buff);
    me->ir_keytime.code=QuantifyCapturedCode(me->IR_decode_buff, me->decodeLen, me->ir_keytime.format);

}


static void TimerCheckIR(cIrLearningDrv* me)
{
    uint32 iCaptureCode;
    IR_FORMAT iCaptureFormat=IR_FORMAT_NG;

    IR.repeat_count++;
    IR.Ir2ms5Cnt++;
    IR.TimeGapCnt++;
    if (IR.Ir2ms5Cnt>70)        // 20ms
    {
        // less than 3 package and timeout (no next package),
        if (IR.wait_next_package == 1)                     //150))            // this 300ms wait pending is necessary for  TIVO remote, fix issue: IN2923
        {
            if (me->gbBuff_IR_Len > MIN_NUMBER_OF_IR_BIT)
            {
                //TP_PRINTF("(b)\r\n");
                me->repHeader=3;
               // me->decodeLen = me->gbBuff_IR_Len;
                //memcpy(me->IR_decode_buff, me->IR_new_buff, sizeof(me->IR_new_buff));
                //iCaptureFormat=DetermineCaptureFormat(me->gbBuff_IR_Len,me->IR_new_buff);
                //me->ir_keytime.format = iCaptureFormat;
                //iCaptureCode=QuantifyCapturedCode(me->IR_new_buff, me->gbBuff_IR_Len, iCaptureFormat);
                //me->ir_keytime.code = iCaptureCode;

            }
            else
            {
                //TP_PRINTF("(c)\r\n");

                iCaptureFormat=DetermineCaptureFormat(me->gbBuff_Prev_IR_Len, me->IR_prev_buff);
                me->ir_keytime.format = iCaptureFormat;
                iCaptureCode=QuantifyCapturedCode(me->IR_prev_buff, me->gbBuff_Prev_IR_Len, iCaptureFormat);
                me->ir_keytime.code = iCaptureCode;
            }
            IR.wait_next_package = 0;
            // copy the last IR info to current IR info, execute IR_can_decode
            me->IR_can_decode=1;	//valid code received, start decode to a key
            me->IRDecodeState = BUTTON_PRESS;
            me->bValidIr =1;
            IR.Ir2ms5Cnt=0;
            IR.status = IR_IDLE;
            IR.repeat_count = 0;
            Set_edge_trigger(FALLING_EDGE);
            IR.Ir2ms5Cnt=0;
            IR.repeat_flag = 0;
            //TP_PRINTF("4)BP\r\n");
        }
        else if (IR.wait_next_package == 0)
        //else if ((IR.wait_next_package == 0)&&(IR.Ir2ms5Cnt>PENDING_TIME))           //150))           // this time limit also solve why cannot need to reach the 4th time during learning TIVO's VOL key, fix IN
        {
            IRreset();
            IR.Ir2ms5Cnt=0;
            me->IRDecodeState = BUTTON_RELEASE;
            IR.repeat_flag = 0;

            if (IR.TimeGapCnt_Enable == 1)
            {
                IR.TimeGapCnt = 0;
                IR.TimeGapCnt_Enable = 0;
            }

        }
    }
}





#ifndef IR_LEARNING
void IRDECODE_9148(cIrLearningDrv* me)
{
#ifndef _WINDOWS
	unsigned char i;

	IR_COM = 0;
	for (i = 1; i < 23; i +=2)
	{
		if (IRB_store[i] > 0x180 && IRB_store[i] < 0x390)
		{
			IR_COM |= 0x01;
			IR_COM <<= 1;
		}
		else if (IRB_store[i] > 0x602 && IRB_store[i] < 0x834)
		{
			IR_COM <<= 1;
		}
	}

	IR_COM >>= 1;
	me->COMMAND = IR_COM;
	IR_COM = 0;
	if(me->COMMAND)
		me->bValidIr = 1;
#endif
}
#endif

void CheckIRPress(void)
{
    cIrLearningDrv* me=pIrLearningDrvObj;
    if(me->IR_can_decode)
    {
#ifdef IR_LEARNING
            if ( me->repHeader)
            {
                IrLearningDrv_getFormatCode(me);
                me->previous_ir_keytime.code = me->ir_keytime.code;
                me->previous_ir_keytime.format = me->ir_keytime.format;
                TP_PRINTF("code=%d-0x%x repHeader=%d\r\n",me->ir_keytime.format, me->ir_keytime.code,me->repHeader);
                me->repHeader=0;
            }
            IR_decode_universal_code(me);
            //TP_PRINTF("CMD=%d\r\n",me->COMMAND);
#else
            IRDECODE_9148(me);
#endif
            me->IR_can_decode = 0;
    }
    if (me->IRDecodeState==BUTTON_RELEASE && me->bValidIr)
    {
        me->bValidIr=0;
        KeySrv_SendEvtToKeySrv(me->COMMAND, KEY_EVT_DOWN);
    }
    if (me->IRDecodeState==REPEATED_COMMAND && me->bValidIr)
    {
        me->bValidIr = 0;
        //TP_PRINTF("*");
        KeySrv_SendEvtToKeySrv(me->COMMAND, KEY_EVT_DOWN);
    }
}

bool GetKeyPressType(eKeyID* IRButton)
{
    uint8 uret;
    if(*IRButton == MUTE_KEY)
    {
        if (IR.TimeGapCnt > IR_KEY_TIME_GAP)
        {
            IR.TimeGapCnt_Enable = 1;

            //uIRToKeyPressed = MUTE_BUTTON;
            //bIRButtonMsg=WM_BUTTONUP;
            uret = BUTTON_RELEASE;
        }
        else
        {
            //bIRButtonMsg=WM_NO_KEY;
            uret = BUTTON_IDLE;				//added 27-02-2012
        }
    }
    if(*IRButton == VOLUME_DOWN_KEY)
    {
        //uIRToKeyPressed = VOLUME_DOWN;
        //bIRButtonMsg=WM_BUTTONDOWN;
        uret = WAIT_FOR_BUTTON_RELEASE;
    }
    else
    if(*IRButton == VOLUME_UP_KEY)
    {
        //uIRToKeyPressed = VOLUME_UP;
        //bIRButtonMsg=WM_BUTTONDOWN;
        uret = WAIT_FOR_BUTTON_RELEASE;
    }
    return uret;
}


void EXTI0_1_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET)
    {
        //IrLearningDrv_DecodeEdgeISR(pIrLearningDrvObj);
        IrLearningDrv_LearningEdgeISR(pIrLearningDrvObj);
        EXTI_ClearITPendingBit(EXTI_Line0);
        /* Clear the EXTI line 0 pending bit */
    }
}


void TIM3_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM3, TIM_IT_CC3) != RESET)
    {
        TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
        TimerCheckIR(pIrLearningDrvObj);
    }
}

void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
    }
}


void TIM1_CC_IRQHandler(void)
{
    if(TIM_GetITStatus(TIM3, TIM_IT_CC3) == SET) 
    {
        /* Clear TIM1 Capture compare interrupt pending bit */
        TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
        TIM_GetCapture3(TIM3);    

    }
}


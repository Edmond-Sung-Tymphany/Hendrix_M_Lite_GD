/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                   infared NEC format Driver
                  -------------------------

                  SW Module Document




@file        NecIrDrv.c
@brief       This file implements the infrared NEC format driver
@author      Edmond Sung, Bob.Xu
@date        2014-07-33
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-07-23     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include <p32xxxx.h>
#include "product.config" // All .c/.h files must include product.config
#include "tp_hwsetup.h"
#include "KeySrv.h"
#include "NecIrDrv_priv.h"
#include "IR.Config"

#include "trace.h"
#define RESET_VALUE         0

static void IrRxDrv_ClearState(void);
static void IrRxDrv_EdgeISR(void);
static void IrRxDrv_TimerConfig(void);
static void IrRxDrv_EXTIConfig(cIrRxDrv *me);
static void IrRxDrv_ResetReleaseCnt(void);

static tNecIrState necIrState;
static uint32 time2Tick = 0;
static eKeyState irKeyState[NUM_OF_IR_KEY] = {KEY_UP};
const tIrKeyIdMapCode * pLocalIrKeyIdMapeCode;

void IrRxDrv_Ctor(cIrRxDrv *me, const tIrKeyIdMapCode * pIrKeyIdMapeCode, const tGPIOPin *pIoConfig)
{
    if(!me->isCreated)
    {
        pLocalIrKeyIdMapeCode = pIrKeyIdMapeCode;
        /* Enable the Externer interrup to detect the pulse generated by IR */
        IrRxDrv_EXTIConfig(me);
        /* Configure two times to mesure the pulse width */
        IrRxDrv_TimerConfig();
        me->isCreated = TRUE;
    }
}
void IrRxDrv_Xtor(cIrRxDrv *me)
{
    /* TO DO */
//    TIM_Cmd(TIM2, DISABLE);
//    TIM_Cmd(TIM3, DISABLE);
}
/**
 * This function will initialize Timer4. It is used by the IR receiver routines.
 * It is 0.1ms interval timer.
 * @return  void
 */
void timer4_init(void)
{
    T4CON = 0x0060;                  /* stop timer, set up for 1:64 prescaler */
    TMR4 = 0;                        /* count from zero up to the period */
    PR4 = SYS_FREQ / (IR_TIMER4_TICKS_PER_SEC * 64);     /* set the Timer4 period */
    IPC4bits.T4IP = 4;               /* Timer4 interrupt priority, must match tickISR (_TIMER_4_VECTOR, IPL4) tickISR */
    IFS0CLR = _IFS0_T4IF_MASK;       /* clear Timer4 Interrupt Flag */
    IEC0SET = _IEC0_T4IE_MASK;       /* enable Timer4 interrupt */
    T4CONSET = _T4CON_ON_MASK;       /* Start Timer4 */
}
/**
 * This function will initialize Timer5. It is 2ms interval timer.
 *
 * @return  void
 */
void timer5_init(void)
{
    T5CON = 0x0060;                  /* stop timer, set up for 1:64 prescaler */
    TMR5 = 0;                        /* count from zero up to the period */
    PR5 = SYS_FREQ / (IR_TIMER5_TICKS_PER_SEC * 64);     /* set the Timer5 period */
    IPC5bits.T5IP = 4;               /* Timer5 interrupt priority, must match tickISR (_TIMER_5_VECTOR, IPL4) tickISR */
    IFS0CLR = _IFS0_T5IF_MASK;       /* clear Timer5 Interrupt Flag */
    IEC0SET = _IEC0_T5IE_MASK;       /* enable Timer5 interrupt */
    T5CONSET = _T5CON_ON_MASK;       /* Start Timer5 */
}

static void IrRxDrv_TimerConfig(void)
{
    timer4_init();
    timer5_init();
}

/**
  * @brief  Configure in interrupt mode
  * @param  None
  * @retval None
  */
static void IrRxDrv_EXTIConfig(cIrRxDrv *me)
{
    INTDisableInterrupts();
    PORTSetPinsDigitalIn(IOPORT_D, BIT_5);
    INTCONbits.INT1EP = 0; //Falling edge
    IPC1bits.INT1IP = 6;/* set INT1 priority; must match IPL in testISR */
    INT1Rbits.INT1R = 0x06; // set RD5 as the INT1
    IFS0CLR = _IFS0_INT1IF_MASK;/* clear the interrupt for INT1 */
    IEC0SET = _IEC0_INT1IE_MASK;/* enable INT1 interrupt */
    INTEnableInterrupts();
}

/**
 * @brief   This function should be run in every 2ms in order to check the IR key release
 * @return
 * @param
 */
static void IrRxDrv_ResetReleaseCnt()
{
    if (necIrState.releaseCountdown)
    {
        necIrState.releaseCountdown--;
        if (necIrState.releaseCountdown==0)
        {
            IrRxDrv_ClearState();
        }
    }
}

eKeyState IrRxDrv_ReadKeyState(cIrRxDrv *me, eKeyID keyID)
{
    uint8 i = 0;
    for( i = 0; i < NUM_OF_IR_KEY; i++)
    {
        if(keyID == pLocalIrKeyIdMapeCode[i].irKeyId)
        {
            return irKeyState[i];
        }
    }
    ASSERT(i != NUM_OF_IR_KEY);
    return KEY_INVALIDE_STATE;
}

void IrRxDrv_InterpretIrCode()
{
    if(necIrState.arrIndex >= IR_BITS_LENGTH)
    {
      /* Have got all the bits, now start decoding  */
      uint8 i = 0;
      for (i = 0;i < IR_BITS_LENGTH;i++)
      {
          /* check logic "0" */
          if((necIrState.irArr[i] <= IR_LOGIC_ZERO_UPPER_LIMIT) && \
            (necIrState.irArr[i] >= IR_LOGIC_ZERO_LOWER_LIMIT))
          {
              necIrState.command &=0xfffffffe;
          }
          /* check logic "1" */
          else if((necIrState.irArr[i] <= IR_LOGIC_ONE_UPPER_LIMIT) && \
            (necIrState.irArr[i] >= IR_LOGIC_ONE_LOWER_LIMIT))
          {
              necIrState.command |= 0X01;
          }
          else
          {
              return;
          }

          if (i+1<IR_BITS_LENGTH)
          {
              necIrState.command <<= 1;
          }
      }/* Decoding end */

      /* Decode done, if this is an IR key, a key done is sent first */
      for(i = 0; i < NUM_OF_IR_KEY; i++)
      {
         if(necIrState.command == pLocalIrKeyIdMapeCode[i].irCode)
         {
            irKeyState[i] = KEY_DOWN;
            break;
         }
         if(i == NUM_OF_IR_KEY)
         {
            ASSERT(0);
         }
      }
      necIrState.arrIndex       = 0;
      necIrState.irState = IR_STATE_IDLE;  //start to long press
    }
}

static void IrRxDrv_ClearState(void)
{
    necIrState.command        = 0;
    necIrState.irState        = IR_STATE_IDLE;
    necIrState.receivedKeyId  = INVALID_KEY;
    uint8 i = 0;
    for( i = 0; i < NUM_OF_IR_KEY; i++)
    {
        irKeyState[i] = KEY_UP;
    }
}

/**
  * @brief  This function handles External interrupt 1 request.
  * @param  None
  * @retval None
  */
void __ISR(_EXTERNAL_1_VECTOR, IPL6) ExtInt1ISR(void)
{
    IFS0CLR = _IFS0_INT1IF_MASK;/*clear the interrupt source*/
    IEC0CLR = _IEC0_INT1IE_MASK;/*disable INT1 interrupt*/

    IrRxDrv_EdgeISR();

    IEC0SET = _IEC0_INT1IE_MASK;/* enable INT1 interrupt */
}

/**
  * @brief  This function handles Timer4 interrupt request.
  * @param  None
  * @retval None
  */
void __ISR(_TIMER_4_VECTOR, IPL4) TR4ISR(void)
{
    time2Tick++;
    TIMER4_RESTART();
    TIMER4_RESET_INTF();
    TIMER4_ENABLE_INT();
}

void __ISR(_TIMER_5_VECTOR, IPL4) TR5ISR(void)
{   
    TIMER5_RESTART();
    TIMER5_RESET_INTF();
    TIMER5_ENABLE_INT();
    IrRxDrv_ResetReleaseCnt();
}


static void IrRxDrv_EdgeISR(void)
{
  necIrState.releaseCountdown = IR_KEY_RELEASE_COUNTDOWN_TIME_120MS;
  if(necIrState.irState == IR_STATE_IDLE)
    {
        time2Tick = RESET_VALUE;
        necIrState.irState  = IR_IN_PROGRESS;
        necIrState.arrIndex = 0;
        necIrState.g_TimerCount = RESET_VALUE;
    }
    else
    {
        necIrState.g_TimerCount = time2Tick;
        if(necIrState.irState == IR_IN_PROGRESS)
        {
            if((necIrState.g_TimerCount > IR_HEAD_CODE_LOWER_LIMIT && \
              necIrState.g_TimerCount < IR_HEAD_CODE_UPPER_LIMIT))
            {
              uint8 i = 0;
              for( i = 0; i < NUM_OF_IR_KEY; i++)
              {
                  irKeyState[i] = KEY_UP;
              }
              time2Tick = RESET_VALUE;
              necIrState.g_TimerCount = RESET_VALUE;
              return;
            }
            /* check IR long press, PP remote */
            else if(necIrState.g_TimerCount > IR_REPEAT_CODE_LOWER_LIMIT && \
              necIrState.g_TimerCount < IR_REPEAT_CODE_UPPER_LIMIT)
            {
                necIrState.irState = IR_STATE_IDLE;
                return;
            }
            else if(necIrState.g_TimerCount > IR_KEY_RELEASE_COUNTDOWN_TIME_120MS)
            {
                IrRxDrv_ClearState();
            }
        }
        necIrState.irArr[necIrState.arrIndex] = necIrState.g_TimerCount;
        /* save the timer counter for decoding */
        if(necIrState.arrIndex > IR_BITS_LENGTH)
        {
            necIrState.releaseCountdown = 0;
            necIrState.arrIndex       = 0;
            necIrState.irState = IR_STATE_IDLE;  //start to long press
            return;
        }
        necIrState.arrIndex++;
    }
    necIrState.g_TimerCount = RESET_VALUE;
    time2Tick = RESET_VALUE;
}
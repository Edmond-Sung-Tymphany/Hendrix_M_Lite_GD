/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver (Rotary Encoder type)
                  -------------------------

                  SW Module Document




@file        RotaterKeyDrv.c
@brief       The key driver (Rotater type) interfaces and implementation
@author      Wesley.Lee
@date        2016-05-13
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2016-01-15    
Jimmy.Zhong
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "EncoderKeyDrv.h"
#include "GpioDrv.h"
#include "trace.h"
#include "KeySrv.h"
#ifdef ENCODER_KEY_CODE_RAMAPPING
#include "encoderKey.config"
#endif

/* local functions */
static void EncoderKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static int32 EncoderKeyDrv_ReadRawValue(cKeyDrv *me);

static bool getDeviceStatusByIndex(cEncoderKeyDrv *pEncoderKeyDrv, uint8 index);
static uint8 getMaxDeviceId(cEncoderKeyDrv *pEncoderKeyDrv);

void EncoderKeyDrv_Ctor(cEncoderKeyDrv *me, const tGpioEncoderKeyDevice *pConfig)
{
    ASSERT(me && pConfig);

    cGpioDrv *pGpioDrv = &me->gpioDrv;
    cKeyDrv  *pKeyDrv = (cKeyDrv*)me;

    me->pKeyboardConfig = pConfig;

    if(!pGpioDrv->isCreated)
    {
        GpioDrv_Ctor(pGpioDrv, pConfig->attachedDeviceObjConfig);
    }

    me->position = 0;

    pKeyDrv->KeyGetRawDataCb = EncoderKeyDrv_ReadRawValue;
    pKeyDrv->KeyStartScanCb = NULL;
    pKeyDrv->KeyUpdateStatusCb = EncoderKeyDrv_UpdateKeyStatus;
    pKeyDrv->keySimulationState = KEY_INVALIDE_STATE;
    pKeyDrv->keyState = KEY_UP;
    pKeyDrv->isCreated = TRUE;
}

void EncoderKeyDrv_Xtor(cEncoderKeyDrv *me)
{
    ASSERT(me && me->gpioDrv.isCreated);
    GpioDrv_Xtor(&me->gpioDrv);
}

/**
* local function to interpret the GPIO value
* @param[in]    me                         the Key object
*/
static void EncoderKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    ASSERT(me);

    static uint8 keyCode = 0;
    static uint8 keyCode_bak = 0;
    static bool data = FALSE;
    uint8 i;
    
    keyCode = 0;
    cEncoderKeyDrv *pEncoderKey = (cEncoderKeyDrv*) me;
    for (i =  0; i < getMaxDeviceId(pEncoderKey); i ++)
    {
      data = getDeviceStatusByIndex(pEncoderKey,i);
      keyCode = ((keyCode << 1) | data);
      data = FALSE;
    }

    if (!keyCode_bak || (keyCode_bak != keyCode))
    {
        keyCode_bak = keyCode;
        KeyStateEvt *pte = Q_NEW(KeyStateEvt, KEY_STATE_SIG);
        pte->keyId = VOL_UP_DOWN_KEY;
        pte->keyEvent = KEY_EVT_SHORT_PRESS;
#ifdef ENCODER_KEY_CODE_RAMAPPING
        for (i = 0;i < sizeof(encoderKeyMapping); i ++)
        {
            if (encoderKeyMapping[i] == keyCode)
            {
                pte->index = i;
                break;
            }
        }
#else
        pte->index = 0;
#endif
#ifdef HAS_DEBUG
        pte->adcRawValue = adcValue;
#endif
        QF_PUBLISH(&pte->super, 0);
    }
    
}

/**
* Sequence Event object constructor
* @param[in]    me      Key Driver object
* @return       position updated within last scanning interval
*/
static int32 EncoderKeyDrv_ReadRawValue(cKeyDrv *me)
{
    ASSERT(me);

    cEncoderKeyDrv *pEncoderKey = (cEncoderKeyDrv*) me;
    int32 rtnValue  = pEncoderKey->lastState | (pEncoderKey->tranState << 2);
    return rtnValue;
}

static bool getDeviceStatusByIndex(cEncoderKeyDrv *pEncoderKeyDrv, uint8 index)
{
    return (bool)(GpioDrv_ReadBit(&pEncoderKeyDrv->gpioDrv, pEncoderKeyDrv->pKeyboardConfig->attachedDeviceObjConfig->pGPIOPinSet[index].gpioId));
}

static uint8 getMaxDeviceId(cEncoderKeyDrv *pEncoderKeyDrv)
{
    return (pEncoderKeyDrv->pKeyboardConfig->attachedDeviceObjConfig->usedGPIOPinNum);
}

/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver(GPIO type)
                  -------------------------

                  SW Module Document




@file        GpioKeyDrv.c
@brief       The key driver(GPIO type) interfaces and implementation 
@author      Bob.Xu 
@date        2014-03-19
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-03-19     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "GpioKeyDrv.h"
#include "GpioDrv.h"
#include "trace.h"

/* local functions */
static void GpioKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static int32 GpioKeyDrv_ReadRawValue(cKeyDrv *me);


/**
* Key Driver(GPIO type) object constructor
* @param[in]    me              the Key Driver object
* @param[in]    pConfig         configuration of the Key instance
* @param[in]    keyID           the keyID
*/
void GpioKeyDrv_Ctor(cGpioKeyDrv *me, const tGpioKeyboardDevice *pGpioKeyboardConfig, eKeyID keyID)
{
    {
        /* check parameters */
        ASSERT(me && pGpioKeyboardConfig && (keyID < NORMAL_KEY_ID_MAX));
    }
        cGpioDrv *pGpioDrvObj;
        pGpioDrvObj = (cGpioDrv*)(pGpioKeyboardConfig->attachedDeviceObj);
        if( FALSE == (pGpioDrvObj->isCreated))
        {
            /**
             * several keys share the same GPIO obj, we check if GPIO obj
             * has been created, if yes, simply ignore this statement
             */
             GpioDrv_Ctor(pGpioDrvObj,pGpioKeyboardConfig->attachedDeviceObjConfig);
        }
        me->pKeyboardConfig = pGpioKeyboardConfig;
        me->super_.KeyGetRawDataCb = GpioKeyDrv_ReadRawValue;
        me->super_.KeyStartScanCb = NULL;
        me->super_.KeyUpdateStatusCb = GpioKeyDrv_UpdateKeyStatus;
        me->super_.keySimulationState = KEY_INVALIDE_STATE;
        me->super_.keyState = KEY_UP;
        me->super_.keyID = keyID;
        me->super_.isCreated = TRUE;
}

/**
* Key Driver(GPIO type) object destructor
* @param[in]    me              the Key Driver object
* @param[in]    keyID           Id of the key
*/
void GpioKeyDrv_Xtor(cGpioKeyDrv *me)
{
    ASSERT(me);
    me->super_.KeyGetRawDataCb = NULL;
    me->super_.KeyStartScanCb = NULL;
    me->super_.KeyUpdateStatusCb = NULL;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_INVALIDE_STATE;
    me->super_.keyID = INVALID_KEY;
    me->super_.isCreated = FALSE;
    cGpioDrv *pGpioDrvObj;
    pGpioDrvObj = (cGpioDrv*)(me->pKeyboardConfig->attachedDeviceObj);
    if(TRUE == pGpioDrvObj->isCreated)
    {
        GpioDrv_Xtor(pGpioDrvObj);
        /*
        * The system goes to a state which has no GPIO key object
        * Enable GPIO key interrupt to handler the key event
        */
        GpioDrv_EnableIntOfWakeUpKeyPin();
    }
    me->pKeyboardConfig = NULL;
}

/**
* local function to interpret the GPIO value
* @param[in]    me                         the Key object
*/
static void GpioKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    uint8 i;
    int8 gpioValue;
    cGpioDrv *pGpioDrvForKey;
    cGpioKeyDrv *pGpioKeyObj;
    pGpioKeyObj = (cGpioKeyDrv*)me;
    const tGPIODevice *gpioDrvConfigForKey;
    gpioDrvConfigForKey = pGpioKeyObj->pKeyboardConfig->attachedDeviceObjConfig;
    pGpioDrvForKey = pGpioKeyObj->pKeyboardConfig->attachedDeviceObj;
    for(i = 0; i < (pGpioKeyObj->pKeyboardConfig->gpioKeyboard.keyNum); i++)
    {
        if((pGpioKeyObj->super_.keyID) == (pGpioKeyObj->pKeyboardConfig->pGpioKeySet[i].keyId))
        {
            gpioValue = GpioDrv_ReadBit(pGpioDrvForKey,pGpioKeyObj->pKeyboardConfig->pGpioKeySet[i].gpioId);

            if(gpioDrvConfigForKey->pGPIOPinSet[i].gpioInitAttr == GPIO_ACTIVE_LOW )
            {
                if (gpioValue)
                {
                    me->keyState = KEY_UP;
                }
                else
                {
                    me->keyState = KEY_DOWN;
                }
            }
            else if(gpioDrvConfigForKey->pGPIOPinSet[i].gpioInitAttr == GPIO_ACTIVE_HIGH )
            {
                if(gpioValue)
                {
                     me->keyState = KEY_DOWN;
                }
                else
                {
                     me->keyState = KEY_UP;
                }
            }
            return;
        }
    }
}

/**
* local function to interpret the ADC value
* @param[in]    me                         the Key object
*/
static int32 GpioKeyDrv_ReadRawValue(cKeyDrv *me)
{
    cGpioKeyDrv *pGpioKeyObj    = (cGpioKeyDrv*)me;
    cGpioDrv *pGpioDrvObjForKey = pGpioKeyObj->pKeyboardConfig->attachedDeviceObj;
    int8 rtnValue               = TP_ACCESS_ERROR;
    uint8 i;
    for(i = 0; i < (pGpioKeyObj->pKeyboardConfig->gpioKeyboard.keyNum); i++)
    {
        if((me->keyID) == (pGpioKeyObj->pKeyboardConfig->pGpioKeySet[i].keyId))
        {
            rtnValue = GpioDrv_ReadBit(pGpioDrvObjForKey, \
                    pGpioKeyObj->pKeyboardConfig->pGpioKeySet[i].gpioId);
            break;
        }
    }
    return rtnValue;
}

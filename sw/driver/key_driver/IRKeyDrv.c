/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver(infrared type)
                  -------------------------

                  SW Module Document




@file        IRKeyDrv.c
@brief       The key driver(Infrared type) interfaces and implementation 
@author      Bob.Xu 
@date        2015-09-10
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-09-10     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "IrRxDrv.h"
#include "IRKeyDrv.h"
#include "trace.h"

/* local functions */
static void IRKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static void IRKeyDrv_InterpretIrCode(cKeyDrv *me);

/**
* Key Driver(Infrared type) object constructor
* @param[in]    me              the Key Driver object
* @param[in]    pConfig         configuration of the Key instance
* @param[in]    keyID           the keyID
*/
void IRKeyDrv_Ctor(cIRKeyDrv *me, const tIRKeyboardDevice *pIRKeyboardConfig, eKeyID keyID)
{
    {
        /* check parameters */
        ASSERT(me && pIRKeyboardConfig && (keyID < NORMAL_KEY_ID_MAX));
    }
        cIrRxDrv *pIrRxDrvObj;
        pIrRxDrvObj = (cIrRxDrv*)(pIRKeyboardConfig->attachedDeviceObj);
        if( FALSE == (pIrRxDrvObj->isCreated))
        {
            /**
             * several keys share the same IR obj, we check if IR obj
             * has been created, if yes, simply ignore this statement
             */
             IrRxDrv_Ctor(pIrRxDrvObj,pIRKeyboardConfig->keyIdIrCodeMap,&(pIRKeyboardConfig->ioAttr));
        }
        me->pKeyboardConfig = pIRKeyboardConfig;
        me->super_.KeyGetRawDataCb = NULL;
        me->super_.KeyStartScanCb = IRKeyDrv_InterpretIrCode;
        me->super_.KeyUpdateStatusCb = IRKeyDrv_UpdateKeyStatus;
        me->super_.keySimulationState = KEY_INVALIDE_STATE;
        me->super_.keyState = KEY_UP;
        me->super_.keyID = keyID;
        me->super_.isCreated = TRUE;
}

/**
* Key Driver(IR type) object destructor
* @param[in]    me              the Key Driver object
* @param[in]    keyID           Id of the key
*/
void IRKeyDrv_Xtor(cIRKeyDrv *me)
{
    ASSERT(me);
    me->super_.KeyGetRawDataCb = NULL;
    me->super_.KeyStartScanCb = NULL;
    me->super_.KeyUpdateStatusCb = NULL;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_INVALIDE_STATE;
    me->super_.keyID = INVALID_KEY;
    me->super_.isCreated = FALSE;
    cIrRxDrv *pIRDrvObj;
    pIRDrvObj = (cIrRxDrv*)(me->pKeyboardConfig->attachedDeviceObj);
    if(TRUE == pIRDrvObj->isCreated)
    {
        IrRxDrv_Xtor(pIRDrvObj);
    }
    me->pKeyboardConfig = NULL;
}

/**
* local function to interpret the IR status
* @param[in]    me                         the Key object
*/
static void IRKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    uint8 i;
    cIrRxDrv *pIRDrvForKey;
    cIRKeyDrv *pIRKeyObj;
    pIRKeyObj = (cIRKeyDrv*)me;
    pIRDrvForKey = (cIrRxDrv *)(pIRKeyObj->pKeyboardConfig->attachedDeviceObj);
    for(i = 0; i < (pIRKeyObj->pKeyboardConfig->irKeyboard.keyNum); i++)
    {
        if((pIRKeyObj->super_.keyID) == pIRKeyObj->pKeyboardConfig->keyIdIrCodeMap[i].irKeyId)
        {
            me->keyState = IrRxDrv_ReadKeyState(pIRDrvForKey,pIRKeyObj->super_.keyID);
            return;
        }
    }
}

/**
* local function to interpret the IR status
* @param[in]    me                         the Key object
*/
static void IRKeyDrv_InterpretIrCode(cKeyDrv *me)
{
//    (void*)me;  // to supress compiler warning
    IrRxDrv_InterpretIrCode();
}
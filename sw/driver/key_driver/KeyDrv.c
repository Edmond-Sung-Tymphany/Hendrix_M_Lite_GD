/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver
                  -------------------------

                  SW Module Document




@file        KeyDrv.c
@brief       The key driver interfaces and implementation 
@author      Bob.Xu 
@date        2014-02-13
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-02-13     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "./KeyDrv_priv.h"

#ifdef HAS_ADC_KEY
#include "AdcKeyDrv.h"
#endif

#ifdef HAS_KNOB_KEY
#include "KnobKeyDrv.h"
#endif

#ifdef GPIO_ENCODER_KEY
#include "EncoderKeyDrv.h"
#endif

#ifdef HAS_GPIO_KEY
#include "GpioKeyDrv.h"
#endif

#ifdef HAS_INFRARED_KEY
#include "IRKeyDrv.h"
#endif

#ifdef HAS_LINEAR_ADC_KNOB_KEY
#include "LinearKnobKeyDrv.h"
#endif

#ifdef HAS_AZOTEQ_INTEG_TOUCHKEY_DRV
#ifdef HAS_AZOTEQ_PRIV
#include "AzIntegTouchKeyDrv_priv.h"
#else
#include "AzIntegTouchKeyDrv.h"
#endif
#endif

#ifdef HAS_ROTATER_KEY
#include "RotaterKeyDrv.h"
#endif

#ifdef HAS_TI_INTEG_TOUCHKEY_DRV
#include "Ldc2114.h"
#endif

#ifdef HAS_BMI160_TILT_SENSOR_KEY
#include "Bmi160KeyDrv.h"
#endif

#ifdef HAS_PROXIMITY_KEY
#include "Pga460KeyDrv.h"
#endif

#include "trace.h"
/**
* Key Driver object constructor, if passing a key array, this construcotr
* will create all the key object of the array
* @param[in]    me              the Key Driver object
* @param[in]    pConfig         configuration of the Key instance
* @param[in]    keyID           the keyID
*/
void KeyDrv_Ctor(cKeyDrv *me, const tKeyboardDevice *pKeyboardConfig,void *pKeyboardAttachedObj)
{
    {
        /* check user's config */
        ASSERT(me && pKeyboardConfig);
    }

    switch(pKeyboardConfig->deviceInfo.deviceType)
    {
#ifdef HAS_PROXIMITY_KEY
        case PROXIMITY_SENSOR_DEV_TYPE:
        {
            uint8 i;
            cPga460KeyDrv *pPga460KeyObj = (cPga460KeyDrv*)me;
            tPga460KeyDevice *pPga460KeyboardConfig = (tPga460KeyDevice*)pKeyboardConfig;
            for(i = 0; i < pPga460KeyboardConfig->proximityKeyboard.keyNum; i++)
            {
                Pga460KeyDrv_Ctor(pPga460KeyObj, pPga460KeyboardConfig);
                pPga460KeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_ADC_KEY
        case ADC_DEV_TYPE:
        {
            uint8 i;
            ASSERT(pKeyboardAttachedObj);
            cAdcKeyDrv *pAdcKeyObj = (cAdcKeyDrv*)me;
            tAdcKeyboardDevice *pAdcKeyboardConfig = (tAdcKeyboardDevice*)pKeyboardConfig;
            pAdcKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
            for(i = 0; i < pAdcKeyboardConfig->adcKeyboard.keyNum; i++)
            {
                AdcKeyDrv_Ctor(pAdcKeyObj,pAdcKeyboardConfig,pAdcKeyboardConfig->pAdcKeySet[i].keyId);
                pAdcKeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_GPIO_KEY
        case GPIO_DEV_TYPE:
        {
            uint8 i;
            ASSERT(pKeyboardAttachedObj);
            cGpioKeyDrv *pGpioKeyObj = (cGpioKeyDrv*)me;
            tGpioKeyboardDevice *pGpioKeyboardConfig = (tGpioKeyboardDevice*)pKeyboardConfig;
            pGpioKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
            for(i = 0; i < pGpioKeyboardConfig->gpioKeyboard.keyNum; i++)
            {
                GpioKeyDrv_Ctor(pGpioKeyObj,pGpioKeyboardConfig,pGpioKeyboardConfig->pGpioKeySet[i].keyId);
                pGpioKeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_TOUCH_KEY
        case TI_TOUCH_KEY_DEV_TYPE:
        {
            uint8 ii;
            cLdc2114TouchKeyDrv *pTouchKeyObj = (cLdc2114TouchKeyDrv*)me;
            tTouchKeyboardDevice *pTouchKeyboardConfig = (tTouchKeyboardDevice*)pKeyboardConfig;
            for(ii = 0; ii < pTouchKeyboardConfig->TiTouchKeyboard.keyNum; ii++)
            {
                Ldc2114TouchKeyDrv_Ctor(pTouchKeyObj, pTouchKeyboardConfig, pTouchKeyboardConfig->pTiTouch[ii].keyId, pTouchKeyboardConfig->pTiTouch[ii].seqNo, pTouchKeyboardConfig->pTiTouch[ii].gainSettId);
                pTouchKeyObj++;
            }
            break;
        }

#endif
#ifdef HAS_KNOB_KEY
        case KNOB_DEV_TYPE:
        {
            uint8 i;
            ASSERT(pKeyboardAttachedObj);
            cKnobKeyDrv *pKnobKeyObj = (cKnobKeyDrv*)me;
            tKnobKeyboardDevice *pKnobKeyboardConfig = (tKnobKeyboardDevice*)pKeyboardConfig;
            pKnobKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
            for(i = 0; i < pKnobKeyboardConfig->knobKeyboard.keyNum; i++)
            {
                KnobKeyDrv_Ctor(pKnobKeyObj,pKnobKeyboardConfig,pKnobKeyboardConfig->pKnobKeySet[i].keyId);
                pKnobKeyObj++;
            }
            break;
        }
#endif

#ifdef GPIO_ENCODER_KEY
        case GPIO_ENCODER_DEV_TYPE:
            {
                uint8 i;
                ASSERT(pKeyboardAttachedObj);
                cEncoderKeyDrv *pEncoderKeyObj = (cEncoderKeyDrv*)me;
                tGpioEncoderKeyDevice *pEncoderKeyboardConfig = (tGpioEncoderKeyDevice*)pKeyboardConfig;
                pEncoderKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
                for(i = 0; i < pEncoderKeyboardConfig->encoderKeyboard.keyNum; i++)
                {
                    EncoderKeyDrv_Ctor(pEncoderKeyObj,pEncoderKeyboardConfig);
                    pEncoderKeyObj++;
                }
            }
          break;
#endif
        case IO_EXPANDER_DEV_TYPE:
            /* need to be upgraded later */
            break;
        case KEY_MATRIX_DEV_TYPE:
            /* need to be upgraded later */
            break;
#ifdef HAS_INFRARED_KEY
        case INFRARED_DEV_TYPE:
            {
            uint8 i;
            ASSERT(pKeyboardAttachedObj);
            cIRKeyDrv *pIRKeyObj = (cIRKeyDrv*)me;
            tIRKeyboardDevice *pIRKeyboardConfig = (tIRKeyboardDevice*)pKeyboardConfig;
            pIRKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
            for(i = 0; i < pIRKeyboardConfig->irKeyboard.keyNum; i++)
            {
                IRKeyDrv_Ctor(pIRKeyObj, pIRKeyboardConfig, pIRKeyboardConfig->keyIdIrCodeMap[i].irKeyId);
                pIRKeyObj++;
            }
            break;
            }

#endif
#ifdef HAS_LINEAR_ADC_KNOB_KEY
        case LINEAR_KNOB_DEV_TYPE:
        {
            uint8 i;
            ASSERT(pKeyboardAttachedObj);
            cLinearKnobKeyDrv *pKnobKeyObj = (cLinearKnobKeyDrv*)me;
            tLinearKnobKeyDevice *pKnobKeyboardConfig = (tLinearKnobKeyDevice*)pKeyboardConfig;
            pKnobKeyboardConfig->attachedDeviceObj = pKeyboardAttachedObj;
            for(i = 0; i < pKnobKeyboardConfig->linearKnobKeyboard.keyNum; i++)
            {
                LinearKnobKeyDrv_Ctor(pKnobKeyObj,pKnobKeyboardConfig,pKnobKeyboardConfig->pLinearKnobKeySet[i].keyId);
                pKnobKeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_AZOTEQ_INTEG_TOUCHKEY_DRV
        case AZ_INTEG_TOUCH_KEY_DEV_TYPE:
        {
            ASSERT(pKeyboardAttachedObj==NULL); //Azeteq Intergrate Touch driver do not need pKeyboardAttachedObj, should be NULL
            cAzIntegTouchKeyDrv *pTouchKeyObj = (cAzIntegTouchKeyDrv*)me;
            tAzIntegTouchKeyboardDevice *pTouchKeyboardConfig = (tAzIntegTouchKeyboardDevice*)pKeyboardConfig;
            ASSERT(pTouchKeyboardConfig->touchKeyboard.keyNum==1); 
            AzIntegTouchKeyDrv_Ctor(pTouchKeyObj, pTouchKeyboardConfig);            
            break;
        }
#endif
#ifdef HAS_ROTATER_KEY
        case ROTATER_DEV_TYPE:
        {
            cRotaterKeyDrv          *pKeyObj    = (cRotaterKeyDrv*)me;
            tRotaterKeyboardDevice  *pKbConfig  = (tRotaterKeyboardDevice*)pKeyboardConfig;
            RotaterKeyDrv_Ctor(pKeyObj, pKbConfig);
            break;
        }
#endif
#ifdef HAS_BMI160_TILT_SENSOR_KEY
        case TILT_SENSOR_DEV_TYPE:
        {
            ASSERT(pKeyboardAttachedObj==NULL); //Intergrate sensor driver do not need pKeyboardAttachedObj, should be NULL
            uint8 i;
            cBmi160KeyDrv * pBmi160KeyObj = (cBmi160KeyDrv *)me;
            tBmi160KeyboardDevice * pBmi160KeyboardConfig = (tBmi160KeyboardDevice*)pKeyboardConfig;

            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqStartCb = Bmi160Keyboard_InitStart;
            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqProcessCb = Bmi160Keyboard_InitProcess;
            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqDoneCb = Bmi160Keyboard_InitDone;
            ASSERT(pBmi160KeyboardConfig->bmi160Keyboard.keyNum == 1);
            Bmi160KeyDrv_Ctor(pBmi160KeyObj, pBmi160KeyboardConfig);
            break;
        }
#endif
        default:
            break;
    }
}

/**
* Key Driver object destructor
* @param[in]    me              the Key Driver object
*/
void KeyDrv_Xtor(cKeyDrv *me,const tKeyboardDevice *pKeyboardConfig)
{
    ASSERT(me);
    me->isCreated = FALSE;
    me->keyID = INVALID_KEY;
    switch(pKeyboardConfig->deviceInfo.deviceType)
    {
#ifdef HAS_PROXIMITY_KEY
        case PROXIMITY_SENSOR_DEV_TYPE:
        {
            uint8 i;
            cPga460KeyDrv *pPga460KeyObj = (cPga460KeyDrv*)me;
            tPga460KeyDevice *pPga460KeyboardConfig = (tPga460KeyDevice*)pKeyboardConfig;
            for(i = 0; i < pPga460KeyboardConfig->proximityKeyboard.keyNum; i++)
            {
                Pga460KeyDrv_Xtor(pPga460KeyObj);
                pPga460KeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_ADC_KEY
        case ADC_DEV_TYPE:
        {
            uint8 i;
            cAdcKeyDrv *pAdcKeyObj = (cAdcKeyDrv*)me;
            tAdcKeyboardDevice *pAdcKeyboardConfig = (tAdcKeyboardDevice*)pKeyboardConfig;
            for(i = 0; i < pAdcKeyboardConfig->adcKeyboard.keyNum; i++)
            {
                AdcKeyDrv_Xtor(pAdcKeyObj);
                pAdcKeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_GPIO_KEY
        case GPIO_DEV_TYPE:
        {
            /* set GPIO to tri-state */
            uint8 i;
            cGpioKeyDrv *pGpioKeyObj = (cGpioKeyDrv*)me;
            tGpioKeyboardDevice *pGpioKeyboardConfig = (tGpioKeyboardDevice*)pKeyboardConfig;;
            for(i = 0; i < pGpioKeyboardConfig->gpioKeyboard.keyNum; i++)
            {
                GpioKeyDrv_Xtor(pGpioKeyObj);
                pGpioKeyObj++;
            }
            break;
        }
#endif
#ifdef HAS_TOUCH_KEY
        case TI_TOUCH_KEY_DEV_TYPE:
        {
            uint8 ii;
            cLdc2114TouchKeyDrv *pTouchKeyObj = (cLdc2114TouchKeyDrv*)me;
            tTouchKeyboardDevice *pTouchKeyboardConfig = (tTouchKeyboardDevice*)pKeyboardConfig;
            for(ii = 0; ii < pTouchKeyboardConfig->TiTouchKeyboard.keyNum; ii++)
            {
                Ldc2114TouchKeyDrv_Xtor(pTouchKeyObj);
                pTouchKeyObj++;
            }
            break;
        }

#endif
#ifdef HAS_KNOB_KEY
        case KNOB_DEV_TYPE:
        {
            uint8 i;
            cKnobKeyDrv *pKnobKeyObj = (cKnobKeyDrv*)me;
            tKnobKeyboardDevice *pKnobKeyboardConfig = (tKnobKeyboardDevice*)pKeyboardConfig;
            for(i = 0; i < pKnobKeyboardConfig->knobKeyboard.keyNum; i++)
            {
                KnobKeyDrv_Xtor(pKnobKeyObj);
                pKnobKeyObj++;
            }
            break;
        }
#endif

#ifdef GPIO_ENCODER_KEY
        case GPIO_ENCODER_DEV_TYPE:
            {
                uint8 i;

                cEncoderKeyDrv *pEncoderKeyObj = (cEncoderKeyDrv*)me;
                tGpioEncoderKeyDevice *pEncoderKeyboardConfig = (tGpioEncoderKeyDevice*)pKeyboardConfig;

                for(i = 0; i < pEncoderKeyboardConfig->encoderKeyboard.keyNum; i++)
                {
                    EncoderKeyDrv_Xtor(pEncoderKeyObj);
                    pEncoderKeyObj++;
                }
            }
          break;
#endif

#ifdef HAS_AZOTEQ_INTEG_TOUCHKEY_DRV
        case AZ_INTEG_TOUCH_KEY_DEV_TYPE:
        {
            cAzIntegTouchKeyDrv *pTouchKeyObj = (cAzIntegTouchKeyDrv*)me;
            tAzIntegTouchKeyboardDevice *pTouchKeyboardConfig = (tAzIntegTouchKeyboardDevice*)pKeyboardConfig;
            ASSERT(pTouchKeyboardConfig->touchKeyboard.keyNum==1); 
            AzIntegTouchKeyDrv_Xtor(pTouchKeyObj);            
            break;
        }
#endif
#ifdef HAS_ROTATER_KEY
        case ROTATER_DEV_TYPE:
        {
            cRotaterKeyDrv      *pKeyObj    = (cRotaterKeyDrv*)me;
            RotaterKeyDrv_Xtor(pKeyObj);
            break;
        }
#endif
#ifdef HAS_BMI160_TILT_SENSOR_KEY
        case TILT_SENSOR_DEV_TYPE:
        {
            uint8 i;
            cBmi160KeyDrv *pBmi160KeyObj = (cBmi160KeyDrv *)me;
            tBmi160KeyboardDevice * pBmi160KeyboardConfig = (tBmi160KeyboardDevice*)pKeyboardConfig;

            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqDoneCb(pBmi160KeyboardConfig);

            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqStartCb = NULL;
            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqProcessCb = NULL;
            pBmi160KeyboardConfig->bmi160Keyboard.KeyboardInitSeqDoneCb = NULL;

            for(i = 0; i< pBmi160KeyboardConfig->bmi160Keyboard.keyNum; i++)
            {
                Bmi160KeyDrv_Xtor(pBmi160KeyObj);
                pBmi160KeyObj++;
            }
            break;
        }
#endif
        case IO_EXPANDER_DEV_TYPE:
            /* need to be upgraded later */
            break;
        case KEY_MATRIX_DEV_TYPE:
            /* need to be upgraded later */
            break;
        case INFRARED_DEV_TYPE:
            /* need to be upgraded later */
            break;
        default:
            break;
    }
}

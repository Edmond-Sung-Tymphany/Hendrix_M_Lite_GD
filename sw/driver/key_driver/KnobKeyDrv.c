/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver(adc type, adc value increase in a Wave form, not linear)
                  -------------------------

                  SW Module Document

@file        KnobKeyDrv.c
@brief       The knob key driver(adc type, adc value increase in a Wave form, not in linear)
			 interfaces and implementation.a knob in this case is an incremental rotary 
			 encoder with a circuitto change the three terminal phase output into a stepped
			 waveform (diagram(s) below). Constraints are that we need to sample fast
             enough not to miss any transition otherwise we could misinterpret
             a quick clockwise turn for a counterclockwise turn. The recommaned
             frequency is 200 Hz, higher frequency will increase the sensibility

            Wave form at knob input adc when the knob is rotated in anti-clockwise and clockwise
                    ----  |  ------ 
                    |     |        |
                    |     |        |
               ------     |        ------| 
               |          |              |
          -----|          |              |
          ------clockwise-|-anti-clockwise---------
@author      Daniel.Qin
@date        2015-03-04
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-03-04     Daniel Qin
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "KnobKeyDrv.h"
#include "AdcDrv.h"
#include "trace.h"
#include "KeySrv.h"

/* local functions */
static void KnobKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static int32 KnobKeyDrv_GetKeyRawValue(cKeyDrv *me);
static void KnobKeyDrv_StartScan(cKeyDrv *me);
static eKnobState KnobKeyDrv_GetKnobState (uint16 adc);
static void KnobKeyDrv_ProcessRotationDetect(cKnobKeyDrv *pKnobKeyObj,uint16 adcValue,uint8 i);

/**
* Key Driver(Knob type) object constructor
* @param[in]    me              the Key Driver(Knob type) object
* @param[in]    pConfig         configuration of the Key instance
* @param[in]    keyID           the keyID
*/
void KnobKeyDrv_Ctor(cKnobKeyDrv *me, const tKnobKeyboardDevice *pKnobKeyboardConfig, eKeyID keyID)
{
    {
        /* check parameters */
        ASSERT(me);
        ASSERT(pKnobKeyboardConfig);
        ASSERT((keyID < NORMAL_KEY_ID_MAX));
    }
        cADCDrv *pAdcDrvObj;
        pAdcDrvObj = (cADCDrv*)(pKnobKeyboardConfig->attachedDeviceObj);
        if( FALSE == (pAdcDrvObj->isCreated))
        {
            /**
             * several keys share the same adc obj, we check if adc obj
             * has been created, if yes, simply ignore this statement
             */
             ADCDrv_Ctor(pAdcDrvObj, pKnobKeyboardConfig->attachedDeviceObjConfig);
        }
        me->pKnobKeyboardConfig = pKnobKeyboardConfig;
        me->super_.KeyGetRawDataCb = KnobKeyDrv_GetKeyRawValue;
        me->super_.KeyStartScanCb = KnobKeyDrv_StartScan;
        me->super_.KeyUpdateStatusCb = KnobKeyDrv_UpdateKeyStatus;
        me->super_.keySimulationState = KEY_INVALIDE_STATE;
        me->super_.keyState = KEY_UP;
        me->super_.keyID = keyID;
        me->super_.isCreated = TRUE;
}

/**
* Key Driver object(adc type) destructor
* @param[in]    me              the Key Driver object
*/
void KnobKeyDrv_Xtor(cKnobKeyDrv *me)
{
    ASSERT(me);
    me->super_.KeyGetRawDataCb = NULL;
    me->super_.KeyStartScanCb = NULL;
    me->super_.KeyUpdateStatusCb = NULL;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_INVALIDE_STATE;
    me->super_.keyID = INVALID_KEY;
    me->super_.isCreated = FALSE;
    cADCDrv *pAdcDrvObj;
    pAdcDrvObj = (cADCDrv*)(me->pKnobKeyboardConfig->attachedDeviceObj);
    if(TRUE == pAdcDrvObj->isCreated)
    {
        ADCDrv_Xtor(pAdcDrvObj);
    }
    me->pKnobKeyboardConfig = NULL;
}

/**
* Read the Key(adc type) value
* @param[in]    me              the Key object
*/
static void KnobKeyDrv_StartScan(cKeyDrv *me)
{
    cKnobKeyDrv *adckeyObj;
    adckeyObj = (cKnobKeyDrv*)me;
    ADCDrv_StartScanning((cADCDrv*)(adckeyObj->pKnobKeyboardConfig->attachedDeviceObj));
}


/**
* local function to interpret the ADC value
* @param[in]    me                         the Key object
*/
static void KnobKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    int16 adcValue;
    eAdcPin adcPin;
    uint8 i;
    cADCDrv *pAdcObj;
    cKnobKeyDrv *pKnobKeyobj;
    pKnobKeyobj = (cKnobKeyDrv*)me;;
    for(i = 0; i < (pKnobKeyobj->pKnobKeyboardConfig->knobKeyboard.keyNum); i++)
    {
        if((pKnobKeyobj->super_.keyID) == (pKnobKeyobj->pKnobKeyboardConfig->pKnobKeySet[i].keyId))
        {
            adcPin = pKnobKeyobj->pKnobKeyboardConfig->pKnobKeySet[i].adcPin;
            pAdcObj = (cADCDrv*)pKnobKeyobj->pKnobKeyboardConfig->attachedDeviceObj;
            adcValue = ADCDrv_GetData(pAdcObj,adcPin);
            /* tranlate adc value */
            if(ADC_DATA_IS_NOT_READY == adcValue)
            {
                /* keep the same sate since conversioin is not done */
                return ;
            }
            KnobKeyDrv_ProcessRotationDetect(pKnobKeyobj, adcValue, i);
            break;
        }
    }
}

/**
* local function to read the adc raw data
* @param[in]    me                         the Key object
*/
static int32 KnobKeyDrv_GetKeyRawValue(cKeyDrv *me)
{
    int16 adcValue;
    eAdcPin adcPin;
    uint8 i;
    cADCDrv *pAdcObj;
    cKnobKeyDrv * pKnobKeyObj;
    pKnobKeyObj = (cKnobKeyDrv*)me;
    pAdcObj = (cADCDrv*)( pKnobKeyObj->pKnobKeyboardConfig->attachedDeviceObj);
    for(i = 0; i < (pKnobKeyObj->pKnobKeyboardConfig->knobKeyboard.keyNum); i++)
    {
        if((pKnobKeyObj->super_.keyID) == ( pKnobKeyObj->pKnobKeyboardConfig->pKnobKeySet[i].keyId))
        {
            adcPin =  pKnobKeyObj->pKnobKeyboardConfig->pKnobKeySet[i].adcPin;
            adcValue = ADCDrv_GetData(pAdcObj,adcPin);
            return adcValue;
        }
    }
    return TP_ACCESS_ERROR;
}

/**
 * @brief   This function identify the knob state bases on the
 *          input adc value
 * @return  knob_State_t : knob state
 * @param   adc : input adc value
 */
static eKnobState KnobKeyDrv_GetKnobState (uint16 adc)
{
    eKnobState retState = KNOB_STATE_LOW;
    if (adc >= ADC_KNOB_HIGH_TH)
    {
        retState = KNOB_STATE_HIGH;
    }
    else if (adc >= ADC_KNOB_MID_TH)
    {
        retState = KNOB_STATE_MID;
    }
    return retState;
}

static void KnobKeyDrv_ProcessRotationDetect(cKnobKeyDrv *pKnobKeyObj,uint16 adcValue, uint8 i)
{
    /* analyse for the latest knob state */
    eRotateStage releaseStage;
    eKnobState newKnobState = KnobKeyDrv_GetKnobState(adcValue);
    releaseStage = pKnobKeyObj->pKnobKeyboardConfig->pKnobKeySet[i].releaseStage;
    // this is the state machine to process the rotation of the knob
    if (newKnobState == KNOB_STATE_LOW)
    {
        pKnobKeyObj->currentStage = ROTATE_FORWARD_0;
    }
    else if(newKnobState == KNOB_STATE_MID && pKnobKeyObj->currentStage == ROTATE_FORWARD_0)
    {
        pKnobKeyObj->currentStage = ROTATE_FORWARD_1;
    }
    else if (newKnobState == KNOB_STATE_HIGH && pKnobKeyObj->currentStage == ROTATE_FORWARD_1)
    {
        pKnobKeyObj->currentStage = ROTATE_FORWARD_2;
    }
    else if (newKnobState == KNOB_STATE_HIGH && pKnobKeyObj->currentStage == ROTATE_FORWARD_0)
    {
        pKnobKeyObj->currentStage = ROTATE_BACKWARD_1;
    }
    else if (newKnobState == KNOB_STATE_MID && pKnobKeyObj->currentStage == ROTATE_BACKWARD_1)
    {
        pKnobKeyObj->currentStage = ROTATE_BACKWARD_2;
    }
    if(pKnobKeyObj->currentStage == releaseStage)
    {
        pKnobKeyObj->currentStage = ROTATE_BACKWARD_3;
        KeyStateEvt *pte = Q_NEW(KeyStateEvt, KEY_STATE_SIG);
        pte->keyId = pKnobKeyObj->super_.keyID;
        pte->keyEvent = KEY_EVT_SHORT_PRESS;
        QF_PUBLISH(&pte->super, 0);
    }
}
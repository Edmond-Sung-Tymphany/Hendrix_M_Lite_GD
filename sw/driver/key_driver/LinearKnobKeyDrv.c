/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver(adc type, adc value increase in linear)
                  -------------------------

                  SW Module Document

@file        LinearKnobKeyDrv.c
@brief       The knob key driver(adc type,adc value increase in linear) interfaces and implementation.
             a linear knob key has the feature of increase/decrease the adc value linearity when 
			 the use turn the key clockwise or anti-clockwise
             Adc Value at knob input adc when the knob is rotated in anti-clockwise and clockwise
			|--Adc miniValue.....................adcMaxValue--|
			<------------------------------------------------->
			|----------clockwise/anti-clockwise---------------|
@author      Bob.Xu
@date        2015-09-22
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-09-22    Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "LinearKnobKeyDrv.h"
#include "AdcDrv.h"
#include "trace.h"
#include "KeySrv.h"
#include "SettingSrv.h"

/* local definitions */
#define MULTIPLIER (1000) // helps to increase precision without introducing float types into calculations

/* set the special number to force to publish the powerup/startup index */
#define STARTUP_PRE_INDEX       111

/* local functions */
static void LinearKnobKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static int32 LinearKnobKeyDrv_GetKeyRawValue(cKeyDrv *me);
static void LinearKnobKeyDrv_StartScan(cKeyDrv *me);
static void LinearKnobKeyDrv_analyseKeyState(cLinearKnobKeyDrv *me, int16 adcValue, uint8 keyIndex);
/**
* Key Driver(Knob type) object constructor
* @param[in]    me              the Key Driver(Knob type) object
* @param[in]    pConfig         configuration of the Key instance
* @param[in]    keyID           the keyID
*/
void LinearKnobKeyDrv_Ctor(cLinearKnobKeyDrv *me, const tLinearKnobKeyDevice *pKeyConfig, eKeyID keyID)
{
    /* check parameters */
    ASSERT(me && pKeyConfig && (keyID < NORMAL_KEY_ID_MAX));
    cADCDrv *pAdcDrvObj;
    pAdcDrvObj = (cADCDrv*)(pKeyConfig->attachedDeviceObj);
    if( FALSE == (pAdcDrvObj->isCreated))
    {
        /**
         * several keys share the same adc obj, we check if adc obj
         * has been created, if yes, simply ignore this statement
         */
         ADCDrv_Ctor(pAdcDrvObj, pKeyConfig->attachedDeviceObjConfig);
    }
    me->pLinearKnobKeyConfig = pKeyConfig;
    me->super_.KeyGetRawDataCb = LinearKnobKeyDrv_GetKeyRawValue;
    me->super_.KeyStartScanCb = LinearKnobKeyDrv_StartScan;
    me->super_.KeyUpdateStatusCb = LinearKnobKeyDrv_UpdateKeyStatus;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_UP;
    me->super_.keyID = keyID;
    me->super_.isCreated = TRUE;
    me->preIndex = STARTUP_PRE_INDEX;
}

/**
* Key Driver object(adc type) destructor
* @param[in]    me              the Key Driver object
*/
void LinearKnobKeyDrv_Xtor(cLinearKnobKeyDrv *me)
{
    ASSERT(me);
    me->super_.KeyGetRawDataCb = NULL;
    me->super_.KeyStartScanCb = NULL;
    me->super_.KeyUpdateStatusCb = NULL;
    me->super_.keySimulationState = KEY_INVALIDE_STATE;
    me->super_.keyState = KEY_INVALIDE_STATE;
    me->super_.keyID = INVALID_KEY;
    me->super_.isCreated = FALSE;
    cADCDrv *pAdcDrvObj;
    pAdcDrvObj = (cADCDrv*)(me->pLinearKnobKeyConfig->attachedDeviceObj);
    if(TRUE == pAdcDrvObj->isCreated)
    {
        ADCDrv_Xtor(pAdcDrvObj);
    }
    me->pLinearKnobKeyConfig = NULL;
}

/**
* Read the Key(adc type) value
* @param[in]    me              the Key object
*/
static void LinearKnobKeyDrv_StartScan(cKeyDrv *me)
{
    cLinearKnobKeyDrv *adckeyObj;
    adckeyObj = (cLinearKnobKeyDrv*)me;
    ADCDrv_StartScanning((cADCDrv*)(adckeyObj->pLinearKnobKeyConfig->attachedDeviceObj));
}


/**
* local function to interpret the ADC value
* @param[in]    me                         the Key object
*/
static void LinearKnobKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    uint8 i;
    int16 adcValue;
    eAdcPin adcPin;
    cADCDrv *pAdcObj;
    cLinearKnobKeyDrv * pKeyObj;
    pKeyObj = (cLinearKnobKeyDrv*)me;
    pAdcObj = (cADCDrv*)( pKeyObj->pLinearKnobKeyConfig->attachedDeviceObj);
    for(i = 0; i < (pKeyObj->pLinearKnobKeyConfig->linearKnobKeyboard.keyNum); i++)
    {
        if((pKeyObj->super_.keyID) == (pKeyObj->pLinearKnobKeyConfig->pLinearKnobKeySet[i].keyId))
        {
            adcPin =  pKeyObj->pLinearKnobKeyConfig->pLinearKnobKeySet[i].adcPin;
            adcValue = ADCDrv_GetData(pAdcObj,adcPin);
            ASSERT(adcValue >= 0);
            LinearKnobKeyDrv_analyseKeyState(pKeyObj,adcValue,i);
            break;
        }
    }
    
}


static void LinearKnobKeyDrv_analyseKeyState(cLinearKnobKeyDrv *me, int16 adcValue, uint8 keyIndex)
{
     int16 slotAdcMinValue;/* This is the max value of a slot*/
     int16 slotAdcMaxValue;/* This is the min value of a slot*/
     uint16 adcMaxValue;   /* This is the max value of a adc pin */
     uint16 adcMinValue;   /* This is the min value of a adc pin */
     uint16 deltaBuffer;
     uint16 resolution;
     uint8 indexTemp;
     indexTemp = me->preIndex;
     if( indexTemp == STARTUP_PRE_INDEX )
        me->preIndex = 0;
     deltaBuffer = (me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].deltaBuffer);
     resolution = (me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].resolution);
     if(Setting_IsReady((eSettingId)me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].settIdOfAdcMax) && \
       Setting_IsIdValid((eSettingId)(me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].settIdOfAdcMax)))
     {
         adcMaxValue = *(int16*)Setting_Get((eSettingId)me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].settIdOfAdcMax);
         adcMinValue = *(int16*)Setting_Get((eSettingId)me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].settIdOfAdcMin);
     }
     else
     {
         adcMaxValue = me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].adcDefaultMaxValue;
         adcMinValue = me->pLinearKnobKeyConfig->pLinearKnobKeySet[keyIndex].adcDefaultMinValue;
     }
     
     /**
     *                            |<-deltBuf->|
     *  |                         |     |<----supose this is preIndex--->|                                  |
     *  |-----|-------------------|-----|-----|--------------------|-----|-----|----------------------|-----|
     *  |                               |                                |                                  |
     *  |                         ^     |                                |     ^                            |
     *adcMinValue         slotAdcMinValue                                slotAdcMaxValue               adcMaxValue
     */

     ASSERT(me->preIndex >= 0 && me->preIndex <= (resolution - 1));

     slotAdcMinValue = ((me->preIndex)       * ((MULTIPLIER * (adcMaxValue - adcMinValue)) / resolution) - ((MULTIPLIER * deltaBuffer) / 2)) / MULTIPLIER;
     slotAdcMaxValue = (((me->preIndex) + 1) * ((MULTIPLIER * (adcMaxValue - adcMinValue)) / resolution) + ((MULTIPLIER * deltaBuffer) / 2)) / MULTIPLIER;

     if (adcValue < slotAdcMinValue || adcValue > slotAdcMaxValue)
     {
         me->preIndex = (uint8)(MULTIPLIER * adcValue / ((MULTIPLIER * (adcMaxValue - adcMinValue))/resolution));
         me->preIndex = (me->preIndex >= resolution) ? (resolution - 1) : me->preIndex;
     }

     if(indexTemp != me->preIndex)
     {
        KeyStateEvt *pte = Q_NEW(KeyStateEvt, KEY_STATE_SIG);
        pte->keyId = me->super_.keyID;
        pte->keyEvent = KEY_EVT_SHORT_PRESS;
        pte->index = me->preIndex;
#ifdef HAS_DEBUG
        pte->adcRawValue = adcValue;
#endif
        QF_PUBLISH(&pte->super, 0);
     }
}

/**
* local function to read the adc raw data
* @param[in]    me                         the Key object
*/
static int32 LinearKnobKeyDrv_GetKeyRawValue(cKeyDrv *me)
{
    uint8 i;
    eAdcPin adcPin;
    cADCDrv *pAdcObj;
    cLinearKnobKeyDrv * pKeyObj;
    pKeyObj = (cLinearKnobKeyDrv*)me;
    pAdcObj = (cADCDrv*)( pKeyObj->pLinearKnobKeyConfig->attachedDeviceObj);
    for(i = 0; i < (pKeyObj->pLinearKnobKeyConfig->linearKnobKeyboard.keyNum); i++)
    {
        if((pKeyObj->super_.keyID) == (pKeyObj->pLinearKnobKeyConfig->pLinearKnobKeySet[i].keyId))
        {
            adcPin =  pKeyObj->pLinearKnobKeyConfig->pLinearKnobKeySet[i].adcPin;
            return (ADCDrv_GetData(pAdcObj,adcPin));
        }
    }
    return TP_ACCESS_ERROR;
}
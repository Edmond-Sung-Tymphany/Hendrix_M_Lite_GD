/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Key Driver (Rotary Encoder type)
                  -------------------------

                  SW Module Document




@file        RotaterKeyDrv.c
@brief       The key driver (Rotater type) interfaces and implementation
@author      Wesley.Lee
@date        2016-01-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2016-01-15     Wesley.Lee
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "RotaterKeyDrv.h"
#include "GpioDrv.h"
#include "trace.h"
#include "KeySrv.h"
#include "../key_server/KeySrv_priv.h"

/* local functions */
static void RotaterKeyDrv_UpdateKeyStatus(cKeyDrv *me);
static int32 RotaterKeyDrv_ReadRawValue(cKeyDrv *me);

/* local variable */

static void RotaterKeyDrv_gpioInit(cRotaterKeyDrv *me)
{
    cGpioDrv *pGpioDrv = &me->gpioDrv;
    eGPIOId encA = me->pKeyboardConfig->gpioConfig->pGPIOPinSet[ENC_PIN_A].gpioId;
    eGPIOId encB = me->pKeyboardConfig->gpioConfig->pGPIOPinSet[ENC_PIN_B].gpioId;
    uint8   s = 0;

    if ( GpioDrv_ReadBit(pGpioDrv, encA) )
    {
        TYM_SET_BIT(s, ROTATER_ENC_A_MASK);
    }
    if ( GpioDrv_ReadBit(pGpioDrv, encB) )
    {
        TYM_SET_BIT(s, ROTATER_ENC_B_MASK);
    }

    switch (s)
    {
    case 0:
    case 3:
        me->lastState = s;
        me->tranState = ROTATER_UNINIT;
        break;
    case 1:
    case 2:
        me->lastState = ROTATER_UNINIT;
        me->tranState = s;
        break;
    }
}

void RotaterKeyDrv_Ctor(cRotaterKeyDrv *me, const tRotaterKeyboardDevice *pConfig)
{
    ASSERT(me && pConfig);

    cGpioDrv *pGpioDrv = &me->gpioDrv;
    cKeyDrv  *pKeyDrv = (cKeyDrv*)me;

    me->pKeyboardConfig = pConfig;

    if(!pGpioDrv->isCreated)
    {
        GpioDrv_Ctor(pGpioDrv, pConfig->gpioConfig);
        RotaterKeyDrv_gpioInit(me);
    }

    me->position = 0;

    pKeyDrv->KeyGetRawDataCb = RotaterKeyDrv_ReadRawValue;
    pKeyDrv->KeyStartScanCb = NULL;
    pKeyDrv->KeyUpdateStatusCb = RotaterKeyDrv_UpdateKeyStatus;
    pKeyDrv->keySimulationState = KEY_INVALIDE_STATE;
    pKeyDrv->keyState = KEY_UP;
    pKeyDrv->keyID = pConfig->keyCw;    // not used
    pKeyDrv->isCreated = TRUE;
}

void RotaterKeyDrv_Xtor(cRotaterKeyDrv *me)
{
    ASSERT(me && me->gpioDrv.isCreated);
    GpioDrv_Xtor(&me->gpioDrv);
}

/**
* local function to interpret the GPIO value
* @param[in]    me                         the Key object
*/
static void RotaterKeyDrv_UpdateKeyStatus(cKeyDrv *me)
{
    ASSERT(me);

    cRotaterKeyDrv *pRotaterKey = (cRotaterKeyDrv*) me;
    cGpioDrv *pGpioDrv = &pRotaterKey->gpioDrv;
    eGPIOId encA = pRotaterKey->pKeyboardConfig->gpioConfig->pGPIOPinSet[ENC_PIN_A].gpioId;
    eGPIOId encB = pRotaterKey->pKeyboardConfig->gpioConfig->pGPIOPinSet[ENC_PIN_B].gpioId;
    uint8   s = 0;

    if ( GpioDrv_ReadBit(pGpioDrv, encA) )
    {
        TYM_SET_BIT(s, ROTATER_ENC_A_MASK);
    }
    if ( GpioDrv_ReadBit(pGpioDrv, encB) )
    {
        TYM_SET_BIT(s, ROTATER_ENC_B_MASK);
    }

    switch (s) {
    case 0:
        if(pRotaterKey->lastState == 0x03)
        {
            if(pRotaterKey->tranState == 0x01)
            {   // CW
                KeySrv_SendKeyEvt_Direct(KEY_EVT_SHORT_PRESS, pRotaterKey->pKeyboardConfig->keyCw);
            }
            else if (pRotaterKey->tranState == 0x02)
            {   // CCW
                KeySrv_SendKeyEvt_Direct(KEY_EVT_SHORT_PRESS, pRotaterKey->pKeyboardConfig->keyCcw);
            }
        }
        pRotaterKey->tranState = ROTATER_UNINIT;
        pRotaterKey->lastState = s;
        break;
    case 3:
        if(pRotaterKey->lastState == 0x00)
        {
            if(pRotaterKey->tranState == 0x01)
            {   // CCW
                KeySrv_SendKeyEvt_Direct(KEY_EVT_SHORT_PRESS, pRotaterKey->pKeyboardConfig->keyCcw);
            }
            else if (pRotaterKey->tranState == 0x02)
            {   // CW
                KeySrv_SendKeyEvt_Direct(KEY_EVT_SHORT_PRESS, pRotaterKey->pKeyboardConfig->keyCw);
            }
        }
        pRotaterKey->lastState = s;
        pRotaterKey->tranState = ROTATER_UNINIT;
        break;
    case 1:
    case 2:
        pRotaterKey->tranState = s; break;
    }
}

/**
* Sequence Event object constructor
* @param[in]    me      Key Driver object
* @return       position updated within last scanning interval
*/
static int32 RotaterKeyDrv_ReadRawValue(cKeyDrv *me)
{
    ASSERT(me);

    cRotaterKeyDrv *pRotaterKey = (cRotaterKeyDrv*) me;
    int32 rtnValue  = pRotaterKey->lastState | (pRotaterKey->tranState << 2);
    return rtnValue;
}


/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Power Driver
                  -------------------------

                  SW Module Document




@file        PowerDrv.c
@brief       It's the power driver for STM32F0xx, used in iHome
@author      Johnny Fan 
@date        2014-06-06
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-06     Johnny Fan 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
 */

#include "./PowerDrv_priv.h"
#include "trace.h"
#include "BluetoothDrv.h"

/*GPIO object*/
static cGpioDrv gpioDrv;
/* will remove the extern with getDeviceId function after the GPIO struct is changed*/

/****************************************************************************************/
/* use the variables below to save and resume register for power saving*/
static uint32* pPeripheralReg[]=
{
    (uint32*)&CNPUB,
    (uint32*)&CNPDB,
#if ((__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
    (uint32*)&TRISC,
    (uint32*)&TRISE,
    (uint32*)&TRISG,
    (uint32*)&CNPUC,
    (uint32*)&CNPDC,
#endif
};
static uint32 peripheralRegSave[ArraySize(pPeripheralReg)];
/**************************************************************************/

/****************************************************************************************/
/* will use GPIO driver and move below part to project config, it's for release usage first*/
//TODO: move the setting to attachdevices.c
typedef struct tMcuPin
{
    IoPortId portId;
    uint32 bits;
}tMcuPin;

const tMcuPin UN_USED_PINS[]=
{
    { IOPORT_B, BIT_11},
    { IOPORT_D, BIT_6},
    { IOPORT_D, BIT_7},
    { IOPORT_D, BIT_8},
    { IOPORT_E, BIT_3},
    { IOPORT_F, BIT_1},
    { IOPORT_G, BIT_9},
};
/**************************************************************************/


/* Private functions / variables. Declare and drivers here */
static tpowerUpSequence powerUpSequence[] =
{
    {&PowerDrv_PowerUpStage1, GET_TICKS_IN_MS(50)},
    {&PowerDrv_PowerUpStage2, GET_TICKS_IN_MS(50)},
    {&PowerDrv_PowerUpStage3, GET_TICKS_IN_MS(100)},
};

static QActive* pIntEvtRequestor = NULL;
static bool isIntEvtRequest = FALSE;

/* The ADC config is not in devices[], so can't use getDeviceId for now, use extern for quick test*/
cADCDrv adcDrv;

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void PowerDrv_Ctor(cPowerDrv *me) {
    /* Fill me in! */
    me->step = INITIAL_STEP;
#ifdef EXTERNAL_BATTERY
    me->ejectBatteryStep = INITIAL_STEP;
#endif

#ifdef HAS_ADC_FOR_POWER
    /* ADC for reading battery and AC input status */
    tADCDevice *pPowerAdcConf;
    pPowerAdcConf = (tADCDevice*)getDevicebyId(POWER_DEV_ID,NULL);
    ADCDrv_Ctor(&adcDrv, pPowerAdcConf);
    ADCDrv_StartScanning(&adcDrv);
#endif

#ifdef HAS_BATTERY
    PowerDrv_InitChargeStatusPin();
#endif
     /* initial the unsed pin to input*/
    PowerDrv_InitialUnusedPins();
}

void PowerDrv_Xtor(cPowerDrv *me) {
    /* Fill me in! */
    me->step = INITIAL_STEP;
#ifdef EXTERNAL_BATTERY
    me->ejectBatteryStep = INITIAL_STEP;
#endif
#ifdef HAS_ADC_FOR_POWER
    ADCDrv_Xtor(&adcDrv);
#endif
    PowerDrv_DeinitialPower(me);
#ifdef HAS_BATTERY
    PowerDrv_UnRegisterIntEvent();
#endif
}
/*****************************************************************************************************************
 *
 * Public interrupt handle function
 *
 *****************************************************************************************************************/
#ifdef HAS_BATTERY

void PowerDrv_HandleDcDetInterrupt() { /* send the event to power server */
    PowerDrv_PushIntEvtToServer(AC_IN_INTERRUPT_SIG);
    /* disable the interrupt request, unless power server turn it on again*/
    PowerDrv_UnRegisterIntEvent();
    TP_PRINTF("interrupt happen in driver layer\r\n");
}
#endif
/*
void EXTI0_1_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line1) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line1);
        PowerDrv_HandleExtBattDetInterrupt();
    }
}*/

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
uint16 PowerDrv_InitialPower(cPowerDrv *me) {
    /*need to change uint16 to int32, but keep it for now as it's used in other project*/
    uint16 delayTime;
    if (me->step < Q_DIM(powerUpSequence)) {
        /* call the power up function according to step*/
        powerUpSequence[me->step].powerUpFunction(me);
        /* get delay time*/
        delayTime = powerUpSequence[me->step].delaytime;
        me->step++;

    } else { /* if reset is completed, return 0 */
        delayTime = 0;
        me->step = 0;
    }
    return delayTime;
}

void PowerDrv_DeinitialPower(cPowerDrv *me)
{
    /*reset DSP*/
    PowerDrv_SetReset(ON_STATE);
    /*turn off external 3V3 voltage*/
    PowerDrv_SetPower(OFF_STATE);
}

#ifdef HAS_BATTERY
void PowerDrv_RegisterIntEvent(QActive* pRequestor) {
    pIntEvtRequestor = pRequestor;
    isIntEvtRequest = TRUE;
    PowerDrv_EnableAcDetInt();
}

void PowerDrv_UnRegisterIntEvent() {
    pIntEvtRequestor = NULL;
    isIntEvtRequest = FALSE;
    PowerDrv_DisableAcDetInt();
}

void PowerDrv_GetInputSourceState(cPowerDrv *me, tInputSourceState* inputSourceState)
{
    if (adcDrv.isCreated) {
        int16 acRawValue = (int16) ADCDrv_GetData(&adcDrv, adcDrv.ADCConfig->pAdcPinIoAttr[1].adcPin);
        if (ADC_DATA_IS_NOT_READY != acRawValue) {
            inputSourceState->dcPlugInVoltage = DC_ADC_TO_mVOLT(acRawValue);
            if ((inputSourceState->dcPlugInVoltage < CHARGER_MAX_mVOLT) &&
                    (inputSourceState->dcPlugInVoltage > CHARGER_MIN_mVOLT))
            {
                inputSourceState->isDcPlugIn = TRUE;
            } else 
            {
                inputSourceState->isDcPlugIn = FALSE;
            }
        }
        ADCDrv_StartScanning(&adcDrv);
    }    
    inputSourceState->isChargingDone = CH_STATUS_PIN;
    inputSourceState->isDcPlugInDetectByGPIO = AC_DETECT_PIN;
}

bool PowerDrv_GetBatteryVol(cPowerDrv *me, tBatteryVol* batteryVol) {
    bool ret = FALSE;
    int16 intBattAdcValue1 = 0;
    if (adcDrv.isCreated)
    {
        intBattAdcValue1 = (int16) ADCDrv_GetData(&adcDrv, adcDrv.ADCConfig->pAdcPinIoAttr[0].adcPin);
        if (ADC_DATA_IS_NOT_READY != intBattAdcValue1)
        {
            batteryVol->intBatteryVol = BATT_ADC_TO_mVOLT(intBattAdcValue1);
            ret = TRUE;
        }
        ADCDrv_StartScanning(&adcDrv);
    }
    return ret;
}

void PowerDrv_SetInputSource(cPowerDrv *me, eInputSource inputSource)
{
}

void PowerDrv_SetBatterySource(cPowerDrv *me, eBatterySource batterySource)
{
}

void PowerDrv_SetExtraCommand(cPowerDrv *me, eExtraCommand extraCommand)
{

}

void PowerDrv_PowerSaveSleep() {
    /**
     * Reset ADC conversion status for the case when adc conversion is on the fly
     * while system goes to deep sleep mode.
     */
    TP_PRINTF("int enable < sleep\r\n");
    ADCDrv_ResetAdcConversionStatus(&adcDrv);
    /*********/
    PowerDrv_SaveRegisters();
    /* set the specific pins tri-state (input) and disable pull-up/down to save power */
    PowerDrv_SetPinsSavingPower();
    /* turn off QP timer2*/
    T2CONbits.ON = 0;
    /* save the OSCCON SLPEN (Sleep mode enable) bit status before going to sleep*/
    uint32 OSCCONSave = (OSCCON & _OSCCON_SLPEN_MASK);
    /* stop the watchdog before putting MCU in sleep mode */
    BSP_DisableWatchdog();
    /* set system status to sleep status */
    BSP_SetSystemAwake(FALSE);

    /* call the microchip library to put MCU in deep sleep, only wake up for specific interrupt*/
    do
    {
        GpioDrv_AssertWakeUpKeyEnable(); //ASSERT if wekeup pin was not enable
        PowerSaveSleep();
    }while(BSP_IsSystemAwake() == FALSE);
    /* restart the watchdog, commont it for now*/

#ifdef DEBUG_FLUSH_MSG_BEFORE_SLEEP
    ProjBsp_PrintError("\r\nwakeup\r\n");
#endif

    BSP_EnableWatchdog();
    /* when wake up, clear the sleep/idle flag to idle mode, otherwise QP will put it into deep sleep mode*/
    if(OSCCONSave == 0)
    { /* if the SLPEN is 0 before sleep, then clear it*/
        mSysUnlockOpLock(OSCCONCLR = (1 << _OSCCON_SLPEN_POSITION));
    }
    T2CONbits.ON = 1;
    PowerDrv_ResumeRegisters();
}
#endif // HAS_BATTERY

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void PowerDrv_PowerUpStage1(cPowerDrv *me)
{
    PowerDrv_SetPower(OFF_STATE);
    //PowerDrv_SetReset(ON_STATE);
}

static void PowerDrv_PowerUpStage2(cPowerDrv *me)
{
    PowerDrv_SetPower(ON_STATE);
}

static void PowerDrv_PowerUpStage3(cPowerDrv *me)
{
    //PowerDrv_SetReset(OFF_STATE);
}

static void PowerDrv_SetPower(bool state)
{
    if(state == ON_STATE)
    {
        SAM3V3_EN_PIN_HIGH;   // Active high
        //DC3V3_EN_PIN_HIGH;   // Active high
    }
    else
    {
        SAM3V3_EN_PIN_LOW;
        //DC3V3_EN_PIN_LOW;
    }
}

static void PowerDrv_SetReset(uint8 state)
{
    if(state == ON_STATE)
    {
        RESET_PIN_LOW;   // Active low
    }
    else
    {
        RESET_PIN_HIGH;
    }
}

#ifdef HAS_BATTERY

static void PowerDrv_PushIntEvtToServer(eSignal signal) {
    if (isIntEvtRequest != TRUE) {
        return;
    }
    if (pIntEvtRequestor != NULL) {
        QEvt* pEvt = Q_NEW(QEvt, signal);
        QACTIVE_POST(pIntEvtRequestor, (QEvt*) pEvt, 0);
    }
}
#endif //HAS_BATTERY


/* set unused pins tri-state*/
static void PowerDrv_InitialUnusedPins()
{
    uint8 i;
    for(i=0; i<ArraySize(UN_USED_PINS); i++)
    {
        PORTSetPinsDigitalIn(UN_USED_PINS[i].portId, UN_USED_PINS[i].bits);
    }
}



static void PowerDrv_EnableAcDetInt()
{
    PowerDrv_InitialCNIntOnAcDet();
}

static void PowerDrv_DisableAcDetInt()
{
    PowerDrv_DisableCNIntOnAcDet();
}


/* use the change notice interrupt for AC plugged in detect*/
static void PowerDrv_InitialCNIntOnAcDet()
{
    INTDisableInterrupts();
    PORTSetPinsDigitalIn(IOPORT_B, BIT_3);
    CNCONBbits.ON =1;
    CNENBbits.CNIEB3 =1;
    /* read this pin once to initial the port change notice int*/
    AC_DETECT_PIN;
    IPC8bits.CNIP = 4;
    IFS1bits.CNBIF = 0;
    IEC1bits.CNBIE =1;
    INTEnableInterrupts();
}

static void PowerDrv_DisableCNIntOnAcDet()
{
    CNCONBbits.ON =0;
    CNENBbits.CNIEB3 =0;
    /* read this pin to clear the mismatch*/
    AC_DETECT_PIN;
    IFS1bits.CNBIF = 0;
    IEC1bits.CNBIE =0;
}

static void PowerDrv_InitChargeStatusPin()
{
    SET_CH_STATUS_PIN_DIGITAL;
    SET_CH_STATUS_PIN_PULL_UP;
    SET_CH_STATUS_PIN_INPUT;
}

/* save the register setting*/
static void PowerDrv_SaveRegisters()
{
    uint8 i;
    for (i=0;i<ArraySize(pPeripheralReg);i++)
    {
        peripheralRegSave[i]= (*pPeripheralReg[i]);
    }
}
/* resume the register setting*/
static void PowerDrv_ResumeRegisters()
{
    uint8 i;
    for (i=0;i<ArraySize(pPeripheralReg);i++)
    {
        (*pPeripheralReg[i])= peripheralRegSave[i];
    }
}

/* set specific pins as tri-state (input) to save power*/
static void PowerDrv_SetPinsSavingPower()
{
    /* set OSC2 pin as input */
    TRISCbits.TRISC15 = 1;
    /* Set SPI pins to sam module as input */
    TRISE = ~0;
    TRISGbits.TRISG6 = 1;
    /* make sure intenal pull-up/down are disabled*/
    CNPUB = 0;
    CNPUC = 0;
    CNPDB = 0;
    CNPDC = 0;
}

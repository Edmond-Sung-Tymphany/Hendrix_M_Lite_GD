/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Nvm Driver
                  -------------------------

                  SW Module Document




@file        NvmDrv.c
@brief       It's the driver to read/write Non-Volatile Memory (NVM) of PIC32MX
@author      Johnny Fan 
@date        2014-03-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-03-17     Johnny Fan 
DESCRIPTION: First Draft. Generated by newclass.py.
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "product.config"
#ifdef HAS_NVM

#include "./NvmDrv_priv.h"
#include "trace.h"

/* Private functions / variables. Declare and drivers here */
// allocates "nvm_data", aligned on erasable page boundary

//NVM_STORAGE_ADDR is defined in bootloader (NvmDrv_common.h)
NVM_ALLOCATE_ADDR(NVM_STORAGE_ADDR, NVM_DATA, NVM_STORE_BYTE_SIZE);

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void NvmDrv_Ctor(cNvmDrv *me)
{   
    ASSERT(me);
    /* set up the function */
    me->super_.SetValue = NvmDrv_WriteWords;
    me->super_.GetValue = NvmDrv_ReadWords;
    /* PIC32 do NOT require an extra erase page opration before writing data.
     * The erase page opration will be done in the write API : NVMProgram()
     */
    me->super_.ErasePage = NULL;
}

void NvmDrv_Xtor(cNvmDrv *me)
{
    ASSERT(me);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
//write some words
static bool NvmDrv_WriteWords(cStorageDrv *me, uint32 addr, uint8* data, uint32 sizeInBytes)
{
    cNvmDrv* pNvmObj;
    pNvmObj = (cNvmDrv*)me;

    /*Note: Because of the limitation of API:NVMProgram(), sizeInBytes must be multiple of sizeof(uint32). */
    if(sizeInBytes%sizeof(uint32))
    {
        sizeInBytes += (sizeof(uint32) - sizeInBytes%sizeof(uint32));
    }

    if((addr+sizeInBytes)>NVM_STORE_BYTE_SIZE)
    {
        return FALSE;
    }
 /* page buffer needed by NVMprogram function, as it will first erase the flash before writing,
  * this buffer is for temporary storage for the flash data*/
    uint32 pagebuff[PAGE_SIZE];
    NVMProgram((void *)(NVM_DATA + addr), (const void *)data, \
            sizeInBytes, (void*) pagebuff);
    return NvmDrv_CheckError(pNvmObj);
}

//read some words
static bool NvmDrv_ReadWords(cStorageDrv *me, uint32 addr, uint8* data, uint32 sizeInBytes)
{
    cNvmDrv* pNvmObj;
    pNvmObj = (cNvmDrv*)me;
    if((addr + sizeInBytes)>NVM_STORE_BYTE_SIZE)
    {
        return FALSE;
    }
    memcpy((void *)data,(void *)(&NVM_DATA[addr]), sizeInBytes);
    return TRUE;
}


static bool NvmDrv_CheckError(cNvmDrv *me)
{
    if(NVMIsError())
    { // if there's error
        NVMClearError();
        return FALSE;
    }
    return TRUE;
}


/***************************************************************************
 * Single word read/write, just keep them for bootloader usage for now
 **************************************************************************/
bool NvmDrv_WriteWord(uint32 address, uint32 wData)
{
    if( (address+sizeof(wData)) > NVM_STORE_BYTE_SIZE )
    {
        return FALSE;
    }
    
    /* page buffer needed by NVMprogram function, as it will first erase the flash before writing,
     * this buffer is for temporary storage for the flash data
     */
    uint32 pagebuff[PAGE_SIZE]; //PAGE_SIZE: page size in interger

    if( *(uint32 *)(&NVM_DATA[address]) != wData ) {
        NVMProgram((void *)(NVM_DATA + address), (const void *)(&wData), sizeof(wData), (void*) pagebuff);
    }
    ASSERT( *(uint32 *)(&NVM_DATA[address]) == wData );

    return NvmDrv_CheckError(NULL);
}

//read a single word
bool NvmDrv_ReadWord(uint32 address, uint32* pReadData)
{
    if( (address+ sizeof(*pReadData)) > NVM_STORE_BYTE_SIZE )
    {
        return FALSE;
    }
    *pReadData = *(uint32 *)(&NVM_DATA[address]);
    return NvmDrv_CheckError(NULL);
}


/***************************************************************************
 * Below functions is not used, but keep it here for now
 **************************************************************************/
//erase the whole NVM storage NVM_DATA
BOOL NvmDrv_EraseAll(cNvmDrv *me)
{
    if (NVM_STORE_BYTE_SIZE > BYTE_PAGE_SIZE)
    {
        /* if the storage size is bigger than 1 page, erase page by page*/
        int32 nvmFlashSize = NVM_STORE_BYTE_SIZE;
        uint8* pNvmData = (uint8*) NVM_DATA;
        do
        {
            NVMErasePage((void *) pNvmData);
            nvmFlashSize -= BYTE_PAGE_SIZE;
            pNvmData += BYTE_PAGE_SIZE;
        }while(nvmFlashSize>0);
    }
    else
    {/* erase one page*/
        NVMErasePage((void *) NVM_DATA);
    }
    return NvmDrv_CheckError(me);
}

#endif  // HAS_NVM
/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Nvm Driver
                  -------------------------

                  SW Module Document




@file        NvmDrv.c
@brief       It's the driver to read/write Non-Volatile Memory (NVM) of STM32F0
@author      Wesley Lee
@date        2014-07-01
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-07-01     Wesley Lee
DESCRIPTION: First Draft. Generated by newclass.py.
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "stm32f10x_flash.h"
#include "./NvmDrv_priv.h"
#include "trace.h"

/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void NvmDrv_Ctor(cNvmDrv *me)
{
    ASSERT(me);

    me->super_.pStorageConfig = (tStorageDevice*) getDevicebyId(INT_FLASH_DEV_ID, NULL);
    /* set up the function */
    me->super_.SetValue = NvmDrv_WriteWords;
    me->super_.GetValue = NvmDrv_ReadWords;
    me->super_.ErasePage    = NvmDrv_ErasePage;

	/* Clear pending flags (if any) */
	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
}

void NvmDrv_Xtor(cNvmDrv *me)
{
    ASSERT(me);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/* @brief           Write the NVM with the given buffer
 * @param   me      Storage Driver object
 * @param   addr    Address start to write
 * @param   data    pointer to data to write
 * @param   sizeInBytes
 * @return
 * @warning data stream should be in size of multiple of 4 (i.e. word)
 * @warning STM32F030 is little-endian
 * @warning The content of address to be written must be 0xFF
 */
static bool NvmDrv_WriteWords(cStorageDrv *me, uint32 addr, uint8* pBuf, uint32 sizeInBytes)
{
    ASSERT(sizeInBytes % 4 == 0);   // Words should be in size of multiple of 4
	uint32 i = 0;
    FLASH_Status s;

	FLASH_Unlock();
	for ( ; i<sizeInBytes; i+=4)
	{
        uint8   *p  = pBuf + i;
        uint32  d   = *p | *(p+1)<<8 | *(p+2)<<16 | *(p+3)<<24;
        s = FLASH_ProgramWord(addr + i, d);
        if (s != FLASH_COMPLETE)
        {
            break;
        }
	}
	FLASH_Lock();

    return NvmDrv_IsError();
}

/* @brief           Read the NVM content
 * @param   me      Storage Driver object
 * @param   addr    Address start to write
 * @param   data    pointer to data to write
 * @param   sizeInBytes
 * @return
 * @warning STM32F030 is little-endian
 */
static bool NvmDrv_ReadWords(cStorageDrv *me, uint32 addr, uint8* pBuf, uint32 sizeInBytes)
{
	uint8* p = (uint8*)addr;

    memcpy((void *)pBuf, p, sizeInBytes);
    return NvmDrv_IsError();
}

/* @brief   Erase Page
 * @param   me      Storage Drive object
 * @param   addr    Address to Erase
 */
static bool NvmDrv_ErasePage(cStorageDrv *me, uint32 addr)
{
    FLASH_Unlock();
    FLASH_Status s = FLASH_ErasePage(addr);
    FLASH_Lock();
    return NvmDrv_IsError();
}

static bool NvmDrv_IsError(void)
{
    return (FLASH_GetStatus() == FLASH_COMPLETE);
}


/***************************************************************************
 * Single word read/write, just keep them for bootloader usage for now
 **************************************************************************/
bool NvmDrv_WriteWord(uint32 addr, uint32 wData)
{
    return FALSE;
}

//read a single word
bool NvmDrv_ReadWord(uint32 addr, uint32* pReadData)
{
	uint32* p = (uint32*)addr;
    *pReadData = *p;
    return NvmDrv_IsError();
}


/***************************************************************************
 * Below functions is not used, but keep it here for now
 **************************************************************************/
//erase the whole NVM storage NVM_DATA
BOOL NvmDrv_EraseAll(cNvmDrv *me)
{
    return NvmDrv_IsError();
}

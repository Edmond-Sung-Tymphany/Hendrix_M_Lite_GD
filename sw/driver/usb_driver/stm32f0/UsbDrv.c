/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  USB Driver
                  -------------------------

                  SW Module Document




@file        UsbDrv.c
@brief       It's the USB driver to communicate bewteen PC endpoint and local endpoint
@author      Neo Gan
@date        2016-09-09
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2016-09-09     Neo Gan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "stm32f0xx.h"
#include "trace.h"
#include "bsp.h"
#include "timer.h"
#include "attachedDevices.h"
#include "usb_dcd.h"
#include "usbd_cdc_core.h"

#include "UsbDrv.h"
#include "UsbDrv_priv.h"
#include "UsbDrv.Config"
#include "UsbSrv.h"
#include "ringbuf.h"
#include "tp_common.h"
#include "controller.h"
#include "AppPrivSig.Config"
//#include "DebugSSrv.h"

#ifdef HW_GPIO_DEBUG
#include "GpioDrv.h"
#endif

#ifdef PT_ADC_DEBUG
#include "AdcDrv.h"
#define ADC_READ_FAIL   0xFFFF
#endif

#ifdef PT_I2C_DEBUG
#include "I2CDrv.h"
static cI2CDrv  dbgI2cObj1;
static cI2CDrv  dbgI2cObj2;
#endif

/* Private functions / variables. Declare and drivers here */
/* internal use for excuting the BT comand*/

#define MSG_POOL_NUM    3 // small, medium and large

/*****************************************************************************************************************
 *
 *  Variable
 *
 *****************************************************************************************************************/
static uint8 cmdBuf[BYTES_USB_RECV_CMD_BUF];

static uint8        usbTxBuf[BYTES_USB_TX_BUF];
static cRingBuf     txBufObj;
static uint16 recvTimerId = 0;


static cUsbDrv *pUsbDrvObj;
static uint16 msg_size_map[MSG_POOL_NUM] = {SIZE_OF_SMALL_EVENTS, SIZE_OF_MEDIUM_EVENTS, SIZE_OF_LARGE_EVENTS};


/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/

void UsbDrv_Ctor(cUsbDrv *me)
{     
    if (FALSE == me->drvIsCreated)
    {
        /* Configure GPIO and Clock */
        UsbDrv_Init();

#ifdef PT_I2C_DEBUG
        I2CDrv_Ctor(&dbgI2cObj1, (tI2CDevice*)getDevicebyIdAndType(DBG_I2C1_ID, I2C_DEV_TYPE, NULL));
        I2CDrv_Ctor(&dbgI2cObj2, (tI2CDevice*)getDevicebyIdAndType(DBG_I2C2_ID, I2C_DEV_TYPE, NULL));
#endif

        pUsbDrvObj = me;

        /* Create buffers for recevie and send data */
        RingBuf_Ctor(&txBufObj, usbTxBuf, BYTES_USB_TX_BUF);
        RingBuf_Reset(&txBufObj);

        /* Intial USB DCD */
        DCD_Init(&USBD_CDC_cb, &txBufObj);

        UsbDrv_ResetRxBuffer(me);

        me->deviceStatus = USB_STA_UNCONNECTED;
        me->drvIsCreated = TRUE;
    }

}

void UsbDrv_Xtor(cUsbDrv *me)
{

#ifdef PT_I2C_DEBUG
    if(me->drvIsCreated)
    {
        I2CDrv_Xtor(&dbgI2cObj1);
        I2CDrv_Xtor(&dbgI2cObj2);
    }
#endif

    me->deviceStatus = USB_STA_UNCONNECTED;

    /* this deinit must do it before UsbDrv_DeInit(),
     * otherwise it will can not mount the usb driver
     */
    DCD_DeInit();
    UsbDrv_DeInit();
    me->drvIsCreated = FALSE;
}

eUsbDeviceStatus UsbDrv_GetStatus(void)
{
    return DCD_GetStatus();
}

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
void UsbDrv_RecvData(uint8_t *rxBuf,uint32_t rxSize)
{
    uint32_t i;
    cUsbDrv *me = pUsbDrvObj;

    for(i = 0; i < rxSize; i++)
    {
        if(START_SIGN_IDX == me->recvIndex)
        {
            if(START_SIGN == rxBuf[i])
            {
                me->recvIndex++;
                me->isHeaderReceived = TRUE;
    
                /*start a timer */
                cmdBuf[START_SIGN_IDX] = rxBuf[i];

                UsbReqEvt *reqEvt = Q_NEW(UsbReqEvt, USB_REQ_SIG);
                reqEvt->type = USB_START_TIMER_REQ;
                SendToServer(USB_SRV_ID, (QEvt*)reqEvt);
            }
            else
            {
                /* reset setting */
                UsbDrv_ResetRxBuffer(me);
            }
            continue;
        }            
        else if(SIZEMSB_IDX == me->recvIndex)
        {
            me->recvSize = (rxBuf[i] << 8) | (rxBuf[i - 1]);
            if(me->recvSize > BYTES_USB_RECV_CMD_BUF)
            {
                //ASSERT(0);
                UsbDrv_ResetRxBuffer(me);
            }
        }
    
        if((me->recvIndex <= me->recvSize) && me->isHeaderReceived)
        {
            cmdBuf[me->recvIndex] = rxBuf[i];
            me->recvIndex++;

            if(me->recvIndex == me->recvSize)
            {
                me->isHeaderReceived = FALSE;
                UsbReqEvt *reqEvt = Q_NEW(UsbReqEvt, USB_REQ_SIG);
                reqEvt->type = USB_RECV_FRAME_REQ;
                SendToServer(USB_SRV_ID, (QEvt*)reqEvt);
            }
        }

    }
}


void UsbDrv_SendData(uint8_t *buf, uint32_t size)
{
    /* write data to the rinb buffer */
    if(USB_STA_CONFIGURED == UsbDrv_GetStatus())
        RingBuf_Push(&txBufObj, buf, size);
}

static void UsbDrv_ResetRxBuffer(cUsbDrv *me)
{
    me->isHeaderReceived    = FALSE;
    me->recvIndex           = START_SIGN_IDX;
    me->recvSize            = DMSG_MIN_SIZE;

    Timer_StopTimer(recvTimerId);
}

static void UsbDrv_HandleCompleteFrame(cUsbDrv * const me)
{    /* Check CRC */
    if(Tp_CheckCrc(cmdBuf, me->recvSize))
    {
        /*Parse frame and diliver msg to servers */
        tpMsgEvt dmsg;
        dmsg.target_srv_id = (ePersistantObjID)cmdBuf[SRVID_IDX];
        dmsg.signal = (eSignal)cmdBuf[SIG_IDX];
        dmsg.msg_size = me->recvSize;
        eSignalType type = Tp_GetSignalType(dmsg.signal, (tAppSigMapTable*)app_priv_sig_map, sizeof(app_priv_sig_map));
        Tp_DeliverFrameToServer(me->pSender, &dmsg, type, &cmdBuf[DATASTART_IDX], me->recvSize - DMSG_MIN_SIZE);
    } 
}

void UsbDrv_RequestHandler(cUsbDrv * const me, QEvt const * const e)
{
    UsbReqEvt *reqEvt = (UsbReqEvt *)e;

    TP_PRINTF("UsbDrv_RequestHandler %d\r\n", reqEvt->type);
    switch(reqEvt->type)
    {
        case USB_START_TIMER_REQ:
        {
            Timer_StartTimer(USB_RECV_START_TIMEOUT_MS, &recvTimerId, UsbDrv_RecvStartTimeoutCallBack, NULL);            
            break;
        }
        case USB_RECV_TIMEOUT_REQ:
        {
            /*Clean the buffer */
            UsbDrv_ResetRxBuffer(me);
            break;
        }
        case USB_RECV_FRAME_REQ:
        {
            UsbDrv_HandleCompleteFrame(me);
            UsbDrv_ResetRxBuffer(me);
            break;
        }
        case USB_RESPONSE_TIMEOUT_REQ:
        {

            break;
        }
        case USB_CTRL_REQ:
        {

            break;
        }
        default:
        {
            break;
        }

    }

}

void UsbDrv_HandleUnknown(cUsbDrv * const me, QEvt const * const e)
{
    /* handle some unknown message */
    uint16 length;
    eSignalType type;
    uint8 databuf[SIZE_OF_LARGE_EVENTS + DMSG_MIN_SIZE] = {0};

    switch(e->sig)
    {
#ifdef HW_GPIO_DEBUG
        case DEBUG_GPIO_REQ_SIG:
        {
            GpioDebugReqEvt* req = (GpioDebugReqEvt*)e;
            if (req->mode == GPIO_PORT_WRITE)
            {
                GpioDrv_DirectPinAccessSet(req->port, req->bit, req->action);
            }
            GpioDebugRespEvt* resp = Q_NEW(GpioDebugRespEvt, DEBUG_GPIO_RESP_SIG);
            resp->evtReturn = RET_SUCCESS;
            resp->value = GpioDrv_DirectPinAccessRead(req->port, req->bit, req->direction);
            req->sender = (QActive*)me;
            SendToServer(USB_SRV_ID, (QEvt*)resp);

            break;
        }
#endif

#ifdef PT_ADC_DEBUG
        case DEBUG_ADC_REQ_SIG:
        {
            int32 result = 0;
            AdcReqEvt* req = (AdcReqEvt*)e;
            AdcRespEvt* resp = Q_NEW(AdcRespEvt, DEBUG_ADC_RESP_SIG);

            resp->port = req->port;
            resp->bit = req->bit;
            result = ADCDrv_GetAdcRawDataByPortBit(req->port, req->bit);
             if (result >= 0)
             {
                resp->value = result;
                resp->evtReturn = RET_SUCCESS;
             }
             else
             {
                resp->value = ADC_READ_FAIL;
                resp->evtReturn = RET_FAIL;
             }
             SendToServer(USB_SRV_ID, (QEvt*)resp);

             break;
        }
#endif

#ifdef PT_I2C_DEBUG
            case DEBUG_I2C_REQ_SIG:
            {
                eTpRet ret;
                IICReqEvt* req = (IICReqEvt*)e;
                if (req->mode == IIC_READ)
                {
                    IICRespEvt* resp = Q_NEW(IICRespEvt, DEBUG_I2C_RESP_SIG);

                    resp->mode = IIC_READ;
                    resp->devAddr = req->devAddr;
                    resp->regAddr = req->regAddr;
                    resp->regAddrLen = req->regAddrLen;
                    resp->length = req->length;
                    tI2CMsg i2cMsg =
                    {
                        .devAddr = req->devAddr,
                        .regAddr = req->regAddr,
                        .length  = req->length,
                        .pMsg    = (uint8*)&(resp->data[0]),
                    };
                    if (req->channel == I2C_CHANNEL_ONE)
                    {
                        ret = I2CDrv_MasterRead(&dbgI2cObj1, &i2cMsg);
                        resp->channel = I2C_CHANNEL_ONE;
                    }
                    else
                    {
                        ret = I2CDrv_MasterRead(&dbgI2cObj2, &i2cMsg);
                        resp->channel = I2C_CHANNEL_TWO;
                    }
                    if (ret == TP_SUCCESS)
                    {
                        resp->evtReturn = RET_SUCCESS;
                    }
                    else
                    {
                        resp->evtReturn = RET_FAIL;
                    }
                    SendToServer(USB_SRV_ID, (QEvt*)resp);
             }
             else
             {
                uint8 wdat[IIC_DATA_MAX_SIZE + 2];
                switch (req->regAddrLen)
                {
                 case REG_LEN_8BITS:
                    wdat[0] = (uint8)req->regAddr;
                    memcpy(&wdat[1], &req->data[0], req->length);
                    break;
                 case REG_LEN_16BITS:
                    wdat[0] = req->regAddr >> 8;
                    wdat[1] = req->regAddr & 0x00FF;
                    memcpy(&wdat[2], &req->data[0], req->length);
                   break;
                    default:
                    ASSERT(0);
                }
                tI2CMsg i2cMsg =
                {
                    .devAddr = req->devAddr,
                    .regAddr = NULL,
                    .length  = req->length + req->regAddrLen + 1,
                    .pMsg    = &wdat[0],
                };
                if (req->channel == I2C_CHANNEL_ONE)
                {
                    ret = I2CDrv_MasterWrite(&dbgI2cObj1, &i2cMsg);
                }
                else
                {
                    ret = I2CDrv_MasterWrite(&dbgI2cObj2, &i2cMsg);
                }
                ASSERT(ret==TP_SUCCESS);
             }

            break;
        }
#endif

        default:
        {
            type = Tp_GetSignalType(e->sig, (tAppSigMapTable*)app_priv_sig_map, sizeof(app_priv_sig_map));
            length = Tp_HandleResponse(type, databuf, e->sig, msg_size_map[e->poolId_ - 1], (uint8*)e);

            UsbDrv_SendData(databuf, length);
            break;

        }
    }    
}

static void UsbDrv_RecvStartTimeoutCallBack(void *pCbPara)
{
    UsbReqEvt *reqEvt = Q_NEW(UsbReqEvt, USB_REQ_SIG);
    reqEvt->type = USB_RECV_TIMEOUT_REQ;
    SendToServer(USB_SRV_ID, (QEvt*)reqEvt);
}


/*
-------------------------------------------------------------------------------
TYMPHANY LTD
                  Main Application
                  -------------------------
                  SW Module Document

@file        MainApp.c
@brief       Main application for BnO SoundWall
@author      Viking Wang
@date        2016-11-08
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-20     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "product.config"

#include "stm32f0xx.h"
#include "projBsp.h"
#include "memory_config.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "bsp.h"
#include "modes.h"
#include "controller.h"
#include "I2CDrv.h"
#include "DebugSSrv.h"
#include "SystemDrv.h"
#include "AudioDrv.h"
#include "IoeLedDrv.h"
#include "A2bSrv.h"
#include "adi_ad24xx.h"
#include "core.pb.h"
#ifdef HAS_SOUNDMODE_UPDATE
#include "Adau1452_drv.h"
#endif
#include "UsbSrv.h"
#include "UsbSrv_GPB.h"
#include "I2cSlaveDrv.h"

#include "MainApp.h"
#include "./MainApp_priv.h"

#define MAIN_APP_TIMEOUT_IN_MS          20

#define CAST_ME cMainApp * MainApp = (cMainApp *) me;

static const uint32 App_version@"APP_VERSION_SECT" =
    (APPLICATION_VERSION0 << 24) | (APPLICATION_VERSION1 << 16) |
    (APPLICATION_VERSION2 << 8) | (APPLICATION_VERSION3);

#ifdef DEFERRED_REQ_QUE
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[6];
#endif
/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[MAINAPP_EVENT_Q_SIZE];

#define A2B_RESTART_TIMEOUT     60     // unit : ms
#define A2B_POWERUP_INIT_TIMEOUT     2000     // unit : ms
static int16_t a2b_restart_timeout=0;
static int16_t ignore_source_hijack_timeout=0;
static int16_t codec_demute_timeout=0;
static int16_t amp_demute_timeout=0;
static bool firmware_version_show=TRUE;
static bool dsp_version_show=TRUE;
static bool hw_ver_show=TRUE;
static bool auto_standby_enable=TRUE;

static eAudioChannel current_source=AUDIO_CHANNEL_INVALID;
static eAudioChannel wakeup_source=AUDIO_CHANNEL_INVALID;
const static eAudioChannel source_list[MAINAPP_SOURCE_CH_MAX+1] =
{
    MAINAPP_SOURCE_AUX,
    MAINAPP_SOURCE_OPTICAL,
    MAINAPP_SOURCE_A2B,
    MAINAPP_SOURCE_OPTICAL  // this is default source
};

#define CAST_ME cMainApp * MainApp = (cMainApp *) me;

static QState MainApp_Initial(cMainApp * const me, QEvt const *const e);

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(cMainApp * const me, QEvt const * const e);

static QState MainApp_PoweringUp(cMainApp * const me, QEvt const * const e);

static QState MainApp_DeActive(cMainApp * const me, QEvt const * const e);

static void MainApp_SwitchMode(cMainApp* me, uint16 modeId);

static void MainApp_EnterDfu(void);
static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e);

static void MainApp_SourceLed(cMainApp * const me)
{
    (void)me;

    switch( current_source )
    {
    case MAINAPP_SOURCE_AUX:
        IoeLed_SetupMode(LED_ID_BLUE, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DIM_VALUE_OFF);
        IoeLed_SetupMode(LED_ID_RED, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DIM_VALUE_OFF);
        IoeLed_SetupMode(LED_ID_GREEN, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DEFAULT_DIM_VALUE);
        break;
    case MAINAPP_SOURCE_A2B:
        IoeLed_SetupMode(LED_ID_BLUE, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DEFAULT_DIM_VALUE);
        IoeLed_SetupMode(LED_ID_GREEN, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DIM_VALUE_OFF);
        IoeLed_SetupMode(LED_ID_RED, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DEFAULT_DIM_VALUE);
        break;
    case MAINAPP_SOURCE_OPTICAL:
        IoeLed_SetupMode(LED_ID_GREEN, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DIM_VALUE_OFF);
        IoeLed_SetupMode(LED_ID_RED, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DIM_VALUE_OFF);
        IoeLed_SetupMode(LED_ID_BLUE, IOE_LED_MODE_NORMAL, LED_BLINK_MODE_NONE, IOE_DEFAULT_DIM_VALUE);
        break;
    default:
        ALWAYS_printf("\n\r Source Error! \n\r");
        break;
    }
}

static void MainApp_SwitchToSource(cMainApp * const me, eAudioChannel source)
{
    current_source = source;

    BRINGUP_printf("\n\r Source : %d\n\r", current_source);

	AudioDrv_Mute(AUDIO_DSP_DACOUT_MUTE, TRUE);
	
    AudioSrv_SetChannel((QActive *)me, current_source);
    MainApp_SourceLed(me);

    if( SystemDrv_A2BModeIsMaster() )
    {
        a2b_restart_timeout = A2B_RESTART_TIMEOUT;
    }

	codec_demute_timeout = 200;
}

#ifdef KEY_FOR_DEBUG
#define SHORT_PRESSED_COUNT     3       // 60ms
#define LONG_PRESSED_COUNT      100     // 2 seconds
#define VERY_LONG_HOLD_COUNT    250     // 5 seconds
static uint8_t key_pressed=0;
static uint32_t key_pressed_count=0;
// PB1 : key for bring up debug
static void MainApp_DebugKey_Init(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;

    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;

    GPIO_Init(GPIOB, &GPIO_InitStructure);
}

static void MainApp_SourceSwitch(cMainApp * const me)
{
    // only powerlink/toslink switch now
    if( current_source == MAINAPP_SOURCE_OPTICAL )
        current_source = MAINAPP_SOURCE_AUX;
    else
        current_source = MAINAPP_SOURCE_OPTICAL;
        
    MainApp_SwitchToSource(me, current_source);
}

static void MainApp_KeyScan(cMainApp * const me)
{
    if( GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) )
    {   // key release
        if( key_pressed )
        {
            if( key_pressed_count > VERY_LONG_HOLD_COUNT )
            {
                // ignore it
            }
            else if( key_pressed_count > LONG_PRESSED_COUNT )
            {
                // long pressed & release
                BRINGUP_printf("\n\r key long pressed.\n\r");
                MainApp_SourceSwitch(me);
//                UsbSrv_AseSendReq_Get(Proto_AseFep_ReqResp_GET_A2B_MODE);
            }
            else if( key_pressed_count > SHORT_PRESSED_COUNT )
            {
                // short pressed & release
                BRINGUP_printf("\n\r key short pressed.\n\r");

                MainApp_SourceSwitch(me);
//                UsbSrv_AseSendReq_VerInfo(1);

//                UsbSrv_TestGainAndDelay();

//                UsbSrv_AseSendEvent(Proto_AseFep_Event_Type_SOUNDWALL_WRITE_SERIAL_NO_CTL, 87654321);
//                UsbSrv_AseSendEvent(Proto_AseFep_Event_Type_SOUNDWALL_GET_SERIAL_NO_CTL, 0);
/*
{
                static int32_t input=3;
                UsbSrv_AseSendReq_AudioInput(input);	// 2:TOSLINK, 3:POWERLINK
                if( input == 3 )
                    input = 2;
                else
                    input = 3;
}
*/
/*
{
                static uint32_t mute=0;
                UsbSrv_AseSendReq_Mute(mute);
                if( mute )
                    mute = 0;
                else
                    mute = 1;
}
*/
//                UsbSrv_BackupVersionInfo("132", "tet");
//                UsbSrv_AseSendReq_Get(Proto_AseFep_ReqResp_FIRMWARE_UPDATE_VERSION_INFO);
/*                {   // for a2b mode debug
                    static int32_t a2b_mode=0;
                    UsbSrv_AseSendReq_A2Bmode(a2b_mode);
                    a2b_mode ++;
                    if( a2b_mode > 5 )
                        a2b_mode = 0;
                }
*/
/*
                if( SYSTEM_STATUS_STANDBY == SystemDrv_GetSystemStatus() )
                {
                    UsbSrv_AseSendReq_PowerMode(1);
                }
                else
                {
                    UsbSrv_AseSendReq_PowerMode(0);
                }
*/
//                UsbSrv_AseSendReq_DfuMode(0);
//                UsbSrv_AseSendReq_SystemReboot(0);
/*
{
                static uint32_t tile_no=0;
                tile_no ++;
                if( tile_no > 4 ) 
                    tile_no = 0;
                UsbSrv_AseSendReq_TestTone(0, tile_no);
}
*/
            }
            else
            {
                // < 60ms pressed, maybe noise, ignore it
            }
            key_pressed = 0;
        }

        key_pressed_count = 0;
    }
    else
    {
        key_pressed = 1;
        key_pressed_count ++;
        if( key_pressed_count == VERY_LONG_HOLD_COUNT )
        {
            BRINGUP_printf("\n\r key very long pressed.\n\r");
            BSP_BlockingDelayMs(10);
            
            if( SYSTEM_STATUS_STANDBY == SystemDrv_GetSystemStatus() )
            {
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
            }
            else if( SYSTEM_STATUS_WORKING == SystemDrv_GetSystemStatus() )
            {
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
            }
            else
            {
            }
        }
    }
}
#endif

static void MainApp_HijackService(cMainApp * const me)
{
#ifdef MUSIC_DETECT_BY_GPIO
    bool update_source=FALSE;
    extern SourceAudioInfo_t opt_audio_info;
    extern SourceAudioInfo_t aux_audio_info;

    // slave mode only works on A2B in mode
    if( A2B_MODE_SLAVE == SystemDrv_GetA2BMode() )
        return ;

    // only on 'WORKING' mode
    if( SYSTEM_STATUS_WORKING != SystemDrv_GetSystemStatus() )
        return ;

    if( ignore_source_hijack_timeout > 0 )
    {
        ignore_source_hijack_timeout --;
        return ;
    }

    if( current_source == MAINAPP_SOURCE_OPTICAL )
    {
        if( aux_audio_info.audio_input_on )
        {
            if( SOURCE_HIJACK_COUNT == aux_audio_info.audio_linked_cnt )
            {
                BRINGUP_printf("\n\rAUX hijack the source.");
                update_source = TRUE;
                MainApp_SwitchToSource(me, MAINAPP_SOURCE_AUX);
            }
        }
    }
    else if( current_source == MAINAPP_SOURCE_AUX )
    {
        if( opt_audio_info.audio_input_on )
        {
            if( SOURCE_HIJACK_COUNT == opt_audio_info.audio_linked_cnt )
            {
                BRINGUP_printf("\n\rOPTICAL hijack the source.");
                update_source = TRUE;
                MainApp_SwitchToSource(me, MAINAPP_SOURCE_OPTICAL);
            }
        }
    }
    else
    {
//        ALWAYS_printf("\n\r Source ERROR!!! .\n\r");
    }

    if( update_source )
    {
        Setting_Set(SETID_AUDIO_SOURCE, (void *)(&current_source));
    }
#endif    
}

static void MainApp_CheckAutoWakeUp(cMainApp * const me)
{
    (void)me;

    // slave mode, check the wake up GPIO only
    if( A2B_MODE_SLAVE == SystemDrv_GetA2BMode() )
    {
        // done in SystemDrv_StandbyUpdate()
    }
    else
    {
        extern SourceAudioInfo_t opt_audio_info;
        extern SourceAudioInfo_t aux_audio_info;
        if( opt_audio_info.audio_input_on )
        {
            if( opt_audio_info.audio_linked_cnt == SOURCE_HIJACK_COUNT )
            {
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
                wakeup_source = MAINAPP_SOURCE_OPTICAL;
            }
        }
        if( aux_audio_info.audio_input_on )
        {
            if( aux_audio_info.audio_linked_cnt == SOURCE_HIJACK_COUNT )
            {
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
                wakeup_source = MAINAPP_SOURCE_AUX;
            }
        }
    }
}

static void MainApp_ShowVersion(void)
{
    ALWAYS_printf("\n\r------------------------------------------------------------\n\r");
    ALWAYS_printf("\n\r BnO SoundWall App:V%s[0x%x]. built on %s.\n\r", SOUNDWALL_APP_VERSION, App_version, __DATE__);
    ALWAYS_printf("\n\r------------------------------------------------------------\n\r");
}

static void MainApp_Version2TPMonitor(void)
{
    char ver_msg[28];
#ifdef HAS_HW_VERSION_TAG
    char hw_msg[][8]={"Unknown", "ES1", "ES2", "ES3", "EVT1", "EVT2", \
                      "DVT1", "DVT2", "PVT", "MP1", "MP2"};
    HwVersion_t hw_ver;
    hw_ver = SystemDrv_GetHWversion();
    sprintf(ver_msg, "[HW Ver:%s].", hw_msg[hw_ver]);
    DebugSSrv_Printf(ver_msg);
#endif
    sprintf(ver_msg, "[MCU:V%s]", SOUNDWALL_APP_VERSION);
    DebugSSrv_Printf(ver_msg);
}

static void MainApp_VolumeCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t value;

    value = p_ctl_evt->value;
    if( value < MAX_VOLUME_STEPS )
    {
        AudioSrv_SetVolume(value);
        Setting_Set(SETID_VOLUME, &value);
        TP_PRINTF("\n\r Volume = -%ddB\n\r", value);
    }
    else
    {
        TP_PRINTF("\n\rERROR:Volume=%d.\n\r", value);
    }
}

static void MainApp_VerInfoAscIIformat(void)
{
    char ver_msg[120];
    char dsp_ver_msg[8] = "x.x.x";
    HwVersion_t hw_ver;
    uint32_t dsp_ver;
    char hw_msg[][8]={"Unknown", "ES1", "ES2", "ES3", "EVT1", "EVT2", \
                      "DVT1", "DVT2", "PVT", "MP1", "MP2"};
    // h/w version
    strcpy(ver_msg, "[HW VER:");
    hw_ver = SystemDrv_GetHWversion();
    strcat(ver_msg, hw_msg[hw_ver]);
    strcat(ver_msg, "].");

    // btl version
    strcat(ver_msg, "[BTL VER:");
    strcat(ver_msg, SOUNDWALL_BL_VERSION);
    strcat(ver_msg, "].");

    // app version
    strcat(ver_msg, "[APP VER:");
    strcat(ver_msg, SOUNDWALL_APP_VERSION);
    strcat(ver_msg, "].");

    // dsp version
    strcat(ver_msg, "[DSP VER:");
    dsp_ver = SystemDrv_GetDspVersion();
    dsp_ver %= 1000;
    dsp_ver_msg[0] = dsp_ver / 100 + '0';
    dsp_ver %= 100;
    dsp_ver_msg[2] = dsp_ver / 10 + '0';
    dsp_ver %= 10;
    dsp_ver_msg[4] = dsp_ver + '0';
    strcat(ver_msg, dsp_ver_msg);
    strcat(ver_msg, "].");

//    DebugSSrv_Printf(ver_msg);     // TP_Monitor only support 24 chars now, use normal printf to show the message
    ALWAYS_printf("\n\r%s", ver_msg);
    UsbSrv_SendString(ver_msg);
}

static void MainApp_VerInfoGPBformat(void)
{
/*
    char sn_msg[100];
    char ver_msg[60];
    char dsp_ver_msg[8] = "x.x.x";
    HwVersion_t hw_ver;
    uint32_t dsp_ver;
    uint32_t item_no, type_no, serial_no;
    char hw_msg[][8]={"Unknown", "ES1", "ES2", "ES3", "EVT1", "EVT2", \
                      "DVT1", "DVT2", "PVT", "MP1", "MP2"};
    
    // node index and Serial no message
    type_no = *(uint32_t *)Setting_Get(SETID_TYPE_NO);
    item_no = *(uint32_t *)Setting_Get(SETID_ITEM_NO);
    serial_no = *(uint32_t *)Setting_Get(SETID_SERIAL_NO);
    sprintf(sn_msg, "[Node:0][Type No:%d][Item No:%d][Serial No:%d]", type_no, item_no, serial_no);

    // h/w version
    strcpy(ver_msg, "\n\r[HW:");
    hw_ver = SystemDrv_GetHWversion();
    strcat(ver_msg, hw_msg[hw_ver]);
    strcat(ver_msg, "]");
    // btl version
    strcat(ver_msg, "[BTL:");
    strcat(ver_msg, SOUNDWALL_BL_VERSION);
    strcat(ver_msg, "]");
    // app version
    strcat(ver_msg, "[APP:");
    strcat(ver_msg, SOUNDWALL_APP_VERSION);
    strcat(ver_msg, "]");
    // dsp version
    strcat(ver_msg, "[DSP:");
    dsp_ver = SystemDrv_GetDspVersion();
    dsp_ver %= 1000;
    dsp_ver_msg[0] = dsp_ver / 100 + '0';
    dsp_ver %= 100;
    dsp_ver_msg[2] = dsp_ver / 10 + '0';
    dsp_ver %= 10;
    dsp_ver_msg[4] = dsp_ver + '0';
    strcat(ver_msg, dsp_ver_msg);
    strcat(ver_msg, "]");

    */
}

static void MainApp_VerInfoCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t value, total_nodes;

    value = p_ctl_evt->value;
    value &= 0xff;

    if( value & 0xf0 )
    {
        MainApp_VerInfoAscIIformat();
    }
    else
    {
        // only support master tile now
        value = 0;
        if( value == 0 )
        {   // master tile
            MainApp_VerInfoGPBformat();
        }
        else
        {   // TODO , get the version info from slaveTile
            total_nodes = SystemDrv_GetTotalNodes();
            if( value < total_nodes )
            {   // parameter is right
            }
            else
            {   // unknown node index
            }
        }
    }
}

static void MainApp_ChMuteCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t value;

    value = p_ctl_evt->value;

    if( value & 0xffffff00 )
    {
        UsbSrv_SendString("\n\rMute CTL : Error Parameter.");
    }
    else
    {
        AudioSrv_SetAudio(AUDIO_CHANNEL_MUTE_ID, TRUE, value, 0);
    }
}

static void MainApp_LedCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    uint8_t mode, blink_mode, dim_value;
    IoeLedIndex_t id;
    uint32_t value;

    value = p_ctl_evt->value;
    
    id = (IoeLedIndex_t)(value & 0xff);
    mode = (uint8_t)((value >> 8) & 0xff);
    blink_mode = (uint8_t)((value >> 16) & 0xff);
    dim_value =  (uint8_t)((value >> 24) & 0xff);
    
    IoeLed_SetupMode(id, mode, blink_mode, dim_value);
}

static void MainApp_SourceCtlSig(cMainApp * const me, MainAppCtlEvt *p_ctl_evt)
{
    uint32_t value;
    value = p_ctl_evt->value;

    switch( value )
    {
    case MAINAPP_SOURCE_AUX:
    case MAINAPP_SOURCE_A2B:
    case MAINAPP_SOURCE_OPTICAL:
        current_source = (eAudioChannel)value;
        MainApp_SwitchToSource(me, current_source);
        break;
    default:    // error
        DebugSSrv_Printf("ERROR Source.");
        break;
    }
}

static void MainApp_BypassCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    bool enable;

    if( p_ctl_evt->value )
    {
        enable = TRUE;
        ALWAYS_printf("\n\rBypass ENABLE.");
    }
    else
    {
        enable = FALSE;
        ALWAYS_printf("\n\rBypass Disable.");
    }
    
    AudioSrv_SetAudio(DSP_PASSTHROUGH_SETT_ID, enable, 0, 0);
}

static void MainApp_EnterDfu(void)
{
    // waiting for the "printf" finished
    BSP_BlockingDelayMs(30);

    // write the "upgrading" flag.
    uint32_t enter_dfu = ENTER_DFU_MAGIC_NUMBER;
    Setting_Set(SETID_ENTER_DFU, &enter_dfu);
    SettingSrv_BookkeepingEx();
    BSP_BlockingDelayMs(300);

    // reboot the system
    BSP_SoftReboot();
}

static void MainApp_A2BMasterCtlSig(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t a2b_mode;

    a2b_mode = p_ctl_evt->value;
    if( a2b_mode < A2B_MODE_MAX )
    {
        // TODO : set mode here 
        Setting_Set(SETID_A2B_MODE, (void *)&a2b_mode);
//        SystemDrv_SetA2BMode(a2b_mode);
        SettingSrv_BookkeepingEx();
        ALWAYS_printf("\n\r a2b_mode -> : %d\n\r", a2b_mode);
    }
    else
    {
        ALWAYS_printf("\n\r Unknown a2b_mode : %d\n\r", a2b_mode);
    }
}

static void MainApp_GetNTCinfo(void)
{
    NTCInfo_t *p_ntc_value;
    char ntc_msg[60];
    char amp_msg[20], dsp_msg[20], psu_msg[20];
    p_ntc_value = SystemDrv_GetNtcValue();
    sprintf(amp_msg, "AMP=%d.", p_ntc_value[NTC_INDEX_AMP].degree);
    sprintf(dsp_msg, "DSP=%d.", p_ntc_value[NTC_INDEX_DSP].degree);
    sprintf(psu_msg, "PSU=%d.", p_ntc_value[NTC_INDEX_PSU].degree);
    strcpy(ntc_msg, "[NTC]");
    strcat(ntc_msg, amp_msg);
    strcat(ntc_msg, dsp_msg);
    strcat(ntc_msg, psu_msg);
    ALWAYS_printf("\n\r%s", ntc_msg);
    UsbSrv_SendString(ntc_msg);    
}

static void MainApp_MuteAmpCtl(cMainApp * const me, MainAppCtlEvt *p_ctl_evt)
{
    bool enable;

    enable = (bool)p_ctl_evt->value;
    
    AudioSrv_SendMuteReq((QActive*)me, AUDIO_AMP_MUTE, enable);
}

static void MainApp_TestToneCtl(cMainApp * const me, MainAppCtlEvt *p_ctl_evt)
{
    uint32_t node, channel;

    node = (p_ctl_evt->value & 0xf0) >> 4;
    channel = p_ctl_evt->value & 0x0f;

    // check NodeIndex first
    if( node == 0 )
    {   // MasterTile
#ifdef HAS_AUDIO_MUTE_CHANNEL
        AudioMuteChannelReqEvt* pMuteReqEvt = Q_NEW(AudioMuteChannelReqEvt, AUDIO_MUTE_CHANNEL_REQ_SIG);
        pMuteReqEvt->channel_mask = channel;
        SendToServer(AUDIO_SRV_ID,(QEvt*)pMuteReqEvt);
#endif
    }
    else if( node < SystemDrv_GetTotalNodes() )
    {   // slaveTile Case, fix me later
    }
    else
    {
        ALWAYS_printf("\n\rTest tone parameter ERROR : 0x%x.", p_ctl_evt->value);
    }
}

static void MainApp_WriteDspParamCtl(cMainApp * const me, MainAppCtlEvt *p_ctl_evt)
{
    // TODO: store the DSP parameter to MCU flash
}

static void MainApp_WriteTypeNoCtl(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t type_no;

    type_no = (uint32_t)p_ctl_evt->value;
    if( type_no > MAINAPP_SN_MAX_TYPE_NO )
    {
        ALWAYS_printf("\n\r ERROR type no : %d.", type_no);
    }
    else
    {
        Setting_Set(SETID_TYPE_NO, (void *)&type_no);
        SettingSrv_BookkeepingEx();
    }
}

static void MainApp_WriteItemNoCtl(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t item_no;

    item_no = (uint32_t)p_ctl_evt->value;
    if( item_no > MAINAPP_SN_MAX_ITEM_NO )
    {
        ALWAYS_printf("\n\r ERROR item no : %d.", item_no);
    }
    else
    {
        Setting_Set(SETID_ITEM_NO, (void *)&item_no);
        SettingSrv_BookkeepingEx();
    }
}

static void MainApp_WriteSerialNoCtl(MainAppCtlEvt *p_ctl_evt)
{
    uint32_t serial_no;

    serial_no = (uint32_t)p_ctl_evt->value;
    if( serial_no > MAINAPP_SN_MAX_SERIAL_NO )
    {
        ALWAYS_printf("\n\r ERROR serial no : %d.", serial_no);
    }
    else
    {
        Setting_Set(SETID_SERIAL_NO, (void *)&serial_no);
        SettingSrv_BookkeepingEx();
    }
}

static void MainApp_GetSerialNoCtl(void)
{
    uint32_t item_no, type_no, serial_no;
    char sn_msg[100];

    type_no = *(uint32_t *)Setting_Get(SETID_TYPE_NO);
    item_no = *(uint32_t *)Setting_Get(SETID_ITEM_NO);
    serial_no = *(uint32_t *)Setting_Get(SETID_SERIAL_NO);
    sprintf(sn_msg, "[Type No:%d][Item No:%d][Serial:%d]", type_no, item_no, serial_no);
    ALWAYS_printf("\n\r%s", sn_msg);
    UsbSrv_SendString(sn_msg);
}

static void MainApp_AseReqHandler(cMainApp * const me, QEvt const * const e)
{
    AseReqEvt *req_evt;
    Proto_AseFep_Req *p_req;
    FepRespAseEvt *p_resp_evt;

    req_evt = (AseReqEvt *)e;
    p_req = &(req_evt->ase2fep_req);

    switch( p_req->type )
    {
    case Proto_AseFep_ReqResp_FIRMWARE_UPDATE_VERSION_INFO:
    {
        FepRespVerInfoEvt *p_ver_evt;
        uint32_t node, read_back;
        node = p_req->data.nodeIndex.nodeIndex;
        p_ver_evt = Q_NEW(FepRespVerInfoEvt, ASE_TK_RESP_SIG);
        p_ver_evt->id = p_req->id;
        p_ver_evt->type = p_req->type;
        A2bSrv_I2cRead(node, I2C_READ_CMD_TYPE_NO, 4, (uint8_t *)(&read_back));
        p_ver_evt->type_no = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_ITEM_NO, 4, (uint8_t *)(&read_back));
        p_ver_evt->item_no = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_SERIAL_NO, 4, (uint8_t *)(&read_back));
        p_ver_evt->serial_no = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_HW_VER, 4, (uint8_t *)(&read_back));
        p_ver_evt->hw_ver = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_BTL_VER, 4, (uint8_t *)(&read_back));
        p_ver_evt->btl_ver = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_APP_VER, 4, (uint8_t *)(&read_back));
        p_ver_evt->app_ver = read_back;
        A2bSrv_I2cRead(node, I2C_READ_CMD_DSP_VER, 4, (uint8_t *)(&read_back));
        p_ver_evt->dsp_ver = read_back;
/*
        BRINGUP_printf("\n\rtype=%d", p_ver_evt->type_no);
        BRINGUP_printf("\n\ritem=%d", p_ver_evt->item_no);
        BRINGUP_printf("\n\rserial=%d", p_ver_evt->serial_no);
        BRINGUP_printf("\n\rHW=%d",p_ver_evt->hw_ver);
        BRINGUP_printf("\n\rBTL=%d", p_ver_evt->btl_ver);
        BRINGUP_printf("\n\rAPP=%d", p_ver_evt->app_ver);
        BRINGUP_printf("\n\rDSP=%d.", p_ver_evt->dsp_ver);
*/
        SendToServer(USB_SRV_ID, (QEvt *)p_ver_evt);
        break;
    }
    case Proto_AseFep_ReqResp_FIRMWARE_UPDATE_SWITCH_TO_BOOTLOADER:
    {
        BOOL local_dfu=TRUE;
        uint32_t node;
        if( p_req->which_data == Proto_AseFep_Req_nodeIndex_tag )
        {
            node = p_req->data.nodeIndex.nodeIndex;
            if( node == 0 )
            {   // master
                local_dfu = TRUE;
            }
            else if( node < SystemDrv_GetTotalNodes() )
            {
                // reserver for future firmware upgrade by A2B
                local_dfu = FALSE;
                A2bSrv_I2cWrite(node, (uint8_t)I2C_WRITE_CMD_ENTER_DFU, 1, (uint8_t *)(&local_dfu)); 
            }
            else
            {   // index ERROR
                local_dfu = FALSE;
                p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
                p_resp_evt->id = p_req->id;
                p_resp_evt->type = p_req->type;
                p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
                SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
            }
        }
        if( local_dfu )
        {
            BSP_BlockingDelayMs(50);
            MainApp_EnterDfu();
        }
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SYSTEM_RESTART:
    {
        ALWAYS_printf("\n\rSystem reboot.");
        AudioDrv_Mute(AUDIO_DSP_DACOUT_MUTE, TRUE);
        BSP_BlockingDelayMs(100);
        AudioDrv_Mute(AUDIO_AMP_MUTE, TRUE);
        BSP_BlockingDelayMs(10);
        // reboot the system
        BSP_SoftReboot();
        break;
    }    
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_MUTE_MODE:
    {
        bool enable;
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        if( p_req->which_data == Proto_AseFep_Req_muteMode_tag )
        {
            if( p_req->data.muteMode.mode == Proto_SoundWall_MuteMode_Mode_MUTE )
            {
                enable = TRUE;
            }
            else
            {
                enable = FALSE;
            }
            AudioSrv_SendMuteReq((QActive*)me, AUDIO_AMP_MUTE, enable);
        }
        else
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
        }
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
    }
    case Proto_AseFep_ReqResp_AUDIO_INPUT:
    {
        Proto_Dsp_RequestAudioInput_AudioInput input;
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        if( p_req->which_data == Proto_AseFep_Req_audioInput_tag )
        {
            input = p_req->data.audioInput.input;
            if( input == Proto_Dsp_RequestAudioInput_AudioInput_TOS_LINK )
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
                current_source = MAINAPP_SOURCE_OPTICAL;
                MainApp_SwitchToSource(me, current_source);
            }
            else if( input == Proto_Dsp_RequestAudioInput_AudioInput_POWER_LINK )
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
                current_source = MAINAPP_SOURCE_AUX;
                MainApp_SwitchToSource(me, current_source);
            }
            else
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
            }
        }
        else
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
        }
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_A2B_MODE:
    {
        int32_t a2b_mode;
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        if( p_req->which_data == Proto_AseFep_Req_reqA2Bmode_tag )
        {
            a2b_mode = (int32_t)(p_req->data.reqA2Bmode.mode);
            if( a2b_mode < A2B_MODE_MAX )
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
                Setting_Set(SETID_A2B_MODE, (void *)&a2b_mode);
                //SystemDrv_SetA2BMode(a2b_mode);
                SettingSrv_BookkeepingEx();
            }
            else
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
                BRINGUP_printf("\n\r Unknown a2b_mode -> : %d\n\r", a2b_mode);
            }
        }
        else
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
        }
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_POWER_MODE:
    {
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        if( p_req->which_data == Proto_AseFep_Req_reqPowerMode_tag )
        {
            if( p_req->data.reqPowerMode.mode == Proto_SoundWall_PowerMode_Mode_STANDBY )
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
            }
            else if( p_req->data.reqPowerMode.mode == Proto_SoundWall_PowerMode_Mode_WORKING )
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
                if( SystemDrv_GetSystemStatus() == SYSTEM_STATUS_STANDBY )
                {
                    SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
                }
            }
            else
            {
                p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
                BRINGUP_printf("\n\r Unknown power mode  -> : %d\n\r", p_req->data.reqPowerMode.mode);
            }
        }
        else
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
        }
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_TEST_TONE:
    {
        uint32_t node, spk_tile;
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        if( p_req->which_data == Proto_AseFep_Req_reqTestTone_tag )
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
            node = p_req->data.reqTestTone.nodeIndex;
            spk_tile = p_req->data.reqTestTone.speakerTile;
            if( spk_tile > 4 )
                spk_tile = 0;
            if( node == 0 )
            {   // master
                MainAppCtlEvt ctl_evt;
                ctl_evt.value = spk_tile;
                MainApp_TestToneCtl(me, &ctl_evt);
            }
            else if( node < SystemDrv_GetTotalNodes() )
            {
                // fix me later
                ALWAYS_printf("\n\r Test tone by A2B is not ready.");
            }
            else
            {   // index ERROR
                p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
            }
        }
        else
        {
            p_resp_evt->status = Proto_Core_GenericResponse_Status_ERROR;
        }
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_GAIN_AND_DELAY:
    {   // TODO: implement the action
        Proto_SoundWall_GainAndDelay *p_gain_and_delay;
        
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;

        p_gain_and_delay = (Proto_SoundWall_GainAndDelay *)(&(p_req->data.reqGainAndDelay));
        if( p_gain_and_delay->nodeIndex == 0 )  // for master tile
        {
#ifdef HAS_SOUNDMODE_UPDATE
            AudioDrv_Mute(AUDIO_AMP_MUTE, TRUE);
            amp_demute_timeout = 100;
            Adau1452Drv_UpdateGainAndDelay(p_gain_and_delay);
#endif
            p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
            SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        }
        else
        {
        }
        break;
    }
    /*
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_DRIVER_GAIN:
    {   // TODO: implement the action
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
    case Proto_AseFep_ReqResp_SOUNDWALL_SET_BASS_AND_ROOMEQ:
    {   // TODO: implement the action
        p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
        p_resp_evt->id = p_req->id;
        p_resp_evt->type = p_req->type;
        p_resp_evt->status = Proto_Core_GenericResponse_Status_DONE;
        SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
        break;
    }
*/    default:
        TP_PRINTF("\n\rMainApp : Unknown ase request.\n\r");
        break;
    }
}

static void MainApp_I2cSlaveEvent(cMainApp * const me, QEvt const * const e)
{
    I2cSlaveRxEvt* pI2cEvt = (I2cSlaveRxEvt*)e;
    uint8_t *p_u8;

    BRINGUP_printf("\n\rI2C cmd=%d.", pI2cEvt->cmd);

    p_u8 = (uint8_t *)pI2cEvt->p_data;

    switch(pI2cEvt->cmd)
    {
    case I2C_WRITE_CMD_ENTER_DFU:
        MainApp_EnterDfu();
        break;
    case I2C_WRITE_CMD_STANDBY:
        SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
        break;
    case I2C_WRITE_CMD_MUTE_AMP:
        AudioSrv_SendMuteReq((QActive*)me, AUDIO_AMP_MUTE, (bool)(*p_u8));
        break;
    case I2C_WRITE_CMD_TEST_TONE:
    {
#ifdef HAS_AUDIO_MUTE_CHANNEL
        AudioMuteChannelReqEvt* pMuteReqEvt = Q_NEW(AudioMuteChannelReqEvt, AUDIO_MUTE_CHANNEL_REQ_SIG);
        pMuteReqEvt->channel_mask = *p_u8;
        SendToServer(AUDIO_SRV_ID,(QEvt*)pMuteReqEvt);
#endif
        break;
    }
    case I2C_WRITE_CMD_DSP_DELAY:
        break;
    case I2C_WRITE_CMD_DSP_GAIN:
        break;
    case I2C_WRITE_CMD_DSP_ROOMEQ:
        break;
    case I2C_WRITE_CMD_DSP_UPDATE:
        break;
    default:
        ALWAYS_printf("\n\rUnknow I2C command.");
        break;
    }
}

static void MainApp_PowerupInit(cMainApp * const me)
{
    eAudioChannel startup_source;
    uint32_t s_n;

    // show dsp version here
    if( dsp_version_show )
    {
        uint32_t dsp_ver;
        char ver_msg[8]="x.x.x";

        // store the dsp/btl/app version to setting server
        dsp_ver = BOOTLOADER_VERSION1 * 100 + BOOTLOADER_VERSION2 * 10 + BOOTLOADER_VERSION3;
        Setting_Set(SETID_BTL_VER, (void *)&dsp_ver);
        dsp_ver = APPLICATION_VERSION1 * 100 + APPLICATION_VERSION2 * 10 + APPLICATION_VERSION3;
        Setting_Set(SETID_APP_VER, (void *)&dsp_ver);
        dsp_ver = SystemDrv_GetDspVersion();
        dsp_ver %= 1000;
        Setting_Set(SETID_DSP_VER, (void *)&dsp_ver);

        ver_msg[0] = dsp_ver / 100 + '0';
        dsp_ver %= 100;
        ver_msg[2] = dsp_ver / 10 + '0';
        dsp_ver %= 10;
        ver_msg[4] = dsp_ver + '0';
        BRINGUP_printf("\n\r DSP : V%s.\n\r", ver_msg);
        dsp_version_show = FALSE;
    }

    if( hw_ver_show )
    {
		char hw_msg[][8]={"Unknown", "ES1", "ES2", "ES3", "EVT1", "EVT2", \
						  "DVT1", "DVT2", "PVT", "MP1", "MP2"};
		HwVersion_t hw_ver;
		hw_ver = SystemDrv_GetHWversion();
		BRINGUP_printf("\n\rHW : %s", hw_msg[hw_ver]);
        hw_ver_show = FALSE;
        // store the hw version to setting server
        Setting_Set(SETID_HW_VER, (void *)&hw_ver);
    }
    
#ifdef LED_ONLY_IN_ACTIVE_STATUS
    IoeLed_Init();
#endif

    // check serial no here
    s_n = *(uint32_t *)Setting_Get(SETID_TYPE_NO);
    if( s_n > MAINAPP_SN_MAX_TYPE_NO )
    {
        s_n = 0;
        Setting_Set(SETID_TYPE_NO, (void *)&s_n);
    }
    s_n = *(uint32_t *)Setting_Get(SETID_ITEM_NO);
    if( s_n > MAINAPP_SN_MAX_ITEM_NO )
    {
        s_n = 0;
        Setting_Set(SETID_ITEM_NO, (void *)&s_n);
    }
    s_n = *(uint32_t *)Setting_Get(SETID_SERIAL_NO);
    if( s_n > MAINAPP_SN_MAX_SERIAL_NO )
    {
        s_n = 0;
        Setting_Set(SETID_SERIAL_NO, (void *)&s_n);
    }

    // enable auto standby when power up
    auto_standby_enable = TRUE;

    // startup source
    startup_source = *(eAudioChannel *)Setting_Get(SETID_AUDIO_SOURCE);
    if( A2B_MODE_SLAVE == SystemDrv_GetA2BMode() )
    {
        current_source = MAINAPP_SOURCE_A2B;
        if( startup_source != MAINAPP_SOURCE_A2B )
        {
            Setting_Set(SETID_AUDIO_SOURCE, (void *)(&current_source));
        }
    }
    else
    {
        if( wakeup_source != AUDIO_CHANNEL_INVALID )
        {  
            current_source = wakeup_source;
            wakeup_source = AUDIO_CHANNEL_INVALID;
            if( startup_source != current_source )
            {
                Setting_Set(SETID_AUDIO_SOURCE, (void *)(&current_source));
            }
        }
        else
        {
            if( (startup_source == MAINAPP_SOURCE_AUX) || (startup_source == MAINAPP_SOURCE_OPTICAL) )
            {
                current_source = startup_source;
            }
            else
            {
                current_source = source_list[MAINAPP_SOURCE_CH_MAX];    // set to default
                Setting_Set(SETID_AUDIO_SOURCE, (void *)(&current_source));
            }
        }
    }
    
    MainApp_SwitchToSource(me, current_source);
    if( SystemDrv_A2BModeIsMaster() )
    {
        SystemDrv_SetTotalNodes(1);
        a2b_restart_timeout = A2B_POWERUP_INIT_TIMEOUT;
    }
    // ignore the hijack when powering up...
    // base on the audio server & mainapp server timeout is the same(10ms),
    ignore_source_hijack_timeout = 150; // unit = MAIN_APP_TIMEOUT_IN_MS = 20ms

	codec_demute_timeout = 100;	// unmute the codec
}

static bool MainApp_ActiveTimeoutSig(cMainApp * const me)
{
    bool enter_standby = FALSE;
    
#ifdef KEY_FOR_DEBUG
    MainApp_KeyScan(me);
#endif
    // source auto switch
    MainApp_HijackService(me);
    if( a2b_restart_timeout > 0 )
    {
        a2b_restart_timeout -= MAIN_APP_TIMEOUT_IN_MS;
        if( a2b_restart_timeout <= 0 )
        {
            CommonReqEvt *p_a2b_evt;
            p_a2b_evt = Q_NEW(CommonReqEvt, ALLPLAY_RESET_SIG);
            SendToServer(A2B_SRV_ID, (QEvt *)p_a2b_evt);
        }
    }
    if( codec_demute_timeout > 0 )
    {
        codec_demute_timeout -= MAIN_APP_TIMEOUT_IN_MS;
        if( codec_demute_timeout <= 0 )
        {
            AudioSrv_SendMuteReq((QActive*)me, AUDIO_DSP_DACOUT_MUTE, FALSE);
        }
    }
    if( amp_demute_timeout )
    {
        amp_demute_timeout -= MAIN_APP_TIMEOUT_IN_MS;
        if( amp_demute_timeout <= 0 )
        {
            AudioSrv_SendMuteReq((QActive*)me, AUDIO_AMP_MUTE, FALSE);
        }
    }
    if( SYSTEM_STATUS_AUTO_STANDBY == SystemDrv_GetSystemStatus() )
    {
        if( auto_standby_enable )
        {
//            enter_standby = TRUE;
//            BRINGUP_printf("\n\rAuto Standby.");
            SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
        }
        else
        {   // ignore the auto-standby and resume the system status to 'WORKING'
            SystemDrv_SetSystemStatus(SYSTEM_STATUS_WORKING);
        }
    }

    if( SYSTEM_STATUS_STANDBY == SystemDrv_GetSystemStatus() )
        enter_standby = TRUE;

    return enter_standby;
}

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MainApp);

#ifdef KEY_FOR_DEBUG
    MainApp_DebugKey_Init();
#endif

     /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), MAINAPP_TIMEOUT_SIG,
                            MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);

#ifdef DEFERRED_REQ_QUE
    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
#endif

   /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif
}

void MainApp_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Application_Xtor((cApplication*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const *const e)
{
    SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
//    SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
    return Q_TRAN(&MainApp_DeActive);
}

static QState MainApp_PoweringUp(cMainApp * const me, QEvt const * const e)
{  
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
            MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            MainApp_SwitchMode(MainApp, NORMAL_MODE);
            return Q_TRAN(&MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Active state  - super state for "normal" behaviour */

static QState MainApp_Active(cMainApp * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
#ifdef DEFERRED_REQ_QUE
            while (QActive_recall((QActive*)me, &deferredReqQue))
            {
              // check if we have events(key_state_sig) in deferred queue
            } 
#endif
			codec_demute_timeout = 0;
            amp_demute_timeout = 0;
            break;
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            bool enter_standby;
            enter_standby = MainApp_ActiveTimeoutSig(me);
            if( enter_standby )
            {
                AudioDrv_Mute(AUDIO_AMP_MUTE, TRUE);
                ALWAYS_printf("\n\r System is off.\n\r");
                IoeLed_Standby();
                return Q_TRAN(&MainApp_DeActive);
            }
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            break;
        }
/*************** tp monitor control signal start here ******************/
        case DISPLAY_DEBUG_REQ_SIG:
            MainApp_Version2TPMonitor();
            break;
        case MAINAPP_PRODUCT_TEST_CTL_SIG:
        {   // when enable production test, disable auto-standby
            MainAppCtlEvt *p_evt=(MainAppCtlEvt *)e;
            if( p_evt->value )
                auto_standby_enable = FALSE;
            else
                auto_standby_enable = TRUE;
            break;
        }
        case MAINAPP_VOLUME_CTL_SIG:
            MainApp_VolumeCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_GET_VER_SIG:
            MainApp_VerInfoCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_CH_MUTE_SIG:
            MainApp_ChMuteCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_LED_CTL_SIG:
            MainApp_LedCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_SOURCE_CTL_SIG:
            MainApp_SourceCtlSig(me, (MainAppCtlEvt *)e);
            break;
        case MAINAPP_BYPASS_CTL_SIG:
            MainApp_BypassCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_DFU_REQ_SIG:
            MainApp_EnterDfu();
            break;
        case MAINAPP_A2B_MASTER_CTL_SIG:
            MainApp_A2BMasterCtlSig((MainAppCtlEvt *)e);
            break;
        case MAINAPP_NTC_INFO_CTL_SIG:
            MainApp_GetNTCinfo();
            break;
        case MAINAPP_MUTE_AMP_CTL_SIG:
            MainApp_MuteAmpCtl(me, (MainAppCtlEvt *)e);
            break;
        case MAINAPP_SYSTEM_RESET_CTL_SIG:
            ALWAYS_printf("\n\r System RESET.\n\r");
            BSP_BlockingDelayMs(10);
            BSP_SoftReboot();
            break;
        case MAINAPP_SYSTEM_STATUS_CTL_SIG:
        {
            MainAppCtlEvt *p_evt=(MainAppCtlEvt *)e;
            if( ! p_evt->value )
            {
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_STANDBY);
            }
            break;
        }
        case MAINAPP_TEST_TONE_CTL_SIG:
            MainApp_TestToneCtl(me, (MainAppCtlEvt *)e);
            break;
        case MAINAPP_WRITE_DSP_PARAM_CTL_SIG:
            MainApp_WriteDspParamCtl(me, (MainAppCtlEvt *)e);
            break;
        case MAINAPP_WRITE_TYPE_NO_CTL_SIG:
            MainApp_WriteTypeNoCtl((MainAppCtlEvt *)e);
            break;
        case MAINAPP_WRITE_ITEM_NO_CTL_SIG:
            MainApp_WriteItemNoCtl((MainAppCtlEvt *)e);
            break;
        case MAINAPP_WRITE_SERIAL_NO_CTL_SIG:
            MainApp_WriteSerialNoCtl((MainAppCtlEvt *)e);
            break;
        case MAINAPP_GET_SERIAL_NO_CTL_SIG:
            MainApp_GetSerialNoCtl();
            break;
/*************** tp monitor control signal end here ******************/

/*************** Ase request signal start here ******************/
        case ASE_TK_REQ_SIG:
        {
            MainApp_AseReqHandler(me, e);
            break;
        }
/*************** Ase request end here ******************/
        case I2C_SLAVE_REQ_SIG:
            MainApp_I2cSlaveEvent(me, e);
            break;
        case KEY_STATE_SIG:
            MainApp_ParseKeyEvent(me, e);
            break;
        case SYSTEM_MODE_RESP_SIG:
        {
            ALWAYS_printf("\n\r System is on.\n\r");
            MainApp_PowerupInit(me);
            AudioSrv_SendMuteReq((QActive*)me, AUDIO_AMP_MUTE, FALSE);
            SystemDrv_SetSystemStatus(SYSTEM_STATUS_WORKING);
#ifdef INITIATIVE_POWER_MODE_TO_EZ3
            // send power mode to EZ3
            FepRespAseEvt *p_resp_evt;
            p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
            p_resp_evt->id = 0;
            p_resp_evt->type = Proto_AseFep_ReqResp_SOUNDWALL_GET_POWER_MODE;
            p_resp_evt->status = (Proto_Core_GenericResponse_Status)Proto_SoundWall_PowerMode_Mode_WORKING;
            SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
#endif            
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
          break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState MainApp_DeActive(cMainApp * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            MainApp_SwitchMode(MainApp, SLEEP_MODE);    // next status : SYSTEM_MODE_RESP_SIG
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
#ifdef KEY_FOR_DEBUG
            MainApp_KeyScan(me);
#endif
            MainApp_CheckAutoWakeUp(me);
            if( SYSTEM_STATUS_POWERING_UP == SystemDrv_GetSystemStatus() )
            {
                return Q_TRAN(&MainApp_PoweringUp);     
            }
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            if( firmware_version_show )
            {
                firmware_version_show = FALSE;
                MainApp_ShowVersion();
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
            }
            if( SystemDrv_GetSystemStatus() != SYSTEM_STATUS_STANDBY )
            {
                return Q_TRAN(&MainApp_PoweringUp);     
            }
            else
            {
#ifdef INITIATIVE_POWER_MODE_TO_EZ3
                // send power mode to EZ3
                FepRespAseEvt *p_resp_evt;
                p_resp_evt = Q_NEW(FepRespAseEvt, ASE_TK_RESP_SIG);
                p_resp_evt->id = 0;
                p_resp_evt->type = Proto_AseFep_ReqResp_SOUNDWALL_GET_POWER_MODE;
                p_resp_evt->status = (Proto_Core_GenericResponse_Status)Proto_SoundWall_PowerMode_Mode_STANDBY;
                SendToServer(USB_SRV_ID, (QEvt *)p_resp_evt);
#endif                
                return Q_HANDLED();
            }
        }
        case MAINAPP_SYSTEM_STATUS_CTL_SIG:
        {
            MainAppCtlEvt *p_evt=(MainAppCtlEvt *)e;
            if( p_evt->value )
            {   // wake up by TP monitor
                SystemDrv_SetSystemStatus(SYSTEM_STATUS_POWERING_UP);
            }
            break;
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


static void MainApp_SwitchMode(cMainApp* me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e)
{
}


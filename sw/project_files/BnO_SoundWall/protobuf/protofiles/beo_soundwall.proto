// @file beo_sound_wall.proto

// @mainpage Introduction
// Protocol Buffers messages for the USB serial interface on the Bang & Olufsen Sound Wall product. Messages are 
// encapsulated in the SoundWallMessage definition and sent over the USB serial interface using the Yet Another HDLC 
// (yahdlc) implementation: https://github.com/bang-olufsen/yahdlc
//
// The acknowledgement of DATA frames must be done as soon as the integrity of the message has been checked to have the
// highest possible throughput. New requests, events and commands may be sent after the message acknowledgement. The
// sequence number must be used to handle retransmission and duplicated messages.
//
// All communication to the Sound Wall is done though the master tile which is tile with audio input (e.g. PowerLink or 
// TosLink). In case of any additional tiles the master tile will act as the master and control these by e.g. forwarding 
// commands using A2B as seen below.
//
// @startuml {SoundWallSelectSoundModeReq.png} Basic request flow width=10cm
// hide footbox
// EZ3 -> "SW1 (master)": SoundWallSelectSoundModeReq
// "SW1 (master)" -> SW2: Set sound mode
// "SW1 (master)" -> SW3: Set sound mode
// "SW1 (master)" -> EZ3: SoundWallSelectSoundModeResp
// @enduml
/************************************************************************/
// @brief Data message for debugging and production test

package Proto.SoundWallMessage;

message SoundWallData {
  optional bytes data = 1;
}

// @brief Logging information from Sound Wall
message SoundWallLog {
  // Severity of the incident causing the log entry to be written to the product log
  enum Severity {
    // Log debugging statements that are not part of the release build
    DEBUG = 0;
    // Log internal tracing inside components
    INFO = 1;
    // Log internal tracing between components
    NOTICE = 2;
    // Log additional information about warnings
    WARNING = 3;
    // Log additional information about error conditions
    ERROR = 4;
  }
  // Severity of the incident causing the log entry to be written
  optional Severity severity = 1;
  // Human readable text describing the incident
  optional string text = 2;
  // File name of the source code file where the log entry is generated
  optional string file = 3;
  // Line number in the source code file where the log entry is generated
  optional uint32 line = 4;
}
/************************************************************************/
// @brief Request statistics from the Sound Wall
message RequestStatistics {
}

// @brief Response to ResponseStatistics
message ResponseStatistics {
  message KeyValuePair {
    // Unique identifier of the value
    optional string key = 1;
    // Counter, timer or other statistical information
    optional string value = 2;
  }
  repeated KeyValuePair keyValue = 1;
}
/************************************************************************/
// @brief Request version information from the Sound Wall
message RequestVersionInfo {
    // node Index 
  optional uint32 nodeIndex = 1;
}

// @brief Response to SoundWallVersionInfoReq with version info
message ResponseVersionInfo {
  message Module {
    optional string name = 1;
    optional string hardware = 2;
    optional string bootloader = 3;
    optional string application = 4;
    optional string configuration = 5;
  }
  // Contains version information about the connected hardware, it may consis of multiple modules.
  repeated Module module = 1;
  optional uint32 nodeIndex = 2;
}
/************************************************************************/
message SoundMode {
    enum Mode {
        UNDEFINED = 0;
        MODE1 = 1;
        MODE2 = 2;
        MODE3 = 3;
        MODE4 = 4;
    }
    optional Mode mode = 1;
}


/************************************************************************/
// @brief Request the current sound mode from the Sound Wall
message RequestActiveSoundMode {
    optional uint32 nodeIndex = 1;
}

// @brief Response to SoundWallActiveSoundModeReq with current sound mode 
message ResponseActiveSoundMode {
    optional SoundMode soundMode = 1;
    optional uint32 nodeIndex = 2;
}
/************************************************************************/
// @brief Request to set the specified sound mode
message RequestSelectSoundMode {
    optional SoundMode soundMode = 1;
    optional uint32 nodeIndex = 2;
}

/************************************************************************/
// @brief Request to create a sound mode
// new struct : change the 'optional' to 'required'
//              add speakerIndex.
message RequestCreateSoundMode {
    required SoundMode soundmode = 1;
    required double leftGain = 2;   // 'float' is enough?
    required double rightGain = 3;  // 'float' is enough?
    required uint32 leftDelay = 4;  // unit : ms
    required uint32 rightDelay = 5; // unit : ms
    required uint32 bassLevel = 6;  // level index;
    required uint32 nodeIndex = 7;  // 0:MasterTile, 1...8 : slaveTile node index
    required uint32 speakerIndex = 8;   // speakerTile[1..4]
    // TODO: Add remaining definitions
}

///// the following is the old struct
//message RequestCreateSoundMode {
//    optional SoundMode soundmode = 1;
//    optional double leftGain = 2;
//    optional double rightGain = 3;
//    optional double leftDelay = 4;
//    optional double rightDelay = 5;
//    optional double bassLevel = 6;
//    optional uint32 nodeIndex = 7;
    // TODO: Add remaining definitions
//}


/************************************************************************/
message A2BMode{
    enum Mode {
        A2B_STANDALONE = 0;         // This mode is standalone that the soundwall will not connect to slave or as a master
        A2B_MASTER = 1;                   // This mode is setting the soundwall as masternode.
        A2B_SLAVE = 2;                      // This mode is setting the soundwall as slavenode.
    }
    optional Mode mode = 1;
}

message RequestSetA2Bmode {
    optional A2BMode a2bmode =1;
}

message ResponseGetA2Bmode{
    optional A2BMode a2bmode =1;
}

message ResponseGetA2BnumberActiveNode{
    optional uint32 activeNodeNumber =1;
}

message EventNumberActiveNode{
    optional uint32 activeNodeNumber =1;
}
//*******************************************************************
message AudioInput{
    enum Input {
        LINE = 0;
        SPDIF = 1;
        A2B = 2;
    }
    optional Input input =1;
}


// @brief Request to set audio input.
message RequestSetAudioInput {
    optional AudioInput audioInput =1;
}

message ResponseGetAudioInput{
    optional AudioInput audioInput =1;
}

/************************************************************************/
message ResponseGetNTCvalue {
    optional uint32 nodeIndex = 1;
    optional uint32 ntcValue_AMP = 2;   // amplifier temperature
    optional uint32 ntcValue_DSP = 3;   // dsp temperature
    optional uint32 ntcValue_PSU = 4;   // power adaptor temperature
}

//*******************************************************************

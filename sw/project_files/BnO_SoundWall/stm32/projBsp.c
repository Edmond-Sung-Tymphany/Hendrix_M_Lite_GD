/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Public project Bsp interfaces
                  -------------------------

                  SW Module Document




@file        projBsp.h
@brief       This file implements the public project bsp interfaces which declared
             at projBsp.h
@author      Bob.Xu
@date        2014-07-14
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-12     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "stm32f0xx.h"

#include "bsp.h"
#include "projBsp.h"

#ifdef PROJECT_SPEC_ASSERT_HANDLER
void ProjBsp_AssertHandler(char const * const file, int line)
{
#ifndef NDEBUG
    tIoeLedDevice *pIoeLedConfig = (tIoeLedDevice*) getDevicebyIdAndType(LED_DEV_ID, I2C_DEV_TYPE, NULL);      
    cIoExpanderDrv ioeDrv= {0};
    
    //turn off all LED
    IoExpanderDrv_Ctor(&ioeDrv, (const tDevice*)pIoeLedConfig->i2cDeviceConf);
    const tIoExpanderLedMap *ledMap= pIoeLedConfig->pIoExpanderLedMap;
    int i;
    for(i=0 ; i<pIoeLedConfig->ledNum ; i++)
    {		
        IoExpanderDrv_SetBrightness(&ioeDrv, ledMap[i].port, ledMap[i].pin, 0);
    }
    
    //Blink All LED
    IoExpanderDrv_AutoBlink(&ioeDrv, IOE_AUTO_PATT_ERROR);
#endif    
}
#endif

void ProjBsp_SysClkUpdate(void)
{
#ifdef EXTERNAL_HIGH_SPEED_CLOCK
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
  
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
   
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
    StartUpCounter++;  
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
  {
    HSEStatus = (uint32_t)0x01;
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 
#ifdef SYSCLK_RUN_AT_32M      
    /* HCLK Vs. SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;

    /* PCLK Vs. HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;
#else
    /* HCLK Vs. SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV4;

    /* PCLK Vs. HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;
#endif
    /* PLL configuration = HSE(12MHz) * 4 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));

    /* config sysclk = 32M */
	RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL8);
	RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV1_DIV3);

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
    {
    }
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
#endif
}

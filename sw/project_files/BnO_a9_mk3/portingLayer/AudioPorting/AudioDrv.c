/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Audio Driver have three layer DISABLE operation.
1. SW Mute     -> FepAseCommand_Command_MUTE, FepAseCommand_Command_UNMUTE
2. SW Shutdown -> AseFepEvent_Event_SYSTEM_STATUS_STANDBY, AseFepEvent_Event_SYSTEM_STATUS_ON
3. HW Shutdown -> Overheat occurs/recover

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "PowerDrv_v2.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AseTkSrv.h"
#include "I2CDrv.h"
#include "ADCDrv.h"
#include "GPIODrv.h"
#include "DspDrv1451.h"
#include "timer.h"
#include "AudioDrv.config"
#include "AudioSrv.config"
#include "pcm1862Drv.h"
#include "pcm1690Drv.h"


/***********************************************
 * Type
 ***********************************************/
typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},
    //{DSP_CAL_GAIN1_ID,    SETID_DSP_CAL_GAIN1_WF},
    //{DSP_CAL_GAIN2_ID,    SETID_DSP_CAL_GAIN2_MID_A},
    ///{DSP_CAL_GAIN3_ID,    SETID_DSP_CAL_GAIN3_MID_B},
    //{DSP_CAL_GAIN4_ID,    SETID_DSP_CAL_GAIN4_TW},
    
};


/***********************************************
 * Global Variable
 ***********************************************/
static cI2CDrv      dspI2cDrv;
static cDSPDrv1451  dspAdau1451Drv;

static cADCDrv      audioAdcDrv;

static cI2CDrv          adcPcm1862i2cObj;
static cAdcDrv_pcm1862  adcPcm1862;

static cI2CDrv          dacPcm1690i2cObj;
static cPcm1690Drv      dacPcm1690;

static cGpioDrv audioGpioDrv;

static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static bool audioOverheat= FALSE;

//Aux in detect
static float auxin_input_db_smooth= -90.0;
static bool hasMusicStream_DebNew= FALSE;
static bool hasMusicStream_DebPre= FALSE;
static uint32 auxin_detect_debounce_msec= 0;

//Optical detect
static bool hasMusicStreamDetByMcuPin_DebNew= FALSE;
static bool hasMusicStreamDetByMcuPin_DebPre= FALSE;
static uint32 auxin_detectDetByMcuPin_debounce_msec= 0;

//Optical detect
static float optical_input_db_smooth= -90.0;
static bool hasOpticalMusicStream_DebNew= FALSE;
static bool hasOpticalMusicStream_DebPre= FALSE;
static uint32 optical_detect_debounce_msec= 0;



#ifdef HAS_DSP_TUNING_DETECT
static bool dspTuneCurr= FALSE;
static bool dspTuneTmp= FALSE;
static uint32 debounceTick= 0; //the time to hold the same DspTune value
#endif

static uint16        tempWfAmp1    = 0;
static uint16        tempWfAmp2    = 0;
static uint16        tempWfSpk     = 0;
static uint16        tempMidSpkA   = 0;
static uint16        tempMidSpkB   = 0;
static uint16        tempTwAmp     = 0;

static eTempLevel    tempLevelWfAmp1  = TL_NORMAL;
static eTempLevel    tempLevelWfAmp2  = TL_NORMAL;
static eTempLevel    tempLevelWfSpk   = TL_NORMAL;
static eTempLevel    tempLevelMidSpkA = TL_NORMAL;
static eTempLevel    tempLevelMidSpkB = TL_NORMAL;
static eTempLevel    tempLevelTwAmp   = TL_NORMAL;

static eTempLevel    tempLevelAudio   = TL_NORMAL;


/* fading volume */
static uint16 volFadeTimerId= 0;
static tVolFadeParam volFadeParam= {0};
static uint32 volFadeReqId = 0;



/***********************************************
 * Init State
 ***********************************************/
typedef enum 
{
    AUDIO_DRV_INIT_STATE_START,
    AUDIO_DRV_INIT_STATE_POWER= AUDIO_DRV_INIT_STATE_START,
    AUDIO_DRV_INIT_STATE_DSP,
    AUDIO_DRV_INIT_STATE_DAC,
    AUDIO_DRV_INIT_STATE_OTHER,
    AUDIO_DRV_INIT_STATE_MAX
}eAudioDrvInitState;


/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds (after ASE-TK MCLK is ready),
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);
    
    //Init State Machine
    me->initState= AUDIO_DRV_INIT_STATE_START;
    me->nextDelayTime= 0;
    
    audioOverheat= FALSE;
    
#ifdef HAS_DSP_TUNING_DETECT
    dspTuneCurr= FALSE;
    dspTuneTmp= FALSE;
    debounceTick= 0;
#endif    

    //Initialize ADC pins
    audioAdcDrv.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(audioAdcDrv.ADCConfig);
    ADCDrv_Ctor(&audioAdcDrv, audioAdcDrv.ADCConfig);
    ADCDrv_StartScanning(&audioAdcDrv);    
    
    //Initialize Audio GPIO pins
    audioGpioDrv.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(audioGpioDrv.gpioConfig);
    GpioDrv_Ctor(&audioGpioDrv, audioGpioDrv.gpioConfig);
    
    //Initialize DSP
    dspI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cDrv.pConfig);
    DSPDrv1451_Ctor(&dspAdau1451Drv, &dspI2cDrv);
            
    //Volume Fading
    memset(&volFadeParam, 0, sizeof(volFadeParam));
    musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
    bool musicDet= FALSE;
    //Setting_Set(SETID_MUSIC_DET, &musicDet);
    volFadeParam.isFadingInProg = FALSE;
    uint8 defaultVol = 0;
    Setting_Set(SETID_VOLUME, &defaultVol);
}


void AudioDrv_Xtor(cAudioDrv *me)
{    
    //Disable power
    AUDIO_DSP_DAC_3V3_OFF(audioGpioDrv);
    AUDIO_ADC_3V3_OFF(audioGpioDrv); 
    AUDIO_SMPS_OFF(audioGpioDrv);
    
    //Xtor device
    Pcm1690Drv_Xtor(&dacPcm1690);
    AdcDrv_pcm1862_Xtor(&adcPcm1862);
    DSPDrv1451_Xtor(&dspAdau1451Drv);
      
//    Setting_Reset(SETID_TEMP_LEVEL_AUDIO);
//    Setting_Reset(SETID_TEMP_WF_AMP_1);
//    Setting_Reset(SETID_TEMP_WF_AMP_2);
//    Setting_Reset(SETID_TEMP_WF_SPK);
//    Setting_Reset(SETID_TEMP_MID_SPK_A);
//    Setting_Reset(SETID_TEMP_MID_SPK_B);
//    Setting_Reset(SETID_TEMP_TW_AMP);

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(me->drvIsReady)
    {
        return TRUE;
    }
    
    if(me->nextDelayTime == 0)
    {
        switch(me->initState)
        {
        case AUDIO_DRV_INIT_STATE_POWER:
            TP_PRINTF("Audio Init State %d - AUDIO_DRV_INIT_STATE_POWER\r\n", me->initState);
            AUDIO_DSP_DAC_3V3_ON(audioGpioDrv);
            AUDIO_ADC_3V3_ON(audioGpioDrv);           
            
            dacPcm1690i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_DAC_DEV_ID, NULL);
            ASSERT(dacPcm1690i2cObj.pConfig);
            Pcm1690Drv_Ctor(&dacPcm1690, &dacPcm1690i2cObj);            
            
            me->nextDelayTime= 50; //delay then go to next state
            me->initState++;
            break;
            
        case AUDIO_DRV_INIT_STATE_DSP:
            me->nextDelayTime= DSPDrv1451_Init(&dspAdau1451Drv);
            if(me->nextDelayTime==0) //dsp init finish
            {                
                //Read DSP Version
                float fVer= DSPDrv1451_GetDspVer(&dspAdau1451Drv);
                char dspVersion[DSP_VERSION_LENGTH]= {0};
                snprintf(dspVersion, sizeof(dspVersion), "%0.1f", fVer);
                Setting_Set(SETID_DSP_VER, dspVersion);
                
                //Set DSP channel
                DSPDrv1451_SetInputChannel(&dspAdau1451Drv, AUDIO_CHANNEL_I2S_1); //ASE-TK
                            
                /* Set default volume
                 * Note ASE-TK may output noise when bootup, thus we must set ZERO volume before AES-TK boot up.
                 */
                DSPDrv1451_SetVol(&dspAdau1451Drv, /*vol*/0);                
            
                me->initState++;
            }
            break;
            
        case AUDIO_DRV_INIT_STATE_DAC: //Initialize DAC: PCM1690
            me->nextDelayTime= Pcm1690Drv_Init(&dacPcm1690);
            if(me->nextDelayTime==0) //DAC init finish
            {
                me->initState++;
            }
            break;
            
        case AUDIO_DRV_INIT_STATE_OTHER:            
            //Initialize ADC: PCM1862
            adcPcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_ADC_DEV_ID, NULL);
            ASSERT(adcPcm1862i2cObj.pConfig);
            AdcDrv_pcm1862_Ctor(&adcPcm1862, &adcPcm1862i2cObj);
            AdcDrv_pcm1862_Init(&adcPcm1862);
            AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_DIFF_INPUT1);
            AdcDrv_pcm1862_SetPGA(&adcPcm1862, PCM1862_PGA_6dB);
            AdcDrv_pcm1862_enableAGC(&adcPcm1862, /*enable:*/FALSE); //AGC feature have problem on MOFA, should disable it            
            
            //Init finish
            AUDIO_DAC_IN_MUTE(audioGpioDrv);
            AUDIO_DAC_OUT_MUTE(audioGpioDrv);
            AUDIO_SMPS_ON(audioGpioDrv);        
            me->drvIsReady = TRUE;
            
            /* set linein sensitivity default gain (medium) 6dB*/
            uint8 sensitivityLineIn = (uint8)AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM;
            Setting_Set(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
            AudioDrv_SetAudio(me, AUDIO_LINEIN_SENSITIVITY_SETT_ID, TRUE, (uint32)AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM, /*NOT USED*/0);                
            break;
            
        default:
            ASSERT(0);
            break;
        }
    }
    else if(me->nextDelayTime > AUDIO_SRV_TIMEOUT_IN_MS)
    {
        me->nextDelayTime-= AUDIO_SRV_TIMEOUT_IN_MS;
        TP_PRINTF(".");
    }
    else // me->nextDelayTime <= AUDIO_SRV_TIMEOUT_IN_MS
    {
        me->nextDelayTime= 0;
    }
    
    return (me->drvIsReady);
}


void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetInputChannel(&dspAdau1451Drv, audioChannel);
}


void AudioDrv_dumpAmpReg(void)
{
//    AudioAmpDrv_dumpReg(&audioAmpWoofer1Drv, "ampWoofer1");
//    AudioAmpDrv_dumpReg(&audioAmpWoofer2Drv, "ampWoofer2"); 
//    AudioAmpDrv_dumpReg(&audioAmpMidDrv,     "ampMid"); 
//    AudioAmpDrv_dumpReg(&audioAmpTweeterDrv, "ampTweeter"); 
}

void AudioDrv_CheckAuxMusicStreamStatus(void)
{
   if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
    {
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
        bool hasMusicStream= *(bool*)Setting_Get(SETID_AUXIN_PLAYING);

//        uint32 sensitivityLineIn = Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED; //type: eLineinSensitivity
//        sensitivityLineIn= *(uint32*)Setting_GetEx(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
//        int8 sensitivityThresholdDb;
//        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_HIGH)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_HIGH_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_MEDIUM)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_MID_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_LOW)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_LOW_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
//        {
//            hasMusicStream_DebNew= FALSE;
//            hasMusicStream_DebPre= FALSE;
//            auxin_detect_debounce_msec= 0;
//        }
//        else
//        {
//            ASSERT(0);
//        }
          int8 sensitivityThresholdDb = AUDIO_AUXIN_DETECT_MID_DB; // for bring up only


          float auxin_input_db= DSPDrv1451_ReadInputVolume(&dspAdau1451Drv);
//          printf("\r\n<<< auxin_input_db : [%d]", (int16)auxin_input_db);
//        hasMusicStream_DebNew= (auxin_input_db>=sensitivityThresholdDb)?TRUE:FALSE;

        /* Some music do not have constant volume and hard to pass debounce,
         * thus we get smooth volume then pass to debounce.
         */
        auxin_input_db_smooth= (auxin_input_db*AUDIO_AUXIN_DETECT_SMOOTH_RATE) + (auxin_input_db_smooth*(1-AUDIO_AUXIN_DETECT_SMOOTH_RATE));

        Setting_Set(SETID_AUDIO_AUXIN_IN_DB, &auxin_input_db_smooth);
        //printf("aux=%.1fdB, aux-smooth=%.1fdB, new=%d, pre=%d, curr=%d, time=%dms, threshold=%ddB[L%d]\r\n",
        //          auxin_input_db, auxin_input_db_smooth, hasMusicStream_DebNew,
        //          hasMusicStream_DebPre, hasMusicStream, auxin_detect_debounce_msec,
        //          sensitivityThresholdDb, sensitivityLineIn);
        hasMusicStream_DebNew= (auxin_input_db_smooth>=sensitivityThresholdDb)?TRUE:FALSE;
        /* to eliminate noise in aux, when jack is not plugged in*/
        int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET5);
        int8 det2 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET1);
        if (hasMusicStream_DebNew  && hasMusicStream && (!((!det1) && (!det2))))
        {
            hasMusicStream = FALSE;
            Setting_Set(SETID_MUSIC_SPDIF_DET, &hasMusicStream);
            AudioMusicDetectStateEvt* pAudioMusicStateEvt;
            pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
            pAudioMusicStateEvt->hasMusicStream = FALSE;
            pAudioMusicStateEvt->jackId = AUXIN_JACK;
            QF_PUBLISH(&pAudioMusicStateEvt->super, me);
            TP_PRINTF("\r\n\r\n*** Aux-in music states is %d as aux cable is not detected ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            hasMusicStream_DebNew = FALSE;
            return;
        }

//        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
//        {
//        }
        if(hasMusicStream_DebNew==hasMusicStream)
        {
            //Do not need debounce
            auxin_detect_debounce_msec= 0;
        }
        else if(hasMusicStream_DebNew!=hasMusicStream_DebPre)
        {
            //stop debounce
            auxin_detect_debounce_msec= 0;
            //TP_PRINTF("aux-in: debounce fail\r\n");
        }
        else
        {
            //start or continue debounce (new == pre == curr)
            if(auxin_detect_debounce_msec <= AUDIO_AUXIN_DETECT_PEROID_MSEC)
            {
                auxin_detect_debounce_msec+= AUDIO_SRV_TIMEOUT_IN_MS;
                //TP_PRINTF("aux: debouncing\r\n");
            }
            else
            {
                int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET5);
                int8 det2 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET1);

                //finish debounce
                hasMusicStream= hasMusicStream_DebNew;
                if ((!hasMusicStream) ||
                    (hasMusicStream  && ((!det1) && (!det2)) ))
                {
                Setting_Set(SETID_AUXIN_PLAYING, &hasMusicStream);
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = hasMusicStream;
                pAudioMusicStateEvt->jackId = AUXIN_JACK;
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("\r\n\r\n*** Aux-in music states is %d ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            }
        }
        }
        hasMusicStream_DebPre= hasMusicStream_DebNew;
    }

}

void AudioDrv_CheckOpticalMusicStreamStatus(void)
{
   if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
    {
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
        bool hasOpticalMusicStream= *(bool*)Setting_Get(SETID_MUSIC_SPDIF_DET);

//        uint32 sensitivityLineIn = Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED; //type: eLineinSensitivity
//        sensitivityLineIn= *(uint32*)Setting_GetEx(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
//        int8 sensitivityThresholdDb;
//        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_HIGH)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_HIGH_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_MEDIUM)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_MID_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_LOW)
//        {
//            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_LOW_DB;
//        }
//        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
//        {
//            hasOpticalMusicStream_DebNew= FALSE;
//            hasOpticalMusicStream_DebPre= FALSE;
//            optical_detect_debounce_msec= 0;
//        }
//        else
//        {
//            ASSERT(0);
//        }
        int8 sensitivityThresholdDb = AUDIO_AUXIN_DETECT_MID_DB;

        float optical_input_db= DSPDrv1451_ReadInputVolume2(&dspAdau1451Drv);
//        hasOpticalMusicStream_DebNew= (optical_input_db>=sensitivityThresholdDb)?TRUE:FALSE;

        /* Some music do not have constant volume and hard to pass debounce,
         * thus we get smooth volume then pass to debounce.
         */
//335
        optical_input_db_smooth= (optical_input_db*AUDIO_OPTICAL_DETECT_SMOOTH_RATE) + (optical_input_db_smooth*(1-AUDIO_OPTICAL_DETECT_SMOOTH_RATE));
        Setting_Set(SETID_AUDIO_OPTICAL_IN_DB, &optical_input_db_smooth);
        //printf("aux=%.1fdB, aux-smooth=%.1fdB, new=%d, pre=%d, curr=%d, time=%dms, threshold=%ddB[L%d]\r\n",
        //          auxin_input_db, auxin_input_db_smooth, hasMusicStream_DebNew,
        //          hasMusicStream_DebPre, hasMusicStream, auxin_detect_debounce_msec,
        //          sensitivityThresholdDb, sensitivityLineIn);
        hasOpticalMusicStream_DebNew= (optical_input_db_smooth>=sensitivityThresholdDb)?TRUE:FALSE;
//        printf("\r\n*** hasOpticalMusicStream_DebNew : [%d]", hasOpticalMusicStream_DebNew);

        /* fix for https://jira.bang-olufsen.dk/browse/ASEII-623
         when spdif out might bring noise to spdif in
         so we report optical signal loss if optical cable is not plugged*/
        int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET5);
        int8 det2 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET1);
        if (hasOpticalMusicStream_DebNew  && hasOpticalMusicStream && (!((!det1) && (det2))))
        {
            hasOpticalMusicStream = FALSE;
            Setting_Set(SETID_MUSIC_SPDIF_DET, &hasOpticalMusicStream);
            AudioMusicDetectStateEvt* pAudioMusicStateEvt;
            pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
            pAudioMusicStateEvt->hasMusicStream = FALSE;
            pAudioMusicStateEvt->jackId = SPDIF1_IN_JACK;
            QF_PUBLISH(&pAudioMusicStateEvt->super, me);
            TP_PRINTF("\r\n\r\n*** Optical music states is %d as optical cable is not detected ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            hasOpticalMusicStream_DebPre = FALSE;
            return;
        }
//*******************************************************************************************************
//        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
//        {
//        }
        if(hasOpticalMusicStream_DebNew==hasOpticalMusicStream)
        {
            //Do not need debounce
            optical_detect_debounce_msec= 0;
        }
        else if(hasOpticalMusicStream_DebNew!=hasOpticalMusicStream_DebPre)
        {
            //stop debounce
            optical_detect_debounce_msec= 0;
            //TP_PRINTF("aux-in: debounce fail\r\n");
        }
        else
        {
            //start or continue debounce (new == pre == curr)
            if(optical_detect_debounce_msec <= AUDIO_OPTICAL_DETECT_PEROID_MSEC)
            {
                optical_detect_debounce_msec+= AUDIO_SRV_TIMEOUT_IN_MS;
                //TP_PRINTF("optical: debouncing\r\n");
            }
            else
            {
                int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET5);
                int8 det2 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET1);
                hasOpticalMusicStream= hasOpticalMusicStream_DebNew;
                if ((!hasOpticalMusicStream) ||
                    (hasOpticalMusicStream && ((!det1) && (det2))))
                {
                    //finish debounce
                Setting_Set(SETID_MUSIC_SPDIF_DET, &hasOpticalMusicStream);
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = hasOpticalMusicStream;
                pAudioMusicStateEvt->jackId = SPDIF1_IN_JACK;
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("\r\n\r\n*** Optical music states is %d ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            }
        }
        }
        hasOpticalMusicStream_DebPre= hasOpticalMusicStream_DebNew;
    }

}


/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *me)
{
    AudioDrv_CheckMusicStreamStatus();
    AudioDrv_AmpHealthMonitor(me);
    AudioDrv_AmpSafetyMonitor(me);
#ifdef HAS_DSP_TUNING_DETECT    
    AudioDrv_DspTuneUpdate(me);
#endif
}


/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
//    bool preStatus = *(bool*)Setting_Get(SETID_MUSIC_DET);
//    bool hasMusicStream = preStatus;
//
//    if (musicDetTimer > 0)
//    {
//        if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
//        {
//            //DSPDrv1451_ReadAsrcConversionRate(&dspAdau1451Drv, DSP_ASRC0); //DSP_ASRC_FROM_ASETK
//            //DSPDrv1451_GetDspVer(&dspAdau1451Drv);
//            
//            hasMusicStream = DSPDrv1451_AuxinHasMusicStream(&dspAdau1451Drv);
//            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
//            if (preStatus != hasMusicStream)
//            {
//                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
//                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
//                pAudioMusicStateEvt->hasMusicStream = hasMusicStream;
//                Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
//                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
//                TP_PRINTF("\r\n\r\n*** Aux-in music states is %d ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
//            }
//        }
//    }
    AudioDrv_CheckAuxMusicStreamStatus();
    AudioDrv_CheckOpticalMusicStreamStatus();

}


static void AudioDrv_StopFadeVolume()
{
    if (volFadeParam.isFadingInProg == TRUE)
    {
        TP_PRINTF("Volume fade: Stop volume fading and reply ASE (red_id=%d)\r\n", volFadeReqId);
        AseNgSrv_ReplyVolumeFade(volFadeReqId, TRUE);
        bool ret= Timer_StopTimer(volFadeTimerId);
        ASSERT(ret); //FALSE means Fade volume timer is not running
        volFadeParam.isFadingInProg = FALSE;
        volFadeReqId = 0;
    }
}


static void AudioDrv_SetFadeVolume(cAudioDrv *me, uint32 target_volume, uint32 fade_duration)
{
    /* The start volume should always be equal to current volume. */
    uint8 start_volume = *(uint8*)Setting_Get(SETID_VOLUME);
    uint32 fadeRange = TYM_DIFF(target_volume, start_volume);

    /* fade_duration should not be less than ADUIO_MIN_FADE_STEP_TIME */
    if(fade_duration < ADUIO_MIN_FADE_STEP_TIME)
    {
        fade_duration= ADUIO_MIN_FADE_STEP_TIME;
    }

    if(((fadeRange <= (MAX_VOLUME - MIN_VOLUME)) && fadeRange > 0)
        && (target_volume >= MIN_VOLUME && target_volume <= MAX_VOLUME)
        && (start_volume >= MIN_VOLUME && start_volume <= MAX_VOLUME))
    {
        volFadeParam.fadeType     = (target_volume > start_volume)? TRUE : FALSE;
        volFadeParam.fadeStep     = ADUIO_MIN_FADE_STEP;
        volFadeParam.fadeStepTime = (fade_duration * volFadeParam.fadeStep)/fadeRange;
        volFadeParam.targetVol    = target_volume;
        volFadeParam.isFadingInProg = TRUE;
        if(ADUIO_MIN_FADE_STEP_TIME > volFadeParam.fadeStepTime)
        {
            volFadeParam.fadeStepTime = ADUIO_MIN_FADE_STEP_TIME;
            volFadeParam.fadeStep = (volFadeParam.fadeStepTime * fadeRange)/fade_duration;
            ASSERT(volFadeParam.fadeStep>0);
        }
        Timer_StartTimer((uint32)volFadeParam.fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, &volFadeParam);
    }
    else
    {
        TP_PRINTF("The volume fade parameters are invalid. \r\n");
        AseNgSrv_ReplyVolumeFade(volFadeReqId, FALSE);
    }
}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady)) {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch (audioSettId)
    {
        case DSP_CAL_GAIN1_ID:
        case DSP_CAL_GAIN2_ID:
        case DSP_CAL_GAIN3_ID:
        case DSP_CAL_GAIN4_ID:
        {
            float fGainDb= *((float*)&param);
            TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_CAL_GAINx_ID, gain=%1.2f\r\n", audioSettId, fGainDb);
            AudioDrv_DspCalGainSetId_Handler(audioSettId, fGainDb);
            break;
        }        
        case DSP_VOLUME_SETT_ID:
        {
            AudioDrv_StopFadeVolume();                
            uint8 volume= (uint8)param;
            Setting_Set(SETID_VOLUME, &volume);
            AudioDrv_DspVolSetId_Handler();
            break;
        }
        case DSP_PASSTHROUGH_SETT_ID:
            TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_PASSTHROUGH_SETT_ID, bypass=%d\r\n", audioSettId, enabled);
            //DSPDrv1451_SetPassthrough(&dspAdau1451Drv, enabled);
            break;
            
        case AMP_SLEEP_MODE_ID:
            if(!audioOverheat)
            {
//                TP_PRINTF("AudioDrv_SetAudio: AMP_SLEEP_MODE_ID, enabled=%d\r\n", enabled);
//                AudioAmpDrv_setShutdown(&audioAmpWoofer1Drv, enabled);
//                AudioAmpDrv_setShutdown(&audioAmpWoofer2Drv, enabled);
//                AudioAmpDrv_setShutdown(&audioAmpMidDrv,     enabled);
//                AudioAmpDrv_setShutdown(&audioAmpTweeterDrv, enabled);
            }
            break;
            
        case AUDIO_OVERHEAT_MODE_ID:
            AudioDrv_SetOverheat(me, enabled);
            break;
            
        case DSP_TUNNING_SETT_ID:
            /* DSP and AMP I2C bus should be disable when tuning DSP. */
            DSPDrv1451_I2cEnable(&dspAdau1451Drv, !enabled);
            break;
            
        case AUDIO_VOL_FADE_SETT_ID:
        {  /* param ( vv:ffffff    8 bits volume : 24 bits fade duration )
              param2 request id */
            uint32 target_volume= param >> 24;
            volFadeReqId = param2;
            uint32 fade_duration= param & 0xFFFFFF;
            AudioDrv_StopFadeVolume();
            AudioDrv_SetFadeVolume(me, target_volume, fade_duration);
            break;
        }
        case AUDIO_LINEIN_SENSITIVITY_SETT_ID:
        {
            eLineinSensitivity lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
            switch ((AseFepSetLineInSensitivity_LineInSensitivity)param)
            {
            case AseFepSetLineInSensitivity_LineInSensitivity_HIGH:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_HIGH;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_MEDIUM;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_LOW:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_LOW;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_DISABLED:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
                    break;
                default:
                break;
            }
            //DSPDrv1451_SetLineInSensitivity(&dspAdau1451Drv, lineInSensitivityLvl);
            break;
        }

        default:
             break;
    }
}


static void AudioDrv_DspCalGainSetId_Handler(eAudioSettId audioSettId, float fGainDb)
{
//   int32 ctlId= AudioDrv_GetCrtIdIndex(audioSettId);
//   ASSERT(ctlId>=0); //-1 means fail
//   DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, audioSettId, fGainDb);
}

static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack\r\n");
    
    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
    /* get current volume value */
    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);

    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack: fadeType=%d, step=%d, vol:(curr=%d,tgt=%d) \r\n", 
    //            pVolFadeParam->fadeType, pVolFadeParam->fadeStep, volLevel, pVolFadeParam->targetVol);
    
    ASSERT(pVolFadeParam->isFadingInProg==TRUE);

    /* For issue FS-202, sometimes AudioDrv_VolFadeTimerCallBack() repeated execute and set the same volume.
     * The only possible condition is fadeStep==0, but there is no reason for it.
     * Before find root cause, we add workaround here.
     */
    if(pVolFadeParam->fadeStep==0)
    {
        ASSERT(0);
        TP_PRINTF("\r\n\r\n\r\n*** ERROR: AudioDrv_VolFadeTimerCallBack fadeStep==0 ***\r\n\r\n\r\n\r\n");
        return;
    }
    
    /* change volume*/
    if(pVolFadeParam->fadeType)
    {
        /* volume fade up*/
        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = MAX_VOLUME;
        }
        else
        {
            volLevel += pVolFadeParam->fadeStep;
        }
    }
    else
    {
        /* volume fade down*/
        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
        {
            volLevel = MIN_VOLUME;
        }
        else
        {
            volLevel -= pVolFadeParam->fadeStep;
        }
    }
    Setting_Set(SETID_VOLUME, &volLevel);
    AudioDrv_DspVolSetId_Handler();

    if((volLevel != pVolFadeParam->targetVol)
        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
    {
        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
    }
    else
    {
        /* Reply Ase-tk when volume fade completed. */
        AseNgSrv_ReplyVolumeFade(volLevel);
        pVolFadeParam->isFadingInProg = FALSE;
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    ASSERT(muteType < AUDIO_MUTE_TYPE_MAX);
    switch (muteType)
    {
        case AUDIO_AMP_SOFT_MUTE:
            TP_PRINTF("AudioDrv_Mute: mute=%d\r\n", muteEnable);
            if(muteEnable)
            {
                AUDIO_DAC_IN_MUTE(audioGpioDrv);
                AUDIO_DAC_OUT_MUTE(audioGpioDrv);
            }
            else
            {
                AUDIO_DAC_IN_UNMUTE(audioGpioDrv);
                AUDIO_DAC_OUT_UNMUTE(audioGpioDrv);
            }
            break;
        default:
            //Support only soft mute
            ASSERT(0);
            break;
    }
 }
    
/**
 * Function to mute specific channel (Woofer, MiddleA, MiddleB, Tweeter).
 * @param[in]   channel_maks    This parameter defines which channels should be muted.
 * Bit 3 corresponds to: Woofer,- 1 to mute; 0 - to unmute.
 * Bit 2 corresponds to: MiddleA,- 1 to mute; 0 - to unmute.
 * Bit 1 corresponds to: MiddleB,- 1 to mute; 0 - to unmute.
 * Bit 0 corresponds to: Tweeter,- 1 to mute; 0 - to unmute.
 * For example to mute only Woofer, MiddleA and MiddleB  and unmute Tweeter
 * channel mask will be : 0000 0000 0000 0000 0000 0000 0000 1110  ( 0x000E )
 *
 */
void AudioDrv_MuteChannel(uint32 channel_mask)
{
//    if (channel_mask & AUDIO_WOOFER_MUTE_CHANNEL_MASK)
//    {
//        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, TRUE);
//    }
//    else
//    {
//        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, FALSE);
//    }
//
//    if (channel_mask & AUDIO_MIDDLEA_MUTE_CHANNEL_MASK)
//    {
//        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, TRUE);
//    }
//    else
//    {
//        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, FALSE);
//    }
//
//    if (channel_mask & AUDIO_MIDDLEB_MUTE_CHANNEL_MASK)
//    {
//        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, TRUE);
//    }
//    else
//    {
//        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, FALSE);
//    }
//
//    if (channel_mask & AUDIO_TWEETER_MUTE_CHANNEL_MASK)
//    {
//        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, TRUE);
//    }
//    else
//    {
//        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, FALSE);
//    }
}


    
 static void AudioDrv_DspVolSetId_Handler(void)
 {
    uint8 volumeLevel = MIN_VOLUME;
    
    int32 ctlId= AudioDrv_GetCrtIdIndex(DSP_VOLUME_SETT_ID);
    ASSERT(ctlId>=0); //-1 means fail   
    
     volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[ctlId].settingId);
     if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
     {
         DSPDrv1451_SetVol(&dspAdau1451Drv, volumeLevel);
     }
     else
     {
         ASSERT(0);
     }    
 }
    

//return -1 means can not find
static int32 AudioDrv_GetCrtIdIndex(eAudioSettId audioSettId)
{
    int32 ret= -1;
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(audioSettId == ctrIdEQIdMap[i].dspSettid)
        {
            ret= i;
            break;
        }
    } 
    
    return ret;
}


static uint16 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint16 degreeC;

    for (degreeC = 0; degreeC < TEMPERATURE_POSITIONS_NUM; degreeC++)
    {
        if (ntcValue >= audioNtcTempTable[degreeC])
        {
            break;
        }
    }
    return degreeC;
}


static void AudioDrv_SetOverheat(cAudioDrv *me, bool overheat)
{  
    /* audioOverheat occurs: Shutdown ampliifer for over-heat
     * recover from audioOverheat: do nothing, but allow MainApp to wakeup amplifier
     */
    TP_PRINTF("AudioDrv_SetOverheat: overheat=%d\r\n", overheat);
    audioOverheat= overheat;
    if(overheat) 
    {
        //AMP_SHUTDOWN(audioGpioDrv);
    }
    else
    {
        //AMP_WAKEUP(audioGpioDrv);
    }
}

static void AudioDrv_AmpHealthMonitor(cAudioDrv *me)
{
//    bool amp_health = 0;
//    bool ampWoofer1_error = FALSE;
//    bool ampWoofer2_error = FALSE;
//    bool ampMid_error     = FALSE;
//    bool ampTweeter_error = FALSE;
//
//    /* bit0: over-temperature error
//     * bit1: output dc error
//     * bit2: over current error
//     * bit3: clock erorr
//     */
//    AudioAmpDrv_getErrorStatus(&audioAmpWoofer1Drv, &ampWoofer1_error);
//    AudioAmpDrv_getErrorStatus(&audioAmpWoofer2Drv, &ampWoofer2_error);
//    AudioAmpDrv_getErrorStatus(&audioAmpMidDrv,     &ampMid_error);
//    AudioAmpDrv_getErrorStatus(&audioAmpTweeterDrv, &ampTweeter_error);
//
//    amp_health = !(ampWoofer1_error || ampWoofer2_error || ampMid_error || ampTweeter_error);
//    
//    /* byte[3]: woofer1 amplifier reason 
//     * byte[2]: woofer2 amplifier reason 
//     * byte[1]: middle amplifier reason 
//     * byte[0]: tweeter amplifier reason 
//     */
//    uint32 ampErrorReason= (ampWoofer1_error<<24) | (ampWoofer2_error<<16) | (ampMid_error<<8) | ampTweeter_error;
//    Setting_Set(SETID_AMP_ERROR_REASON, &ampErrorReason);
//
//    bool amp_healthPrev= TRUE;    
//    amp_healthPrev= *(bool*)Setting_GetEx(SETID_AMP_HEALTH, &amp_healthPrev);
//    Setting_Set(SETID_AMP_HEALTH, &amp_health);
// 
//    if(amp_healthPrev!=amp_health)
//    {
//        TP_PRINTF("\r\n\r\n\r\n*** AMP_HEALTH: %d (error reason: wf1:0x%x, wf2:0x%x, mid:0x%x, tw:0x%x) ***\r\n\r\n\r\n", amp_health, ampWoofer1_error, ampWoofer2_error, ampMid_error, ampTweeter_error);
//    }    
}


static void AudioDrv_AmpSafetyMonitor(cAudioDrv *me)
{  
//    uint16  tempWfAmp1New  = 0;
//    uint16  tempWfAmp2New  = 0;
//    uint16  tempWfSpkNew     = 0;
//    uint16  tempMidSpkANew   = 0;
//    uint16  tempMidSpkBNew   = 0;
//    uint16  tempTwAmpNew     = 0;   
//    eTempLevel tempLevelAudioNew = TL_NORMAL;
//    int32 rawResult= 0;
//    ASSERT(audioAdcDrv.isCreated);
//    
//    
//    //(1)Get temperature for Woofer amplifier 1
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_1);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempWfAmp1New = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempWfAmp1New, &tempWfAmp1, &tempLevelWfAmp1, ampTempLevels,  ArraySize(ampTempLevels));
//        Setting_Set(SETID_TEMP_WF_AMP_1, &tempWfAmp1);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_1_REGISTER, (uint32)tempWfAmp1New);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_1_REGISTER);
//        //TP_PRINTF("DSP Read back tempWfAmp1= %d\r\n", value);
//    }
//    
//    
//    //(2)Get temperature for Woofer amplifier 2
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_2);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempWfAmp2New = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempWfAmp2New, &tempWfAmp2, &tempLevelWfAmp2, ampTempLevels,  ArraySize(ampTempLevels));
//        Setting_Set(SETID_TEMP_WF_AMP_2, &tempWfAmp2);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_2_REGISTER, (uint32)tempWfAmp2New);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_2_REGISTER);
//        //TP_PRINTF("DSP Read back tempWfAmp2= %d\r\n", value);
//    }
//
//    
//    //(3)Get temperature for Woofer speaker 
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_SPK);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempWfSpkNew = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempWfSpkNew, &tempWfSpk, &tempLevelWfSpk, spkTempLevels,  ArraySize(spkTempLevels));
//        Setting_Set(SETID_TEMP_WF_SPK, &tempWfSpk);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_SPK_REGISTER, (uint32)tempWfSpkNew);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_SPK_REGISTER);
//        //TP_PRINTF("DSP Read back tempWfSpkNew= %d\r\n", value);
//    }
//   
//    
//    //(4)Get temperature for Middle spekaer A
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_A);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempMidSpkANew = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempMidSpkANew, &tempMidSpkA, &tempLevelMidSpkA, spkTempLevels,  ArraySize(spkTempLevels));
//        Setting_Set(SETID_TEMP_MID_SPK_A, &tempMidSpkA);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_A_REGISTER, (uint32)tempMidSpkANew);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_A_REGISTER);
//        //TP_PRINTF("DSP Read back tempMidSpkA= %d\r\n", value);
//    }
//   
//    
//    //(5)Get temperature for Middle spekaer B
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_B);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempMidSpkBNew = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempMidSpkBNew, &tempMidSpkB, &tempLevelMidSpkB, spkTempLevels,  ArraySize(spkTempLevels));
//        Setting_Set(SETID_TEMP_MID_SPK_B, &tempMidSpkB);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_B_REGISTER, (uint32)tempMidSpkBNew);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_B_REGISTER);
//        //TP_PRINTF("DSP Read back tempMidSpkB= %d\r\n", value);
//    }
//   
//    
//    //(6)Get temperature for Tweeter Amplifier
//    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_TW_AMP);
//    if (ADC_DATA_IS_NOT_READY != rawResult)
//    {
//        tempTwAmpNew = AudioDrv_ConvertNtcToTemperature(rawResult);
//        PowerDrv_UpdateTempLevel(tempTwAmpNew, &tempTwAmp, &tempLevelTwAmp, ampTempLevels,  ArraySize(ampTempLevels));
//        Setting_Set(SETID_TEMP_TW_AMP, &tempTwAmp);
//        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_TW_AMP_REGISTER, (uint32)tempTwAmpNew);
//        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_TW_AMP_REGISTER);
//        //TP_PRINTF("DSP Read back tempTwAmp= %d\r\n", value);
//    }
//    
//
//    //(4)Error Handling
//    tempLevelAudioNew= MIN6(tempLevelWfAmp1, tempLevelWfAmp2, tempLevelWfSpk, tempLevelMidSpkA, tempLevelMidSpkB, tempLevelTwAmp);
//    if(tempLevelAudio!=tempLevelAudioNew)
//    {
//        switch(tempLevelAudioNew)
//        {
//        case TL_CRITICAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (CRITICAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_SERIOUS:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (SERIOUS) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_WARN:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (WARN) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//       
//        case TL_NORMAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (NORMAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);            
//            AudioDrv_SetOverheat(me, FALSE);
//            break;
//             
//        default:
//            ASSERT(0);
//            break;
//        }
//    }
//    tempLevelAudio= tempLevelAudioNew;
//    Setting_Set(SETID_TEMP_LEVEL_AUDIO, &tempLevelAudioNew);
//    
//    
//    //(5)Continues ADC scanning
//    ADCDrv_StartScanning(&audioAdcDrv);
//    
//    
//    //(6)Print every 10sec (AUDIO_PRINT_PREIOD_IN_MS)
//    static int32 timeoutTick= 0;
//    timeoutTick--;
//    if(timeoutTick<=0)
//    {   
//        timeoutTick= AUDIO_PRINT_PREIOD_IN_MS / AUDIO_SRV_TIMEOUT_IN_MS;
//        TP_PRINTF("Temp: WfAmp1=%dC(L%d), WfAmp2=%dC(L%d), WfSpk=%dC(L%d), MidSpkA=%dC(L%d), MidSpkB=%dC(L%d), TwAmp=%dC(L%d) ==> audio=(L%d)\r\n", 
//                      tempWfAmp1,   tempLevelWfAmp1,
//                      tempWfAmp2,   tempLevelWfAmp2,
//                      tempWfSpk,    tempLevelWfSpk,
//                      tempMidSpkA,  tempLevelMidSpkA,
//                      tempMidSpkB,  tempLevelMidSpkB,
//                      tempTwAmp,    tempLevelTwAmp,
//                      tempLevelAudio);
//    }
}


#ifdef HAS_DSP_TUNING_DETECT    
static void AudioDrv_DspTuneUpdate(cAudioDrv *me)
{
    /* When insert DSP USBi cable, PA15 get high input from PA15,
     * but noise cause it trigger low sometime. Thus we need to debounce here.
     */
     
    //debounce for 0.5 seconds
    const uint32 timeoutTick= 100 / AUDIO_SRV_TIMEOUT_IN_MS;
    int8 dspTuneNew= GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_DSP_TUNE);
    
    if(dspTuneTmp != dspTuneNew) 
    {   //(Step-1) start debounce different DspTune
        debounceTick= 0;
        TP_PRINTF("DspTune (1)\r\n");
    }
    else
    {
        if(dspTuneCurr != dspTuneNew)
        {
            if( debounceTick < timeoutTick )
            {   //(Step-2) wait DspTune hold for 1s
                debounceTick++;
                TP_PRINTF("DspTune (2)\r\n");
            }
            else
            {   //(Setep-3) timeout, apply DspTune change, and turn on amplifier
                //When set dspTuneCurr, audio driver never turn off amplifier
                TP_PRINTF("DSP-TUNE= %d\r\n", dspTuneNew);
                if( dspTuneNew )
                {   //Enable amplifier when DSP cable insert
                    AudioDrv_SetAudio(me, AMP_SLEEP_MODE_ID, FALSE, /*not used*/0, /*not used*/0);
                    AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/FALSE);
                }
                DSPDrv1451_I2cEnable(&dspAdau1451Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer1Drv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer2Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpMidDrv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpTweeterDrv, !dspTuneNew);
                debounceTick= 0;
                dspTuneCurr= dspTuneNew;
            }
        }
        else
        {
            //(Step-4) DspTune not change
        }
    }
    dspTuneTmp= dspTuneNew;
}
#endif /* HAS_DSP_TUNING_DETECT */


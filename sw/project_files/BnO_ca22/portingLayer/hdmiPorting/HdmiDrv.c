/*****************************************************************************
* Model: tym_platform.qm
* File:  F:\Project_Atmos\tymphany_platform\sw/driver\hdmi_driver\HdmiDrv.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${F:\Project_Atmos~::driver\hdmi_driver\HdmiDrv.c} .......................*/
/**
 *  @file      hdmi_driver.c
 *  @brief     This file contains the EP91A6S HDMI driver implementation.
 *  @author    Albert
 *  @date      23-May-2016
 *  @copyright Tymphany Ltd.
 */
#include "HdmiDrv_priv.h"
#include "HdmiDrv.h"
#include "GPIODrv.h"
#include "deviceTypes.h"
#include "attachedDevices.h"
#include "trace.h"
#include "product.config"
#include "stdbool.h"
#include "bsp.h"
#include "HdmiSrv.h"
#include "HdmiDrv.Config"

/*************************************************************
    Debug information
**************************************************************/
#ifdef HDMIDRV_DEBUG
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...) TymQP_DumpQueue_WithLog((QActive *)(me), __func__, __VA_ARGS__)
    #define HDMIDRV_DEBUG_MSG TP_PRINTF
#else
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...)
    #define HDMIDSRV_DEBUG_MSG(...)
    #undef   TP_PRINTF
    #define  TP_PRINTF(...)
#endif

/*************************************************************
    Variable
**************************************************************/
static HdmiDrv *pHdmiDrvObj;
static bool interruptFlag = FALSE;

/**
 * Construct the DSP driver instance.
 * @param      me - instance of the driver
 */
static tHdmiInitSection HdmiInitSection[] =
{
    {&HdmiDrv_InitSection0, 10},
    {&HdmiDrv_InitSection1, 10},
};

/*
*
*/
static uint8_t HdmiDrv_I2C_Read(HdmiDrv * const me, uint8_t addr, uint8_t *data)
{
    ASSERT(me);
    SWi2cDrv_ReadByte(&me->i2cDrv, addr, data);
    return TRUE;
}

/*
*
*/
static uint8_t HdmiDrv_I2C_Write(HdmiDrv * const me, uint8_t addr, uint8_t data)
{
    ASSERT(me);
    SWi2cDrv_WriteByte(&me->i2cDrv, addr, data);
    return TRUE;
}

/**
 * Construct the driver instance.
 * @param me - instance of the driver
 * @param - None
 */
void HdmiDrv_Ctor(HdmiDrv * const me)
{
    ASSERT(me);

    /* initial HDMI GPIO */
    tDevice *pDev = NULL;
    pDev = (tDevice*)getDevicebyIdAndType(EP_HDMI_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(pDev!=NULL);
    GpioDrv_Ctor(&me->gpioDrv,(tGPIODevice*)pDev);
    GpioDrv_DisableExtInterrupt(&me->gpioDrv, GPIO_IN_HDMI_INTB);

    /* initial HDMI swi2c */
    me->i2cDrv.pConfig = (stSWi2cDevice_t *) getDevicebyIdAndType(SW_I2C1_DEV_ID, SWI2C_DEV_TYPE, NULL);
    ASSERT(me->i2cDrv.pConfig !=NULL);
    SWi2cDrv_Ctor(&me->i2cDrv,me->i2cDrv.pConfig);

    /* Reset Hdmi chip */
    GpioDrv_ClearBit(&me->gpioDrv, GPIO_OUT_HDMI_RSTB);
    BSP_BlockingDelayMs(10); //TBD: spec. >=10 ms
    GpioDrv_SetBit(&me->gpioDrv, GPIO_OUT_HDMI_RSTB);

    /* initial some variable */
    pHdmiDrvObj = me;
    me->drvIsReady = FALSE;
    me->pInitTable    = HdmiInitSection;
    me->sectionSize   = ArraySize(HdmiInitSection);
}

/**
 * Deconstruct the driver instance.
 * @param me - instance of the driver
 * @param - None
 */
void HdmiDrv_Xtor(HdmiDrv * const me)
{
    ASSERT(me);

    me->drvIsReady = FALSE;
    HdmiDrv_SetPower(me,HDMI_BITMASK_POWER_OFF);
    GpioDrv_Xtor(&me->gpioDrv);
    SWi2cDrv_Xtor(&me->i2cDrv);

    GpioDrv_DisableExtInterrupt(&me->gpioDrv, GPIO_IN_HDMI_INTB);
}

/*
*
*/
uint16 HdmiDrv_Init(HdmiDrv * const me)
{
    uint16 delaytime;

    ASSERT(me && me->pInitTable && me->pInitTable[me->initPhase].initSectionFunc);

    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
        return 0;
    }

    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    return (delaytime);
}

static void HdmiDrv_InitSection0(void *p)
{
    HdmiDrv *me = (HdmiDrv*)p;
    uint8_t features;
#if 0
    features = HDMI_BITMASK_POWER_ON | HDMI_BITMASK_AUDIO_PATH_AMP\
            | HDMI_BITMASK_CEC_DISABLE_OFF | HDMI_BITMASK_CEC_MUTE_OFF\
            | HDMI_BITMASK_ARC_ENABLE_ON;

    HdmiDrv_I2C_Write(me, HDMI_REG_X10, features);

    /*
    *  MCU should update bellow settings when HDMI initializing,
    *  otherwise TV will not enter ARC mode and CEC is failed
    */
    features = HDMI_BITMASK_HOST_POWER_ON | HDMI_BITMASK_HOST_SOURCE_TV_ARC;
    HdmiDrv_I2C_Write(me, HDMI_REG_X7, features);

    /*
    *
    */
    features = HDMI_BITMASK_RX_SEL_NULL;
    HdmiDrv_I2C_Write(me, HDMI_REG_X11, features);
#else

    features = HDMI_BITMASK_POWER_ON | HDMI_BITMASK_AUDIO_PATH_AMP\
            | HDMI_BITMASK_CEC_DISABLE_OFF | HDMI_BITMASK_CEC_MUTE_OFF\
            | HDMI_BITMASK_ARC_ENABLE_ON;

    HdmiDrv_I2C_Write(me, HDMI_REG_X10, features);

    /*
    *  MCU should update bellow settings when HDMI initializing,
    *  otherwise TV will not enter ARC mode and CEC is failed
    */
    features = HDMI_BITMASK_HOST_POWER_ON | HDMI_BITMASK_HOST_SOURCE_TV_ARC;
    HdmiDrv_I2C_Write(me, HDMI_REG_X7, features);

    /*
    *
    */
    features = HDMI_BITMASK_RX_SEL_NULL;
    HdmiDrv_I2C_Write(me, HDMI_REG_X11, features);

    /*
    *
    */
    HdmiDrv_SetCECPower(me, HDMI_BITMASK_CEC_POWER_ON);
#endif
}

static void HdmiDrv_InitSection1(void *p)
{
    HdmiDrv *me = (HdmiDrv*)p;
    uint8_t major_version, minor_version1, minor_version2;

    HDMIDRV_DEBUG_MSG("HDMI Vender ID:%04x\n\r",HdmiDrv_GetVenderID(me));
    HDMIDRV_DEBUG_MSG("HDMI Device ID:%04x\n\r",HdmiDrv_GetDeviceID(me));

    HdmiDrv_GetVersion(me, &major_version, &minor_version1, &minor_version2);
    HDMIDRV_DEBUG_MSG("HDMI Version:%d.%d.%d\n\r", major_version, minor_version1, minor_version2);

    /* Enable the Interrupt */
    GpioDrv_EnableExtInterrupt(&me->gpioDrv, GPIO_IN_HDMI_INTB, ExtiIntTri_Rising);

    /**/
    me->txPlugin = FALSE;   // not plugin
    me->cec_volume = 0;
    me->cec_mute = FALSE;
    me->cec_power = TRUE;
    me->source = 0;
}

/**
 * Enable/Disable system power.
 * @param me - instance of the driver
 * @param enable- enable or disable power
 */
void HdmiDrv_SetPower(HdmiDrv * const me, uint8_t setting)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    value &= ~HDMI_BITMASK_POWER;
    value |= setting;
    HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
}

/**
 * Return power status.
 * @param me - instance of the driver
 * @param - NONE
 */
uint8_t HdmiDrv_GetPower(HdmiDrv * const me)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    return (value & HDMI_BITMASK_POWER);
}

/**
 * Set HDMI CEC.
 * @param me - instance of the driver
 * @param enable- enable or disable ARC
 */
void HdmiDrv_SetCECDisable(HdmiDrv * const me, uint8_t setting)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    value &= ~HDMI_BITMASK_CEC_DISABLE;
    value |= setting;
    HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
}

/**
 * Return ARC status.
 * @param me - instance of the driver
 * @param - NONE
 */
uint8_t HdmiDrv_GetCECDisable(HdmiDrv * const me)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    return (value & HDMI_BITMASK_CEC_DISABLE);
}

/**
 * Set HDMI ARC.
 * @param me - instance of the driver
 * @param enable- enable or disable ARC
 */
void HdmiDrv_SetARCEnable(HdmiDrv * const me, uint8_t setting)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    value &= ~HDMI_BITMASK_ARC_ENABLE;
    value |= setting;
    HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
}
/**
 * Return ARC status.
 * @param me - instance of the driver
 * @param - NONE
 */
uint8_t HdmiDrv_GetARCEnable(HdmiDrv * const me)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    return (value & HDMI_BITMASK_ARC_ENABLE);
}

/**
 * Set HDMI mute/unmute.
 * @param me - instance of the driver
 * @param setting- 1:enable mute or 0:disable mute
 */
void HdmiDrv_SetMute(HdmiDrv * const me, uint8_t setting)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    value &= ~HDMI_BITMASK_CEC_MUTE;
    value |= setting;
    HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
}

uint8_t HdmiDrv_GetMute(HdmiDrv * const me)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    return (value & HDMI_BITMASK_CEC_MUTE);
}

/**
 * Set HDMI volume.
 * @param me - instance of the driver
 * @param level- volume level
 */
void HdmiDrv_SetVolume(HdmiDrv * const me, uint8_t level)
{
    ASSERT(me);
    HdmiDrv_I2C_Write(me, HDMI_REG_X13, level);
}

/**
 * Return current HDMI volume.
 * @param me - instance of the driver
 * @param - NONE
 */
uint8_t HdmiDrv_GetVolume(HdmiDrv * const me)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X13, &value);
    return value;
}

/**
 * Set HDMI source.
 * @param me - instance of the driver
 * @param port - 1:HDMI_Port1, 6:HDMI_ARC
 */
void HdmiDrv_SetSource(HdmiDrv * const me, uint8_t port)
{
    uint8 value;
    ASSERT(me);

    me->source=port;
    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &value);
    switch(port)
    {
        case HDMI_PORT_1:
            //Reg 0x10: Power=1, Audio_Path=1 , ARC_EN=0
            value |= (HDMI_BITMASK_POWER_ON | HDMI_BITMASK_AUDIO_PATH_AMP);
            value &= ~(HDMI_BITMASK_ARC_ENABLE);
            HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
            //Reg 0x11: HDMI_PORT_1=1
            HdmiDrv_SetPort(me, HDMI_PORT_1);
            break;
        case HDMI_PORT_ARC:
            //Reg 0x10: Power=1, Audio_Path=1 , ARC_EN=1
            value |= (HDMI_BITMASK_POWER_ON | HDMI_BITMASK_AUDIO_PATH_AMP | HDMI_BITMASK_ARC_ENABLE_ON);
            HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
            //Reg 0x11: HDMI_PORT_ARC=6
            HdmiDrv_SetPort(me, HDMI_PORT_ARC);
            break;
        default:
            //Reg 0x10:Audio_Path=0 , ARC_EN=0
            value &= ~(HDMI_BITMASK_AUDIO_PATH | HDMI_BITMASK_ARC_ENABLE);
            HdmiDrv_I2C_Write(me, HDMI_REG_X10, value);
            //Reg 0x11: HDMI_PORT_NONE=0xf [TBD]
            HdmiDrv_SetPort(me, HDMI_PORT_NONE);
            break;
    }
}

/**
 * Return current HDMI source.
 * @param me - instance of the driver
 * @param - NONE
 */
uint8_t HdmiDrv_GetSource(HdmiDrv * const me)
{
    ASSERT(me);
    return me->source;
}

uint8_t HdmiDrv_isI2cReady(HdmiDrv * const me)
{
    uint8_t value = 0x00;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X9, &value);
    return (value & HDMI_BITMASK_I2C);
}

uint16_t HdmiDrv_GetVenderID(HdmiDrv * const me)
{
    uint8_t value = 0x00;
    uint16_t result = 0x0000;

    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X0, &value);
    result = (value << 8);

    HdmiDrv_I2C_Read(me, HDMI_REG_X1, &value);
    result |= value;

    return result;
}
uint16_t HdmiDrv_GetDeviceID(HdmiDrv * const me)
{
    uint8_t value = 0x00;
    uint16_t result = 0x0000;

    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X2, &value);
    result = (value << 8);

    HdmiDrv_I2C_Read(me, HDMI_REG_X3, &value);
    result |= value;

    return result;
}

void HdmiDrv_GetVersion(HdmiDrv * const me, uint8_t* major_ver, uint8_t* minor_ver1, uint8_t* minor_ver2)
{
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X4, major_ver);
    HdmiDrv_I2C_Read(me, HDMI_REG_X5, minor_ver1);
    HdmiDrv_I2C_Read(me, HDMI_REG_X6, minor_ver2);
}

void HdmiDrv_SetPort(HdmiDrv * const me, uint8_t port)
{
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X11, &value);
    value &= ~HDMI_BITMASK_RX_SEL;
    value |= (port & HDMI_BITMASK_RX_SEL);
    HdmiDrv_I2C_Write(me, HDMI_REG_X11, value);
}

/**
 * Set HDMI cec power
 * @param me - instance of the driver
 * @param 
 */
void HdmiDrv_SetCECPower(HdmiDrv * const me, uint8_t setting) {
    uint8_t value;
    ASSERT(me);

    HdmiDrv_I2C_Read(me, HDMI_REG_X9, &value);
    value &= ~HDMI_BITMASK_CEC_POWER;
    value |= setting;
    HdmiDrv_I2C_Write(me, HDMI_REG_X9, value);
}

void HdmiDrv_Dump(void)
{
    uint32_t i;
    uint8_t regVal;

    TP_PRINTF("\r\nGET:");
    for (i = HDMI_REG_X7; i <= HDMI_REG_X38; i++)
    {
        HdmiDrv_I2C_Read(pHdmiDrvObj, i, &regVal);
        TP_PRINTF(" <0x%02x>0x%02x", i, regVal);
    }
    TP_PRINTF("\r\nDONE.");
}

bool HdmiDrv_isDeviceReady(void)
{
    HdmiDrv *me = pHdmiDrvObj;
    ASSERT(me);

    if (SWi2cDrv_DeviceAvailable(&me->i2cDrv, 2))
    {
        /* check if the i2c is already */
        if (HdmiDrv_isI2cReady(me))
            return TRUE;
    }

    return FALSE;
}

void HdmiDrv_Standby(HdmiDrv * const me)
{
    /* enable CEC */
    HdmiDrv_SetCECDisable(me, HDMI_BITMASK_CEC_DISABLE_OFF);

    /* Disable power */
    HdmiDrv_SetPower(me, HDMI_BITMASK_POWER_OFF);
}

void HdmiDrv_SetInterruptFlag(bool enable)
{
    interruptFlag = enable;
}

bool HdmiDrv_GetInterruptFlag(void)
{
    return interruptFlag;
}

/*
*
*/
static void HdmiDrv_InterruptHandler(void)
{
    REG_7 reg7;
    REG_8 reg8;
    REG_9 reg9;
    REG_10 reg10;
    REG_11 reg11;
    REG_12 reg12;
    uint8_t cec_volume;
    HdmiDrv *me = pHdmiDrvObj;
    ASSERT(me);

    HdmiDrv_Dump();

    HdmiDrv_I2C_Read(me, HDMI_REG_X7, &reg7.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X8, &reg8.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X9, &reg9.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X10, &reg10.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X11, &reg11.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X12, &reg12.data);
    HdmiDrv_I2C_Read(me, HDMI_REG_X13, &cec_volume);

#if 1
    if (me->txPlugin != (bool)reg8.bit.Tx_Hot_Plug)
    {
        if (reg8.bit.Tx_Hot_Plug)
        {
            /* now status: cable plug in
            *  power up the HDMI total power, update the register cache
            */
            HDMIDRV_DEBUG_MSG("tx plugin\r\n");
            HdmiDrv_SetPower(me, HDMI_BITMASK_POWER_ON);
            HdmiSrv_UpdatedTxPluginStatus(TRUE);
        }
        else
        {
            /* now status: cable plug out
            *  power down the HDMI chip, clean variables
            */
            HDMIDRV_DEBUG_MSG("tx plugout\r\n");
            HdmiDrv_SetPower(me, HDMI_BITMASK_POWER_OFF);
            HdmiSrv_UpdatedTxPluginStatus(FALSE);
        }

        me->txPlugin = reg8.bit.Tx_Hot_Plug;
    }

    if (me->cec_mute != (bool)reg10.bit.CEC_Mute)
    {
        if (reg10.bit.CEC_Mute)
        {
            /*  TV mute
            *
            */
            HdmiSrv_UpdatedMuteStatus(TRUE);
            HDMIDRV_DEBUG_MSG("cec mute\r\n");
        }
        else
        {
            /* TV unmute
            *
            */
            HdmiSrv_UpdatedMuteStatus(FALSE);
            HDMIDRV_DEBUG_MSG("cec unmute\r\n");
        }

        me->cec_mute = reg10.bit.CEC_Mute;
    }

    if (me->cec_volume != cec_volume)
    {
        uint8_t volume;

        /* calculate the actually volume according volume map table */
        volume = HdmiDrv_CalcVolume(cec_volume);
        HDMIDRV_DEBUG_MSG("cec volume=%d, %d\r\n", cec_volume, volume);
        if (me->volume != volume)
        {
            HdmiSrv_UpdatedVolume(volume, cec_volume);
        }

        me->cec_volume = cec_volume;
    }

    if (me->cec_power != (bool)reg9.bit.CEC_Power)
    {
        HDMIDRV_DEBUG_MSG("cec power=%d\r\n", reg9.bit.CEC_Power);
        if (reg9.bit.CEC_Power)
        {

        }
        else
        {

        }

        HdmiSrv_UpdatedPowerOnOff(reg9.bit.CEC_Power);
        me->cec_power = reg9.bit.CEC_Power;
    }

#endif
}


void HdmiDrv_UpdateStatus(void)
{
    /* */
    if(HdmiDrv_GetInterruptFlag())
    {
        HdmiDrv_SetInterruptFlag(FALSE);
        HdmiDrv_InterruptHandler();
    }
}

/*
* @brief       HDMI request
* @param[in]   me          pointer to Led Server object
*/
void HdmiDrv_RequestHandler(HdmiReqEvt *reqEvt)
{
    ASSERT(reqEvt->hdmiSettId < HDMI_SETT_ID_MAX);

    switch(reqEvt->hdmiSettId)
    {
    case HDMI_ENTER_ISP_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_ENTER_ISP_ID\r\n");
        
        break;
    }
    case HDMI_POWER_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_POWER_ID\r\n");
        
        break;
    }
    case HDMI_VOLUME_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_VOLUME_ID\r\n");
        
        break;
    }
    case HDMI_MUTE_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_MUTE_ID\r\n");
        
        break;
    }
    case HDMI_TEST_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_TEST_ID\r\n");
        
        break;
    }

    default:
    {
        HDMIDRV_DEBUG_MSG("unknown Request command\r\n");
        break;
    }
    }
}

/*
* @brief       HDMI request
* @param[in]   me          pointer to Led Server object
*/
void HdmiDrv_GetHandler(HdmiGetCmd *pGetCmd)
{
    ASSERT(pGetCmd->hdmiSettId < HDMI_SETT_ID_MAX);

    switch (pGetCmd->hdmiSettId)
    {
    case HDMI_TX_PLUGIN_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_TX_PLUGIN_ID\r\n");
        break;
    }
    /* HDMI Driver internal interact */
    case HDMI_CEC_POWER_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_CEC_POWER_ID\r\n");
        break;
    }
    case HDMI_CEC_VOLUME_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_CEC_VOLUME_ID\r\n");
        break;
    }
    case HDMI_CEC_MUTE_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_CEC_MUTE_ID\r\n");
        break;
    }
    case HDMI_CEC_PORT_SOURCE_ID:
    {
        HDMIDRV_DEBUG_MSG("HDMI_CEC_SOURCE_ID\r\n");
        break;
    }

    default:
    {
        HDMIDRV_DEBUG_MSG("unknown CEC command\r\n");
        break;
    }
    }

}

static uint8_t HdmiDrv_CalcVolume(uint8_t cec_volume)
{
    uint8_t vol_idx;

    for(vol_idx = 0; vol_idx < sizeof(HdmiVolMap); vol_idx++)
    {
        if(HdmiVolMap[vol_idx] > cec_volume)
        {
            break;
        }
    }

    return (vol_idx - 1);
}

static uint8_t HdmiDrv_CalcCECVolume(uint8_t volume)
{
    return HdmiVolMap[volume];
}


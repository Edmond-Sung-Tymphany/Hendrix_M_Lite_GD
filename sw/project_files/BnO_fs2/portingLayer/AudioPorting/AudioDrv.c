/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Audio Driver have three layer DISABLE operation.
1. SW Mute     -> FepAseCommand_Command_MUTE, FepAseCommand_Command_UNMUTE
2. SW Shutdown -> AseFepEvent_Event_SYSTEM_STATUS_STANDBY, AseFepEvent_Event_SYSTEM_STATUS_ON
3. HW Shutdown -> Overheat occurs/recover

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "PowerDrv_v2.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AseTkSrv.h"
#include "I2CDrv.h"
#include "ADCDrv.h"
#include "GPIODrv.h"
#include "DspDrv1451.h"
#include "AmpDrvTas5760.h"
#include "timer.h"
#include "AudioDrv.config"
#include "AudioSrv.config"
#include "pcm1862Drv.h"


/***********************************************
 * Type
 ***********************************************/
typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},
    {DSP_CAL_GAIN1_ID,    SETID_DSP_CAL_GAIN1_WF},
    {DSP_CAL_GAIN2_ID,    SETID_DSP_CAL_GAIN2_MID_A},
    {DSP_CAL_GAIN3_ID,    SETID_DSP_CAL_GAIN3_MID_B},
    {DSP_CAL_GAIN4_ID,    SETID_DSP_CAL_GAIN4_TW},
    
};


/***********************************************
 * Global Variable
 ***********************************************/
static cI2CDrv      dspI2cDrv;
static cDSPDrv1451  dspAdau1451Drv;

static cI2CDrv      ampWoofer1I2cDrv;
static cAudioAmpDrv audioAmpWoofer1Drv;

static cI2CDrv      ampWoofer2I2cDrv;
static cAudioAmpDrv audioAmpWoofer2Drv;

static cI2CDrv      ampMidI2cDrv;
static cAudioAmpDrv audioAmpMidDrv;

static cI2CDrv      ampTweeterI2cDrv;
static cAudioAmpDrv audioAmpTweeterDrv;

static cADCDrv      audioAdcDrv;

static cI2CDrv          adcPcm1862i2cObj;
static cAdcDrv_pcm1862  adcPcm1862;

static cGpioDrv audioGpioDrv;

static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static bool audioOverheat= FALSE;

#ifdef HAS_DSP_TUNING_DETECT
static bool dspTuneCurr= FALSE;
static bool dspTuneTmp= FALSE;
static uint32 debounceTick= 0; //the time to hold the same DspTune value
#endif

static uint16        tempWfAmp1    = 0;
static uint16        tempWfAmp2    = 0;
static uint16        tempWfSpk     = 0;
static uint16        tempMidSpkA   = 0;
static uint16        tempMidSpkB   = 0;
static uint16        tempTwAmp     = 0;

static eTempLevel    tempLevelWfAmp1  = TL_NORMAL;
static eTempLevel    tempLevelWfAmp2  = TL_NORMAL;
static eTempLevel    tempLevelWfSpk   = TL_NORMAL;
static eTempLevel    tempLevelMidSpkA = TL_NORMAL;
static eTempLevel    tempLevelMidSpkB = TL_NORMAL;
static eTempLevel    tempLevelTwAmp   = TL_NORMAL;

static eTempLevel    tempLevelAudio   = TL_NORMAL;

static uint16 volFadeTimerId= 0;

tVolFadeParam volFadeParam= {0};


/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds (after ASE-TK MCLK is ready),
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);
    audioOverheat= FALSE;
    
#ifdef HAS_DSP_TUNING_DETECT
    dspTuneCurr= FALSE;
    dspTuneTmp= FALSE;
    debounceTick= 0;
#endif    

    //Initialize Audio ADC pins
    audioAdcDrv.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(audioAdcDrv.ADCConfig);
    ADCDrv_Ctor(&audioAdcDrv, audioAdcDrv.ADCConfig);
    ADCDrv_StartScanning(&audioAdcDrv);    
    
    //Initialize Audio GPIO pins
    audioGpioDrv.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(audioGpioDrv.gpioConfig);
    GpioDrv_Ctor(&audioGpioDrv, audioGpioDrv.gpioConfig);
    
    //Initialize DSP
    dspI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cDrv.pConfig);
    DSPDrv1451_Ctor(&dspAdau1451Drv, &dspI2cDrv);

    //Shutdown all amplifier
    AMP_SHUTDOWN(audioGpioDrv); //pull low SDZ
    
    //Enable power for DSP/AMP/NTC
    //SYSPWR_ENABLE(audioGpioDrv);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    AudioAmpDrv_Xtor(&audioAmpWoofer1Drv);
    AudioAmpDrv_Xtor(&audioAmpWoofer2Drv);
    AudioAmpDrv_Xtor(&audioAmpMidDrv);
    AudioAmpDrv_Xtor(&audioAmpTweeterDrv);
    AdcDrv_pcm1862_Xtor(&adcPcm1862);
    DSPDrv1451_Xtor(&dspAdau1451Drv);
    
    //Disable power for DSP/AMP/NTC
    SYSPWR_DISABLE(audioGpioDrv);    

    //Shutdown all amplifier
    AMP_SHUTDOWN(audioGpioDrv); //pull low SDZ        

    Setting_Reset(SETID_TEMP_LEVEL_AUDIO);

    Setting_Reset(SETID_TEMP_WF_AMP_1);
    Setting_Reset(SETID_TEMP_WF_AMP_2);
    Setting_Reset(SETID_TEMP_WF_SPK);
    Setting_Reset(SETID_TEMP_MID_SPK_A);
    Setting_Reset(SETID_TEMP_MID_SPK_B);
    Setting_Reset(SETID_TEMP_TW_AMP);

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {        
        if(me->nextDelayTime == 0)
        {
            //Enable power for ADC/DSP/AMP/NTC
            SYSPWR_ENABLE(audioGpioDrv);
        }

        me->nextDelayTime = DSPDrv1451_Init(&dspAdau1451Drv);            
        if(me->nextDelayTime == 0) 
        {         
            //Read DSP Version
            float fVer= DSPDrv1451_GetDspVer(&dspAdau1451Drv);
            char dspVersion[DSP_VERSION_LENGTH]= {0};
            snprintf(dspVersion, sizeof(dspVersion), "%0.1f", fVer);
            Setting_Set(SETID_DSP_VER, dspVersion);
            
            
#ifdef MCU_STORE_DSP_GAIN
            //Set DSP calibration gain, read 0xFFFFFFFF means never set
            #define SETTING_INAVLID_VALUE  0xFFFFFFFF
            const float defaultGainDb= 0.0;

            //Set Woofer gain
            const float* p_gainLinearWoofer=  Setting_Get(SETID_DSP_CAL_GAIN1_WF);    //Woofer (gain1)            
            if((*(uint32*)p_gainLinearWoofer)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have WOOFER gain: %f ***\r\n\r\n", *p_gainLinearWoofer);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, *p_gainLinearWoofer);
            }
            else {
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have WOOFER gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN1_WF, &defaultGainDb);
            }
            
            //Set Middle-A gain
            const float* p_gainLinearMidA=  Setting_Get(SETID_DSP_CAL_GAIN2_MID_A); //Middle A (gain2)
            if((*(uint32*)p_gainLinearMidA)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have MIDDLE-A gain: %f ***\r\n\r\n", *p_gainLinearMidA);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, *p_gainLinearMidA);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have MIDDLE-A gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN2_TW, &defaultGainDb);
            }
            
            //Set Middle-B gain
            const float* p_gainLinearMidB= Setting_Get(SETID_DSP_CAL_GAIN3_MID_B); //Middle B (gain3)
            if((*(uint32*)p_gainLinearMidB)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have MIDDLE-B gain: %f ***\r\n\r\n", *p_gainLinearMidB);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, *p_gainLinearMidB);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have MIDDLE-B gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN3_MID_B, &defaultGainDb);
            }
            
            //Set Tweeter gain
            const float* p_gainLinearTweeter=  Setting_Get(SETID_DSP_CAL_GAIN4_TW);    //Tweeter (gain4)
            if((*(uint32*)p_gainLinearTweeter)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have TWETTER gain: %f ***\r\n\r\n", *p_gainLinearTweeter);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, *p_gainLinearTweeter);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have TWETTER gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, defaultGainDb);
                //Setting_Set(DSP_CAL_GAIN4_ID, &defaultGainDb);
            }
#else
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, 0.0/*dB*/);
#endif

            /* Set default volume
             * Note ASE-TK may output noise when bootup, thus we must set ZERO volume before AES-TK boot up.
             */
            //uint32 vol_readback= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, /*reg:*/ADAU1451_VOLUME_ADDR);
            //TP_PRINTF("\r\n\r\n\r\nDSP flow initial vol = %d\r\n\r\n\r\n", vol_readback);
            DSPDrv1451_SetVol(&dspAdau1451Drv, /*vol*/0);
            
            /* set linein sensitivity default gain (medium) 6dB*/
            uint8 sensitivityLineIn = (uint8)AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM;
            Setting_Set(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
            AudioDrv_SetAudio(me, AUDIO_LINEIN_SENSITIVITY_SETT_ID, TRUE, (uint32)AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM, /*NOT USED*/0);

            
            //Set DSP channel
            DSPDrv1451_SetInputChannel(&dspAdau1451Drv, AUDIO_CHANNEL_I2S_1); //ASE-TK

            //Initialize ADC: PCM1862
            adcPcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_ADC_DEV_ID, NULL);
            ASSERT(adcPcm1862i2cObj.pConfig);
            AdcDrv_pcm1862_Ctor(&adcPcm1862, &adcPcm1862i2cObj);
            AdcDrv_pcm1862_Init(&adcPcm1862);
            AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_INPUT1);
            AdcDrv_pcm1862_SetPGA(&adcPcm1862, PCM1862_PGA_6dB);
            AdcDrv_pcm1862_enableAGC(&adcPcm1862, /*enable:*/FALSE); //AGC feature have problem on MOFA, should disable it

            //Initialize Woofer Amplifier 1
            TP_PRINTF("Init Woofer Amplifier 1\r\n");
            ampWoofer1I2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_WOOFER_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampWoofer1I2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpWoofer1Drv, &ampWoofer1I2cDrv);

            //Initialize Woofer Amplifier 2
            TP_PRINTF("Init Woofer Amplifier 2\r\n");
            ampWoofer2I2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_WOOFER_2_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampWoofer2I2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpWoofer2Drv, &ampWoofer2I2cDrv);

            //Initialize Middle Amplifier
            TP_PRINTF("Init Middle Amplifier\r\n");
            ampMidI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_MIDDLE_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampMidI2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpMidDrv, &ampMidI2cDrv);

            //Initialize Tweeter Amplifier
            TP_PRINTF("Init Tweeter Amplifier\r\n");
            ampTweeterI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_TWEETER_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampTweeterI2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpTweeterDrv, &ampTweeterI2cDrv);
            
            /* 1. Set amplifer to PBTL mode, means two output to one speaker
             * 2. Datasheet said, PBTL select right channel when REG[6].bit1==1, left chanel when REG[6].bit1==0.
             *    But accurary result is inverse.
             * 2. Vpk should < amplifier PVDD(15~24v), or analog output will clip on PVDD
             */
            //TODO: move this customization to attachedDevices.c
            TP_PRINTF("Set Amplifier Analog Control\r\n");
            AudioAmpDrv_setAnalogControl(&audioAmpWoofer1Drv, 0x99); //PBTL=1, PWM Rate=LRCK*8=384KHz, Analog Gain=25dBV(Vpk=25.15V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpWoofer2Drv, 0x99); //PBTL=1, PWM Rate=LRCK*8=384KHz, Analog Gain=25dBV(Vpk=25.15V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpMidDrv,     0x39); //PBTL=0, PWM Rate=LRCK*12=576KHz, Analog Gain=25dBV(Vpk=25.15V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpTweeterDrv, 0xB9); //PBTL=1, PWM Rate=LRCK*12=576KHz, Analog Gain=25dBV(Vpk=25.15V), PBTL Channel selection=right

            /* It is important to note that control port register changes should only occur when the device is placed into
             *  shutdown. This can be accomplished either by pulling the SPK_SD pin "LOW" or clearing the SPK_SD bit in the
             *  control port.
             */            
            /* Pull SDZ to high after I2C programming */
            AMP_WAKEUP(audioGpioDrv);
            
            //AudioAmpDrv_printError(&audioAmpWoofer1Drv);
            AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/TRUE);
            AudioAmpDrv_setShutdown(&audioAmpWoofer1Drv, TRUE);
            AudioAmpDrv_setShutdown(&audioAmpWoofer2Drv, TRUE);
            AudioAmpDrv_setShutdown(&audioAmpMidDrv,     TRUE);
            AudioAmpDrv_setShutdown(&audioAmpTweeterDrv, TRUE);
            
            //Finish
            me->drvIsReady = TRUE;
            memset(&volFadeParam, 0, sizeof(volFadeParam));
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            bool musicDet= FALSE;
            Setting_Set(SETID_MUSIC_DET, &musicDet);
            volFadeParam.isFadingInProg = FALSE;
            uint8 defaultVol = 0;
            Setting_Set(SETID_VOLUME, &defaultVol);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetInputChannel(&dspAdau1451Drv, audioChannel);
}


void AudioDrv_dumpAmpReg(void)
{
    AudioAmpDrv_dumpReg(&audioAmpWoofer1Drv, "ampWoofer1");
    AudioAmpDrv_dumpReg(&audioAmpWoofer2Drv, "ampWoofer2"); 
    AudioAmpDrv_dumpReg(&audioAmpMidDrv,     "ampMid"); 
    AudioAmpDrv_dumpReg(&audioAmpTweeterDrv, "ampTweeter"); 
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *me)
{
    AudioDrv_CheckMusicStreamStatus();
    AudioDrv_AmpHealthMonitor(me);
    AudioDrv_AmpSafetyMonitor(me);
#ifdef HAS_DSP_TUNING_DETECT    
    AudioDrv_DspTuneUpdate(me);
#endif
}


/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    bool preStatus = *(bool*)Setting_Get(SETID_MUSIC_DET);
    bool hasMusicStream = preStatus;

    if (musicDetTimer > 0)
    {
        if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            //DSPDrv1451_ReadAsrcConversionRate(&dspAdau1451Drv, DSP_ASRC0); //DSP_ASRC_FROM_ASETK
            //DSPDrv1451_GetDspVer(&dspAdau1451Drv);
            
            hasMusicStream = DSPDrv1451_AuxinHasMusicStream(&dspAdau1451Drv);
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            if (preStatus != hasMusicStream)
            {
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = hasMusicStream;
                Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("\r\n\r\n*** Aux-in music states is %d ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            }
        }
    }
}


static void AudioDrv_SetFadeVolume(cAudioDrv *me, uint32 target_volume, uint32 fade_duration)
{
    if (volFadeParam.isFadingInProg == TRUE)
    {
        TP_PRINTF("    Volume fade: Stop previous fade volume and start new one\r\n");
        bool ret= Timer_StopTimer(volFadeTimerId);
        ASSERT(ret); //FALSE means Fade volume timer is not running
    }
    
        
    /* The start volume should always be equal to current volume. */
    uint8 start_volume = *(uint8*)Setting_Get(SETID_VOLUME);
    uint32 fadeRange = TYM_DIFF(target_volume, start_volume);
    
    
    //deubg
    AseTkSrv_ReplyVolumeFade(start_volume);
        
        
    /* fade_duration should not be zero, because it is denominator to calculate fadeStep */
    if(fade_duration < ADUIO_MIN_FADE_STEP)
    {
        fade_duration= ADUIO_MIN_FADE_STEP;
    }
    
    if(((fadeRange <= (MAX_VOLUME - MIN_VOLUME)) && fadeRange > 0)
        && (target_volume >= MIN_VOLUME && target_volume <= MAX_VOLUME)
        && (start_volume >= MIN_VOLUME && start_volume <= MAX_VOLUME))
    {
        volFadeParam.fadeType     = (target_volume > start_volume)? TRUE : FALSE;
        volFadeParam.fadeStep     = ADUIO_MIN_FADE_STEP;
        volFadeParam.fadeStepTime = (fade_duration * volFadeParam.fadeStep)/fadeRange;
        volFadeParam.targetVol    = target_volume;
        volFadeParam.isFadingInProg = TRUE;
        if(ADUIO_MIN_FADE_STEP_TIME > volFadeParam.fadeStepTime)
        {
            volFadeParam.fadeStepTime = ADUIO_MIN_FADE_STEP_TIME;
            volFadeParam.fadeStep = (volFadeParam.fadeStepTime * fadeRange)/fade_duration;
            ASSERT(volFadeParam.fadeStep>0);
        }
        Timer_StartTimer((uint32)volFadeParam.fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, &volFadeParam);
    }
    else
    {
        TP_PRINTF("The volume fade parameters are invalid. \r\n");
        AseTkSrv_ReplyVolumeFade(start_volume); //reply current volume
    }
    

}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady)) {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch (audioSettId)
    {
        case DSP_CAL_GAIN1_ID:
        case DSP_CAL_GAIN2_ID:
        case DSP_CAL_GAIN3_ID:
        case DSP_CAL_GAIN4_ID:
        {
            float fGainDb= *((float*)&param);
            TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_CAL_GAINx_ID, gain=%1.2f\r\n", audioSettId, fGainDb);
            AudioDrv_DspCalGainSetId_Handler(audioSettId, fGainDb);
            break;
        }        
            
        case DSP_VOLUME_SETT_ID:
            //TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_VOLUME_SETT_ID\r\n", audioSettId);
            if(!volFadeParam.isFadingInProg)
            {
                uint8 volume= (uint8)param;
                Setting_Set(SETID_VOLUME, &volume);
                AudioDrv_DspVolSetId_Handler();
            }
            break;

        case DSP_PASSTHROUGH_SETT_ID:
            TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_PASSTHROUGH_SETT_ID, bypass=%d\r\n", audioSettId, enabled);
            DSPDrv1451_SetPassthrough(&dspAdau1451Drv, enabled);
            break;
            
        case AMP_SLEEP_MODE_ID:
            if(!audioOverheat)
            {
                TP_PRINTF("AudioDrv_SetAudio: AMP_SLEEP_MODE_ID, enabled=%d\r\n", enabled);
                AudioAmpDrv_setShutdown(&audioAmpWoofer1Drv, enabled);
                AudioAmpDrv_setShutdown(&audioAmpWoofer2Drv, enabled);
                AudioAmpDrv_setShutdown(&audioAmpMidDrv,     enabled);
                AudioAmpDrv_setShutdown(&audioAmpTweeterDrv, enabled);
            }
            break;
            
        case AUDIO_OVERHEAT_MODE_ID:
            AudioDrv_SetOverheat(me, enabled);
            break;
            
        case DSP_TUNNING_SETT_ID:
            /* DSP and AMP I2C bus should be disable when tuning DSP. */
            DSPDrv1451_I2cEnable(&dspAdau1451Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpWoofer1Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpWoofer2Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpMidDrv,     !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpTweeterDrv, !enabled);
            break;
            
        case AUDIO_VOL_FADE_SETT_ID:
        {
            uint32 target_volume= param;
            uint32 fade_duration= param2;
            AudioDrv_SetFadeVolume(me, target_volume, fade_duration);
            break;
        }
        case AUDIO_LINEIN_SENSITIVITY_SETT_ID:
        {
            eLineinSensitivity lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
            switch ((AseFepSetLineInSensitivity_LineInSensitivity)param)
            {
            case AseFepSetLineInSensitivity_LineInSensitivity_HIGH:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_HIGH;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_MEDIUM;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_LOW:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_LOW;
                break;
                case AseFepSetLineInSensitivity_LineInSensitivity_DISABLED:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
                    break;
                default:
                break;
            }
            DSPDrv1451_SetLineInSensitivity(&dspAdau1451Drv, lineInSensitivityLvl);
            break;
        }

        default:
             break;
    }
}


static void AudioDrv_DspCalGainSetId_Handler(eAudioSettId audioSettId, float fGainDb)
{
   int32 ctlId= AudioDrv_GetCrtIdIndex(audioSettId);
   ASSERT(ctlId>=0); //-1 means fail
   DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, audioSettId, fGainDb);
}

static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack\r\n");
    
    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
    /* get current volume value */
    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);

    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack: fadeType=%d, step=%d, vol:(curr=%d,tgt=%d) \r\n", 
    //            pVolFadeParam->fadeType, pVolFadeParam->fadeStep, volLevel, pVolFadeParam->targetVol);
    
    ASSERT(pVolFadeParam->isFadingInProg==TRUE);

    /* For issue FS-202, sometimes AudioDrv_VolFadeTimerCallBack() repeated execute and set the same volume.
     * The only possible condition is fadeStep==0, but there is no reason for it.
     * Before find root cause, we add workaround here.
     */
    if(pVolFadeParam->fadeStep==0)
    {
        ASSERT(0);
        TP_PRINTF("\r\n\r\n\r\n*** ERROR: AudioDrv_VolFadeTimerCallBack fadeStep==0 ***\r\n\r\n\r\n\r\n");
        return;
    }
    
    /* change volume*/
    if(pVolFadeParam->fadeType)
    {
        /* volume fade up*/
        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = MAX_VOLUME;
        }
        else
        {
            volLevel += pVolFadeParam->fadeStep;
        }
    }
    else
    {
        /* volume fade down*/
        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
        {
            volLevel = MIN_VOLUME;
        }
        else
        {
            volLevel -= pVolFadeParam->fadeStep;
        }
    }
    Setting_Set(SETID_VOLUME, &volLevel);
    AudioDrv_DspVolSetId_Handler();

    if((volLevel != pVolFadeParam->targetVol)
        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
    {
        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
    }
    else
    {
        /* Reply Ase-tk when volume fade completed. */
        AseTkSrv_ReplyVolumeFade(volLevel);
        pVolFadeParam->isFadingInProg = FALSE;
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    ASSERT(muteType < AUDIO_MUTE_TYPE_MAX);
    switch (muteType)
    {
        case AUDIO_AMP_SOFT_MUTE:
            TP_PRINTF("AudioDrv_Mute: mute=%d\r\n", muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpWoofer1Drv, muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpWoofer2Drv, muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpMidDrv,     muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpTweeterDrv, muteEnable);
            break;
        default:
            //Support only soft mute
            ASSERT(0);
            break;
    }
 }
    
/**
 * Function to mute specific channel (Woofer, MiddleA, MiddleB, Tweeter).
 * @param[in]   channel_maks    This parameter defines which channels should be muted.
 * Bit 3 corresponds to: Woofer,- 1 to mute; 0 - to unmute.
 * Bit 2 corresponds to: MiddleA,- 1 to mute; 0 - to unmute.
 * Bit 1 corresponds to: MiddleB,- 1 to mute; 0 - to unmute.
 * Bit 0 corresponds to: Tweeter,- 1 to mute; 0 - to unmute.
 * For example to mute only Woofer, MiddleA and MiddleB  and unmute Tweeter
 * channel mask will be : 0000 0000 0000 0000 0000 0000 0000 1110  ( 0x000E )
 *
 */
void AudioDrv_MuteChannel(uint32 channel_mask)
{
    if (channel_mask & AUDIO_WOOFER_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_MIDDLEA_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_MIDDLEB_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_TWEETER_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, FALSE);
    }
}


    
 static void AudioDrv_DspVolSetId_Handler(void)
 {
    uint8 volumeLevel = MIN_VOLUME;
    
    int32 ctlId= AudioDrv_GetCrtIdIndex(DSP_VOLUME_SETT_ID);
    ASSERT(ctlId>=0); //-1 means fail   
    
     volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[ctlId].settingId);
     if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
     {
         DSPDrv1451_SetVol(&dspAdau1451Drv, volumeLevel);
     }
     else
     {
         ASSERT(0);
     }    
 }
    

//return -1 means can not find
static int32 AudioDrv_GetCrtIdIndex(eAudioSettId audioSettId)
{
    int32 ret= -1;
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(audioSettId == ctrIdEQIdMap[i].dspSettid)
        {
            ret= i;
            break;
        }
    } 
    
    return ret;
}


static uint16 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint16 degreeC;

    for (degreeC = 0; degreeC < TEMPERATURE_POSITIONS_NUM; degreeC++)
    {
        if (ntcValue >= audioNtcTempTable[degreeC])
        {
            break;
        }
    }
    return degreeC;
}


static void AudioDrv_SetOverheat(cAudioDrv *me, bool overheat)
{  
    /* audioOverheat occurs: Shutdown ampliifer for over-heat
     * recover from audioOverheat: do nothing, but allow MainApp to wakeup amplifier
     */
    TP_PRINTF("AudioDrv_SetOverheat: overheat=%d\r\n", overheat);
    audioOverheat= overheat;
    if(overheat) 
    {
        AMP_SHUTDOWN(audioGpioDrv);
    }
    else
    {
        AMP_WAKEUP(audioGpioDrv);
    }
}

static void AudioDrv_AmpHealthMonitor(cAudioDrv *me)
{
    bool amp_health = 0;
    bool ampWoofer1_error = FALSE;
    bool ampWoofer2_error = FALSE;
    bool ampMid_error     = FALSE;
    bool ampTweeter_error = FALSE;

    /* bit0: over-temperature error
     * bit1: output dc error
     * bit2: over current error
     * bit3: clock erorr
     */
    AudioAmpDrv_getErrorStatus(&audioAmpWoofer1Drv, &ampWoofer1_error);
    AudioAmpDrv_getErrorStatus(&audioAmpWoofer2Drv, &ampWoofer2_error);
    AudioAmpDrv_getErrorStatus(&audioAmpMidDrv,     &ampMid_error);
    AudioAmpDrv_getErrorStatus(&audioAmpTweeterDrv, &ampTweeter_error);

    amp_health = !(ampWoofer1_error || ampWoofer2_error || ampMid_error || ampTweeter_error);
    
    /* byte[3]: woofer1 amplifier reason 
     * byte[2]: woofer2 amplifier reason 
     * byte[1]: middle amplifier reason 
     * byte[0]: tweeter amplifier reason 
     */
    uint32 ampErrorReason= (ampWoofer1_error<<24) | (ampWoofer2_error<<16) | (ampMid_error<<8) | ampTweeter_error;
    Setting_Set(SETID_AMP_ERROR_REASON, &ampErrorReason);

    bool amp_healthPrev= TRUE;    
    amp_healthPrev= *(bool*)Setting_GetEx(SETID_AMP_HEALTH, &amp_healthPrev);
    Setting_Set(SETID_AMP_HEALTH, &amp_health);
 
    if(amp_healthPrev!=amp_health)
    {
        TP_PRINTF("\r\n\r\n\r\n*** AMP_HEALTH: %d (error reason: wf1:0x%x, wf2:0x%x, mid:0x%x, tw:0x%x) ***\r\n\r\n\r\n", amp_health, ampWoofer1_error, ampWoofer2_error, ampMid_error, ampTweeter_error);
    }    
}


static void AudioDrv_AmpSafetyMonitor(cAudioDrv *me)
{  
    uint16  tempWfAmp1New  = 0;
    uint16  tempWfAmp2New  = 0;
    uint16  tempWfSpkNew     = 0;
    uint16  tempMidSpkANew   = 0;
    uint16  tempMidSpkBNew   = 0;
    uint16  tempTwAmpNew     = 0;   
    eTempLevel tempLevelAudioNew = TL_NORMAL;
    int32 rawResult= 0;
    ASSERT(audioAdcDrv.isCreated);
    
    
    //(1)Get temperature for Woofer amplifier 1
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_1);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfAmp1New = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempWfAmp1New, &tempWfAmp1, &tempLevelWfAmp1, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_WF_AMP_1, &tempWfAmp1);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_1_REGISTER, (uint32)tempWfAmp1New);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_1_REGISTER);
        //TP_PRINTF("DSP Read back tempWfAmp1= %d\r\n", value);
    }
    
    
    //(2)Get temperature for Woofer amplifier 2
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_2);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfAmp2New = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempWfAmp2New, &tempWfAmp2, &tempLevelWfAmp2, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_WF_AMP_2, &tempWfAmp2);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_2_REGISTER, (uint32)tempWfAmp2New);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_2_REGISTER);
        //TP_PRINTF("DSP Read back tempWfAmp2= %d\r\n", value);
    }

    
    //(3)Get temperature for Woofer speaker 
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_SPK);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfSpkNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempWfSpkNew, &tempWfSpk, &tempLevelWfSpk, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_WF_SPK, &tempWfSpk);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_SPK_REGISTER, (uint32)tempWfSpkNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_SPK_REGISTER);
        //TP_PRINTF("DSP Read back tempWfSpkNew= %d\r\n", value);
    }
   
    
    //(4)Get temperature for Middle spekaer A
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_A);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempMidSpkANew = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempMidSpkANew, &tempMidSpkA, &tempLevelMidSpkA, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_MID_SPK_A, &tempMidSpkA);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_A_REGISTER, (uint32)tempMidSpkANew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_A_REGISTER);
        //TP_PRINTF("DSP Read back tempMidSpkA= %d\r\n", value);
    }
   
    
    //(5)Get temperature for Middle spekaer B
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_B);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempMidSpkBNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempMidSpkBNew, &tempMidSpkB, &tempLevelMidSpkB, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_MID_SPK_B, &tempMidSpkB);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_B_REGISTER, (uint32)tempMidSpkBNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_B_REGISTER);
        //TP_PRINTF("DSP Read back tempMidSpkB= %d\r\n", value);
    }
   
    
    //(6)Get temperature for Tweeter Amplifier
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_TW_AMP);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempTwAmpNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        PowerDrv_UpdateTempLevel(tempTwAmpNew, &tempTwAmp, &tempLevelTwAmp, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_TW_AMP, &tempTwAmp);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_TW_AMP_REGISTER, (uint32)tempTwAmpNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_TW_AMP_REGISTER);
        //TP_PRINTF("DSP Read back tempTwAmp= %d\r\n", value);
    }
    

    //(4)Error Handling
    tempLevelAudioNew= MIN6(tempLevelWfAmp1, tempLevelWfAmp2, tempLevelWfSpk, tempLevelMidSpkA, tempLevelMidSpkB, tempLevelTwAmp);
//    if(tempLevelAudio!=tempLevelAudioNew)
//    {
//        switch(tempLevelAudioNew)
//        {
//        case TL_CRITICAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (CRITICAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_SERIOUS:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (SERIOUS) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_WARN:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (WARN) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//       
//        case TL_NORMAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (NORMAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);            
//            AudioDrv_SetOverheat(me, FALSE);
//            break;
//             
//        default:
//            ASSERT(0);
//            break;
//        }
//    }
    tempLevelAudio= tempLevelAudioNew;
    Setting_Set(SETID_TEMP_LEVEL_AUDIO, &tempLevelAudioNew);
    
    
    //(5)Continues ADC scanning
    ADCDrv_StartScanning(&audioAdcDrv);
    
    
    //(6)Print every 10sec (AUDIO_PRINT_PREIOD_IN_MS)
    static int32 timeoutTick= 0;
    timeoutTick--;
    if(timeoutTick<=0)
    {   
        timeoutTick= AUDIO_PRINT_PREIOD_IN_MS / AUDIO_SRV_TIMEOUT_IN_MS;
        TP_PRINTF("Temp: WfAmp1=%dC(L%d), WfAmp2=%dC(L%d), WfSpk=%dC(L%d), MidSpkA=%dC(L%d), MidSpkB=%dC(L%d), TwAmp=%dC(L%d) ==> audio=(L%d)\r\n", 
                      tempWfAmp1,   tempLevelWfAmp1,
                      tempWfAmp2,   tempLevelWfAmp2,
                      tempWfSpk,    tempLevelWfSpk,
                      tempMidSpkA,  tempLevelMidSpkA,
                      tempMidSpkB,  tempLevelMidSpkB,
                      tempTwAmp,    tempLevelTwAmp,
                      tempLevelAudio);
    }
}


#ifdef HAS_DSP_TUNING_DETECT    
static void AudioDrv_DspTuneUpdate(cAudioDrv *me)
{
    /* When insert DSP USBi cable, PA15 get high input from PA15,
     * but noise cause it trigger low sometime. Thus we need to debounce here.
     */
     
    //debounce for 0.5 seconds
    const uint32 timeoutTick= 100 / AUDIO_SRV_TIMEOUT_IN_MS;
    int8 dspTuneNew= GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_DSP_TUNE);
    
    if(dspTuneTmp != dspTuneNew) 
    {   //(Step-1) start debounce different DspTune
        debounceTick= 0;
        TP_PRINTF("DspTune (1)\r\n");
    }
    else
    {
        if(dspTuneCurr != dspTuneNew)
        {
            if( debounceTick < timeoutTick )
            {   //(Step-2) wait DspTune hold for 1s
                debounceTick++;
                TP_PRINTF("DspTune (2)\r\n");
            }
            else
            {   //(Setep-3) timeout, apply DspTune change, and turn on amplifier
                //When set dspTuneCurr, audio driver never turn off amplifier
                TP_PRINTF("DSP-TUNE= %d\r\n", dspTuneNew);
                if( dspTuneNew )
                {   //Enable amplifier when DSP cable insert
                    AudioDrv_SetAudio(me, AMP_SLEEP_MODE_ID, FALSE, /*not used*/0, /*not used*/0);
                    AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/FALSE);
                }
                DSPDrv1451_I2cEnable(&dspAdau1451Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer1Drv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer2Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpMidDrv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpTweeterDrv, !dspTuneNew);
                debounceTick= 0;
                dspTuneCurr= dspTuneNew;
            }
        }
        else
        {
            //(Step-4) DspTune not change
        }
    }
    dspTuneTmp= dspTuneNew;
}
#endif /* HAS_DSP_TUNING_DETECT */


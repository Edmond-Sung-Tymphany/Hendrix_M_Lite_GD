/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Audio Driver have three layer DISABLE operation.
1. SW Mute     -> FepAseCommand_Command_MUTE, FepAseCommand_Command_UNMUTE
2. SW Shutdown -> AseFepEvent_Event_SYSTEM_STATUS_STANDBY, AseFepEvent_Event_SYSTEM_STATUS_ON
3. HW Shutdown -> Overheat occurs/recover

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "PowerDrv_v2.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AseNgSrv.h"
#include "I2CDrv.h"
#include "ADCDrv.h"
#include "GPIODrv.h"
#include "DspDrv1451.h"
#include "AmpDrvTas5760.h"
#include "timer.h"
#include "AudioDrv.config"
#include "AudioSrv.config"
#include "pcm1862Drv.h"
#include "math.h"


/***********************************************
 * Type
 ***********************************************/
typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_CAL_GAIN1_ID,    SETID_DSP_CAL_GAIN1_WF},
    {DSP_CAL_GAIN2_ID,    SETID_DSP_CAL_GAIN2_MID_A},
    {DSP_CAL_GAIN3_ID,    SETID_DSP_CAL_GAIN3_MID_B},
    {DSP_CAL_GAIN4_ID,    SETID_DSP_CAL_GAIN4_TW},
    
};

extern float DSPDrv1451_ReadInputAuxinVolume(cDSPDrv1451 *me);

/***********************************************
 * Global Variable
 ***********************************************/
static cI2CDrv      dspI2cDrv;
static cDSPDrv1451  dspAdau1451Drv;

static cI2CDrv      ampWoofer1I2cDrv;
static cAudioAmpDrv audioAmpWoofer1Drv;

static cI2CDrv      ampWoofer2I2cDrv;
static cAudioAmpDrv audioAmpWoofer2Drv;

static cI2CDrv      ampMidI2cDrv;
static cAudioAmpDrv audioAmpMidDrv;

static cI2CDrv      ampTweeterI2cDrv;
static cAudioAmpDrv audioAmpTweeterDrv;

static cADCDrv      audioAdcDrv;

static cI2CDrv          adcPcm1862i2cObj;
static cAdcDrv_pcm1862  adcPcm1862;

static cGpioDrv audioGpioDrv;

static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static bool audioOverheat= FALSE;

#ifdef HAS_DSP_TUNING_DETECT
static bool dspTuneCurr= FALSE;
static bool dspTuneTmp= FALSE;
static uint32 debounceTick= 0; //the time to hold the same DspTune value
#endif

static uint16        tempWfAmp1    = 0;
static uint16        tempWfAmp2    = 0;
static uint16        tempWfSpk     = 0;
static uint16        tempMidSpkA   = 0;
static uint16        tempMidSpkB   = 0;
static uint16        tempTwAmp     = 0;

static eTempLevel    tempLevelWfAmp1  = TL_NORMAL;
static eTempLevel    tempLevelWfAmp2  = TL_NORMAL;
static eTempLevel    tempLevelWfSpk   = TL_NORMAL;
static eTempLevel    tempLevelMidSpkA = TL_NORMAL;
static eTempLevel    tempLevelMidSpkB = TL_NORMAL;
static eTempLevel    tempLevelTwAmp   = TL_NORMAL;

static eTempLevel    tempLevelAudio   = TL_NORMAL;


/* fading volume */
static uint16 volFadeTimerId= 0;
static tVolFadeParam volFadeParam= {0};
static uint32 volFadeReqId = 0;

//Aux in detect
static float auxin_input_db_smooth= -90.0;
static bool hasMusicStream_DebNew= FALSE;
static bool hasMusicStream_DebPre= FALSE;
static uint32 auxin_detect_debounce_msec= 0;


hwVersionTag hwVersionArray[] =
{
    {"MP2",     0,    400 },
    {"PVT",     400,  750 },
    {"DVT2",    750,  1100},
    {"DVT1",    1100, 1450},
    {"EVT2",    1450, 1750},
    {"EVT1",    1750, 2200},
    {"ES3",     2200, 2700},
    {"ES2",     2700, 3150},
    {"ES1",     3150, 3500},
    {"PRE-ES",  3500, 3900},
    {"MP",      3900, 4095},
};



/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds (after ASE-TK MCLK is ready),
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);
    audioOverheat= FALSE;
    
#ifdef HAS_DSP_TUNING_DETECT
    dspTuneCurr= FALSE;
    dspTuneTmp= FALSE;
    debounceTick= 0;
#endif
    
    //Initialize Aux-in detect
    auxin_input_db_smooth= -90.0;
    hasMusicStream_DebNew= FALSE;
    hasMusicStream_DebPre= FALSE;
    auxin_detect_debounce_msec= 0;

    //Initialize Audio ADC pins
    audioAdcDrv.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(audioAdcDrv.ADCConfig);
    ADCDrv_Ctor(&audioAdcDrv, audioAdcDrv.ADCConfig);
    ADCDrv_StartScanning(&audioAdcDrv);    
    
    //Initialize Audio GPIO pins
    audioGpioDrv.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(audioGpioDrv.gpioConfig);
    GpioDrv_Ctor(&audioGpioDrv, audioGpioDrv.gpioConfig);
    
    //Initialize DSP
    dspI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cDrv.pConfig);
    DSPDrv1451_Ctor(&dspAdau1451Drv, &dspI2cDrv);

    //Shutdown all amplifier
    AMP_SHUTDOWN(audioGpioDrv); //pull low SDZ
    
    //Enable power for DSP/AMP/NTC
    //SYSPWR_ENABLE(audioGpioDrv);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    AudioAmpDrv_Xtor(&audioAmpWoofer1Drv);
    AudioAmpDrv_Xtor(&audioAmpWoofer2Drv);
    AudioAmpDrv_Xtor(&audioAmpMidDrv);
    AudioAmpDrv_Xtor(&audioAmpTweeterDrv);
    AdcDrv_pcm1862_Xtor(&adcPcm1862);
    DSPDrv1451_Xtor(&dspAdau1451Drv);
    
    //Disable power for DSP/AMP/NTC
    SYSPWR_DISABLE(audioGpioDrv);    

    //Shutdown all amplifier
    AMP_SHUTDOWN(audioGpioDrv); //pull low SDZ        

    Setting_Reset(SETID_TEMP_LEVEL_AUDIO);

    Setting_Reset(SETID_TEMP_WF_AMP_1);
    Setting_Reset(SETID_TEMP_WF_AMP_2);
    Setting_Reset(SETID_TEMP_WF_SPK);
    Setting_Reset(SETID_TEMP_MID_SPK_A);
    Setting_Reset(SETID_TEMP_MID_SPK_B);
    Setting_Reset(SETID_TEMP_TW_AMP);

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {        
        if(me->nextDelayTime == 0)
        {
            //Enable power for ADC/DSP/AMP/NTC
            SYSPWR_ENABLE(audioGpioDrv);
            AudioDrv_UpdateHwVer();
        }

        me->nextDelayTime = DSPDrv1451_Init(&dspAdau1451Drv);            
        if(me->nextDelayTime == 0) 
        {         
            //Read DSP Version
            float fVer= DSPDrv1451_GetDspVer(&dspAdau1451Drv);
            char dspVersion[DSP_VERSION_LENGTH]= {0};
            snprintf(dspVersion, sizeof(dspVersion), "%0.2f", fVer);
            Setting_Set(SETID_DSP_VER, dspVersion);

#ifdef MCU_STORE_DSP_GAIN
            //Set DSP calibration gain, read 0xFFFFFFFF means never set
            #define SETTING_INAVLID_VALUE  0xFFFFFFFF
            const float defaultGainDb= 0.0;

            //Set Woofer gain
            const float* p_gainLinearWoofer=  Setting_Get(SETID_DSP_CAL_GAIN1_WF);    //Woofer (gain1)            
            if((*(uint32*)p_gainLinearWoofer)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have WOOFER gain: %f ***\r\n\r\n", *p_gainLinearWoofer);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, *p_gainLinearWoofer);
            }
            else {
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have WOOFER gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN1_WF, &defaultGainDb);
            }
            
            //Set Middle-A gain
            const float* p_gainLinearMidA=  Setting_Get(SETID_DSP_CAL_GAIN2_MID_A); //Middle A (gain2)
            if((*(uint32*)p_gainLinearMidA)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have MIDDLE-A gain: %f ***\r\n\r\n", *p_gainLinearMidA);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, *p_gainLinearMidA);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have MIDDLE-A gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN2_TW, &defaultGainDb);
            }
            
            //Set Middle-B gain
            const float* p_gainLinearMidB= Setting_Get(SETID_DSP_CAL_GAIN3_MID_B); //Middle B (gain3)
            if((*(uint32*)p_gainLinearMidB)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have MIDDLE-B gain: %f ***\r\n\r\n", *p_gainLinearMidB);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, *p_gainLinearMidB);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have MIDDLE-B gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, defaultGainDb);
                //Setting_Set(SETID_DSP_CAL_GAIN3_MID_B, &defaultGainDb);
            }
            
            //Set Tweeter gain
            const float* p_gainLinearTweeter=  Setting_Get(SETID_DSP_CAL_GAIN4_TW);    //Tweeter (gain4)
            if((*(uint32*)p_gainLinearTweeter)!=SETTING_INAVLID_VALUE) {
                TP_PRINTF("\r\n\r\n*** DSP: Flash have TWETTER gain: %f ***\r\n\r\n", *p_gainLinearTweeter);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, *p_gainLinearTweeter);
            }
            else {              
                TP_PRINTF("\r\n\r\n*** DSP: Flash do not have TWETTER gain, set default: %f ***\r\n\r\n", defaultGainDb);
                DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, defaultGainDb);
                //Setting_Set(DSP_CAL_GAIN4_ID, &defaultGainDb);
            }
#else
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN1_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN2_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN3_ID, 0.0/*dB*/);
            DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, DSP_CAL_GAIN4_ID, 0.0/*dB*/);
#endif

            /* Set default volume
             * Note ASE-TK may output noise when bootup, thus we must set ZERO volume before AES-TK boot up.
             */
            //uint32 vol_readback= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, /*reg:*/ADAU1451_VOLUME_ADDR);
            //TP_PRINTF("\r\n\r\n\r\nDSP flow initial vol = %d\r\n\r\n\r\n", vol_readback);
            DSPDrv1451_SetVol(&dspAdau1451Drv, /*vol*/0);
            
            /* set linein sensitivity default gain (medium)*/
            AudioDrv_SetAudio(me, AUDIO_LINEIN_SENSITIVITY_SETT_ID, TRUE, (uint32)Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED, /*NOT USED*/0);

            
            //Set DSP channel
            DSPDrv1451_SetInputChannel(&dspAdau1451Drv, AUDIO_CHANNEL_I2S_1); //ASE-TK

            //Initialize ADC: PCM1862
            adcPcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_ADC_DEV_ID, NULL);
            ASSERT(adcPcm1862i2cObj.pConfig);
            AdcDrv_pcm1862_Ctor(&adcPcm1862, &adcPcm1862i2cObj);
            AdcDrv_pcm1862_Init(&adcPcm1862);

            /* Backward compatible for EVT
             * The single-end (analog input) setting for EVT cause high noise
             */
            char *hw_ver= (char*)Setting_GetEx(SETID_HW_VER, "unknown");
//            if( strcmp(hw_ver, "EVT1")==0 )
//            {   //EVT
//                TP_PRINTF("\r\n\r\nADC: set differential input, because of %s HW\r\n\r\n\r\n", hw_ver);
//                AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_DIFF_INPUT1);
//            }
//            else
            //{   //DVT and later
                //TP_PRINTF("\r\n\r\nADC: set single-end input, because of %s HW\r\n\r\n\r\n", hw_ver);
                AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_INPUT1);
            //}

            AdcDrv_pcm1862_SetPGA(&adcPcm1862, AUDIO_AUXIN_GAIN);
            AdcDrv_pcm1862_enableAGC(&adcPcm1862, /*enable:*/FALSE); //AGC feature have problem on MOFA, should disable it

            //Initialize Woofer Amplifier 1
            TP_PRINTF("Init Woofer Amplifier 1\r\n");
            ampWoofer1I2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_WOOFER_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampWoofer1I2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpWoofer1Drv, &ampWoofer1I2cDrv);

            //Initialize Woofer Amplifier 2
            TP_PRINTF("Init Woofer Amplifier 2\r\n");
            ampWoofer2I2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_WOOFER_2_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampWoofer2I2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpWoofer2Drv, &ampWoofer2I2cDrv);

            //Initialize Middle Amplifier
            TP_PRINTF("Init Middle Amplifier\r\n");
            ampMidI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_MIDDLE_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampMidI2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpMidDrv, &ampMidI2cDrv);

            //Initialize Tweeter Amplifier
            TP_PRINTF("Init Tweeter Amplifier\r\n");
            ampTweeterI2cDrv.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_TWEETER_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampTweeterI2cDrv.pConfig);
            AudioAmpDrv_Ctor(&audioAmpTweeterDrv, &ampTweeterI2cDrv);
            
            /* 1. Set amplifer to PBTL mode, means two output to one speaker
             *
             * 2. Datasheet said, PBTL select right channel when REG[6].bit1==1, left chanel when REG[6].bit1==0.
             *    But accurary result is inverse.
             *
             * 3. As measurement, with 22.6dBV (=19.1Vpk) setting, output voltage will clip on 13.5V.
             *    To avoid clip, and let 0dBFS map to 13.6V output, 
             *    DSP should set gain 13.6/19.1 ~= 0.71 (-2.97dB)
             */
            TP_PRINTF("Set Amplifier Analog Control\r\n");
            AudioAmpDrv_setAnalogControl(&audioAmpWoofer1Drv, 0x95); //PBTL=1, PWM Rate=LRCK*8=384KHz, Analog Gain=22.6dBV(Vpk=19.8V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpWoofer2Drv, 0x95); //PBTL=1, PWM Rate=LRCK*8=384KHz, Analog Gain=22.6dBV(Vpk=19.8V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpMidDrv,     0x35); //PBTL=0, PWM Rate=LRCK*12=576KHz, Analog Gain=22.6dBV(Vpk=19.8V), PBTL Channel selection=right
            AudioAmpDrv_setAnalogControl(&audioAmpTweeterDrv, 0xB5); //PBTL=1, PWM Rate=LRCK*12=576KHz, Analog Gain=22.6dBV(Vpk=19.8V), PBTL Channel selection=right

            /* It is important to note that control port register changes should only occur when the device is placed into
             *  shutdown. This can be accomplished either by pulling the SPK_SD pin "LOW" or clearing the SPK_SD bit in the
             *  control port.
             */            
            /* Pull SDZ to high after I2C programming */
            AMP_WAKEUP(audioGpioDrv);
            
            //AudioAmpDrv_printError(&audioAmpWoofer1Drv);
            AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/TRUE);
            AudioAmpDrv_setShutdown(&audioAmpWoofer1Drv, TRUE);
            AudioAmpDrv_setShutdown(&audioAmpWoofer2Drv, TRUE);
            AudioAmpDrv_setShutdown(&audioAmpMidDrv,     TRUE);
            AudioAmpDrv_setShutdown(&audioAmpTweeterDrv, TRUE);
            
            //Finish
            me->drvIsReady = TRUE;
            memset(&volFadeParam, 0, sizeof(volFadeParam));
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            bool musicDet= FALSE;
            Setting_Set(SETID_MUSIC_DET, &musicDet);
            volFadeParam.isFadingInProg = FALSE;
            uint8 defaultVol = 0;
            Setting_Set(SETID_VOLUME, &defaultVol);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetInputChannel(&dspAdau1451Drv, audioChannel);
}


void AudioDrv_dumpAmpReg(void)
{
    AudioAmpDrv_dumpReg(&audioAmpWoofer1Drv, "ampWoofer1");
    AudioAmpDrv_dumpReg(&audioAmpWoofer2Drv, "ampWoofer2"); 
    AudioAmpDrv_dumpReg(&audioAmpMidDrv,     "ampMid"); 
    AudioAmpDrv_dumpReg(&audioAmpTweeterDrv, "ampTweeter"); 
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *me)
{
    AudioDrv_CheckMusicStreamStatus();
    AudioDrv_AmpHealthMonitor(me);
    AudioDrv_AmpSafetyMonitor(me);
#ifdef HAS_DSP_TUNING_DETECT    
    AudioDrv_DspTuneUpdate(me);
#endif
}


/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
    {
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
        bool hasMusicStream= *(bool*)Setting_Get(SETID_MUSIC_DET);
    
        uint32 sensitivityLineIn = Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED; //type: eLineinSensitivity
        sensitivityLineIn= *(uint32*)Setting_GetEx(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
        int8 sensitivityThresholdDb;
        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_HIGH)
        {
            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_HIGH_DB;
        }
        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_MEDIUM)
        {
            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_MID_DB;
        }
        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_LOW)
        {
            sensitivityThresholdDb= AUDIO_AUXIN_DETECT_LOW_DB;
        }
        else if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
        {
            hasMusicStream_DebNew= FALSE;
            hasMusicStream_DebPre= FALSE;
            auxin_detect_debounce_msec= 0;
        }
        else
        {
            ASSERT(0);
        }
        
        float auxin_input_db= DSPDrv1451_ReadInputAuxinVolume(&dspAdau1451Drv);
        hasMusicStream_DebNew= (auxin_input_db>=sensitivityThresholdDb)?TRUE:FALSE;
        
        /* Some music do not have constant volume and hard to pass debounce,
         * thus we get smooth volume then pass to debounce.
         */
        auxin_input_db_smooth= (auxin_input_db*AUDIO_AUXIN_DETECT_SMOOTH_RATE) + (auxin_input_db_smooth*(1-AUDIO_AUXIN_DETECT_SMOOTH_RATE));
        Setting_Set(SETID_AUDIO_AUXIN_IN_DB, &auxin_input_db_smooth);
        //printf("aux=%.1fdB, aux-smooth=%.1fdB, new=%d, pre=%d, curr=%d, time=%dms, threshold=%ddB[L%d]\r\n", 
        //          auxin_input_db, auxin_input_db_smooth, hasMusicStream_DebNew, 
        //          hasMusicStream_DebPre, hasMusicStream, auxin_detect_debounce_msec,
        //          sensitivityThresholdDb, sensitivityLineIn);
                
        if(sensitivityLineIn==Proto_Dsp_LineInSensitivity_Sensitivity_DISABLED)
        {
        }
        if(hasMusicStream_DebNew==hasMusicStream)
        {
            //Do not need debounce
            auxin_detect_debounce_msec= 0;
        }
        else if(hasMusicStream_DebNew!=hasMusicStream_DebPre)
        {
            //stop debounce
            auxin_detect_debounce_msec= 0;
            //TP_PRINTF("aux-in: debounce fail\r\n");
        }
        else
        {
            //start or continue debounce (new == pre == curr)
            if(auxin_detect_debounce_msec <= AUDIO_AUXIN_DETECT_PEROID_MSEC)
            {
                auxin_detect_debounce_msec+= AUDIO_SRV_TIMEOUT_IN_MS;
                //TP_PRINTF("aux: debouncing\r\n");
            }
            else 
            {
                //finish debounce
                hasMusicStream= hasMusicStream_DebNew;
                Setting_Set(SETID_MUSIC_DET, &hasMusicStream);                
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = hasMusicStream;
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("\r\n\r\n*** Aux-in music states is %d ***\r\n\r\n\r\n", pAudioMusicStateEvt->hasMusicStream);
            }
        }
        hasMusicStream_DebPre= hasMusicStream_DebNew;
    }
}

static void AudioDrv_StopFadeVolume()
{
    if (volFadeParam.isFadingInProg == TRUE)
    {
        TP_PRINTF("Volume fade: Stop volume fading and reply ASE (red_id=%d)\r\n", volFadeReqId);
        AseNgSrv_ReplyVolumeFade(volFadeReqId, TRUE);
        bool ret= Timer_StopTimer(volFadeTimerId);
        ASSERT(ret); //FALSE means Fade volume timer is not running
        volFadeParam.isFadingInProg = FALSE;
        volFadeReqId = 0;
    }
}


static void AudioDrv_SetFadeVolume(cAudioDrv *me, uint32 target_volume, uint32 fade_duration)
{
    if (volFadeParam.isFadingInProg == TRUE)
    {
        TP_PRINTF("    Volume fade: Stop previous fade volume and start new one\r\n");
        bool ret= Timer_StopTimer(volFadeTimerId);
        ASSERT(ret); //FALSE means Fade volume timer is not running
    }
    
        
    /* The start volume should always be equal to current volume. */
    uint8 start_volume = *(uint8*)Setting_Get(SETID_VOLUME);
    uint32 fadeRange = TYM_DIFF(target_volume, start_volume);
        
    /* fade_duration should not be less than ADUIO_MIN_FADE_STEP_TIME */
    if(fade_duration < ADUIO_MIN_FADE_STEP_TIME)
    {
        fade_duration= ADUIO_MIN_FADE_STEP_TIME;
    }
    
    if(((fadeRange <= (MAX_VOLUME - MIN_VOLUME)) && fadeRange > 0)
        && (target_volume >= MIN_VOLUME && target_volume <= MAX_VOLUME)
        && (start_volume >= MIN_VOLUME && start_volume <= MAX_VOLUME))
    {
        volFadeParam.fadeType     = (target_volume > start_volume)? TRUE : FALSE;
        volFadeParam.fadeStep     = ADUIO_MIN_FADE_STEP;
        volFadeParam.fadeStepTime = (fade_duration * volFadeParam.fadeStep)/fadeRange;
        volFadeParam.targetVol    = target_volume;
        volFadeParam.isFadingInProg = TRUE;
        if(ADUIO_MIN_FADE_STEP_TIME > volFadeParam.fadeStepTime)
        {
            volFadeParam.fadeStepTime = ADUIO_MIN_FADE_STEP_TIME;
            volFadeParam.fadeStep = (volFadeParam.fadeStepTime * fadeRange)/fade_duration;
            ASSERT(volFadeParam.fadeStep>0);
        }
        Timer_StartTimer((uint32)volFadeParam.fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, &volFadeParam);
    }
    else
    {
        TP_PRINTF("The volume fade parameters are invalid. \r\n");
        AseNgSrv_ReplyVolumeFade(volFadeReqId, TRUE);
    }
    

}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady)) {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch (audioSettId)
    {
        case DSP_CAL_GAIN1_ID:
        case DSP_CAL_GAIN2_ID:
        case DSP_CAL_GAIN3_ID:
        case DSP_CAL_GAIN4_ID:
        {
            float fGainDb= *((float*)&param);
            
            /* Golden sample will write gainAllow=1, means do not allow gain writeing and keep gain to 0dB
             */
            uint32 gainAllow= TRUE;
            gainAllow= *(uint32*)Setting_GetEx(SETID_GAIN_ALLOW, &gainAllow);
            
            /* Normal sample did not write gainAllow, the initial value is 0xFF, the follower decision treat as TRUE.
             */
            if(gainAllow)
            {
                //TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_CAL_GAINx_ID, gain=%1.2f\r\n", audioSettId, fGainDb);
                AudioDrv_DspCalGainSetId_Handler(audioSettId, fGainDb);
            }
            else
            {
                TP_PRINTF("\r\n\r\n\r\n*** AudioDrv_SetAudio: reject gain writing because gainAllow is set (id=%d, gain=%1.2f) ***\r\n\r\n\r\n", audioSettId, fGainDb);
            }
            break;
        }        
            
        case DSP_VOLUME_SETT_ID:
        {
            uint8 volume= (uint8)param;
            //TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_VOLUME_SETT_ID\r\n", audioSettId);
            if(!volFadeParam.isFadingInProg)
            {
                TP_PRINTF("AudioDrv_SetAudio: vol=%d\r\n", volume);
                AudioDrv_Set_DspVol(volume);
            }
            else
            {
                TP_PRINTF("AudioDrv_SetAudio: ignore volume change (vol=%d) because fading volume is on-going\r\n", volume);
            }
            break;
        }
        case DSP_PASSTHROUGH_SETT_ID:
            TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_PASSTHROUGH_SETT_ID, bypass=%d\r\n", audioSettId, enabled);
            DSPDrv1451_SetPassthrough(&dspAdau1451Drv, enabled);
            break;
            
        case AMP_SLEEP_MODE_ID:
            if(!audioOverheat)
            {
                TP_PRINTF("AudioDrv_SetAudio: AMP_SLEEP_MODE_ID, enabled=%d\r\n", enabled);
                AudioAmpDrv_setShutdown(&audioAmpWoofer1Drv, enabled);
                AudioAmpDrv_setShutdown(&audioAmpWoofer2Drv, enabled);
                AudioAmpDrv_setShutdown(&audioAmpMidDrv,     enabled);
                AudioAmpDrv_setShutdown(&audioAmpTweeterDrv, enabled);
            }
            break;
            
        case AUDIO_OVERHEAT_MODE_ID:
            AudioDrv_SetOverheat(me, enabled);
            break;
            
        case DSP_TUNNING_SETT_ID:
            /* DSP and AMP I2C bus should be disable when tuning DSP. */
            DSPDrv1451_I2cEnable(&dspAdau1451Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpWoofer1Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpWoofer2Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpMidDrv,     !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpTweeterDrv, !enabled);
            break;
            
        case AUDIO_VOL_FADE_SETT_ID:
        {  /* param ( vv:ffffff    8 bits volume : 24 bits fade duration )
              param2 request id */
            uint32 target_volume= param >> 24;
            volFadeReqId = param2;
            uint32 fade_duration= param & 0xFFFFFF;
            AudioDrv_StopFadeVolume();
            AudioDrv_SetFadeVolume(me, target_volume, fade_duration);
            break;
        }
        case AUDIO_LINEIN_SENSITIVITY_SETT_ID:
        {
            uint32 sensitivityLineIn = param; //type: AseFepSetLineInSensitivity_LineInSensitivity
            Setting_Set(SETID_SENSITIVITY_LINEIN, &sensitivityLineIn);
            break;
        }
        case AUDIO_DSP_CHENNEL_L_R:
        {
            tDspChannel dspCh = param;
            DSPDrv1451_SetChannel_L_R(&dspAdau1451Drv, dspCh);
            break;
        }
        case AUDIO_DSP_TREBLE_SETT_ID:
        {
            uint32 value= param;
            DSPDrv1451_SetTreble(&dspAdau1451Drv, value);
            break;
        }
        case AUDIO_DSP_BASS_SETT_ID:
        {
            uint32 value= param;
            DSPDrv1451_SetBase(&dspAdau1451Drv, value);
            break;
        } 
        case AUDIO_DSP_LOUDNESS_SETT_ID:
        {
            bool loudness= (bool)param;
            DSPDrv1451_SetLoudness(&dspAdau1451Drv, loudness);
            break;
        }
        case AUDIO_POS_SOUND_MODE_SETT_ID:
        {
            tDspPosition position= (tDspPosition)param;
            DSPDrv1451_SetPosition(&dspAdau1451Drv, position);
            break;
        }
        default:
             break;
    }
}



static void AudioDrv_DspCalGainSetId_Handler(eAudioSettId audioSettId, float fGainDb)
{
   int32 ctlId= AudioDrv_GetCrtIdIndex(audioSettId);
   ASSERT(ctlId>=0); //-1 means fail
   DSPDrv1451_SetCalibrateGain(&dspAdau1451Drv, audioSettId, fGainDb);
}


static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
    /* get current volume value */
    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);

    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack: fadeType=%d, step=%d, vol:(curr=%d,tgt=%d) \r\n", 
    //           pVolFadeParam->fadeType, pVolFadeParam->fadeStep, volLevel, pVolFadeParam->targetVol);
    
    ASSERT(pVolFadeParam->isFadingInProg==TRUE);

    /* For issue FS-202, sometimes AudioDrv_VolFadeTimerCallBack() repeated execute and set the same volume.
     * The only possible condition is fadeStep==0, but there is no reason for it.
     * Before find root cause, we add workaround here.
     */
    if(pVolFadeParam->fadeStep==0)
    {
        ASSERT(0);
        TP_PRINTF("\r\n\r\n\r\n*** ERROR: AudioDrv_VolFadeTimerCallBack fadeStep==0 ***\r\n\r\n\r\n\r\n");
        return;
    }
    
    /* change volume*/
    if(pVolFadeParam->fadeType)
    {
        /* volume fade up*/
        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = MAX_VOLUME;
        }
        else
        {
            volLevel += pVolFadeParam->fadeStep;
        }
    }
    else
    {
        /* volume fade down*/
        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
        {
            volLevel = MIN_VOLUME;
        }
        else
        {
            volLevel -= pVolFadeParam->fadeStep;
        }
    }
    AudioDrv_Set_DspVol(volLevel); //also store volLevel to SETID_VOLUME

    if((volLevel != pVolFadeParam->targetVol)
        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
    {
        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
    }
    else
    {
        /* Reply Ase-tk when volume fade completed. */
        AudioDrv_StopFadeVolume();
        TP_PRINTF("Volume fade: finish, vol=%d, req_id=%d\r\n", volLevel, volFadeReqId);
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    ASSERT(muteType < AUDIO_MUTE_TYPE_MAX);
    switch (muteType)
    {
        case AUDIO_AMP_SOFT_MUTE:
            TP_PRINTF("AudioDrv_Mute: mute=%d\r\n", muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpWoofer1Drv, muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpWoofer2Drv, muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpMidDrv,     muteEnable);
            AudioAmpDrv_setSoftMute(&audioAmpTweeterDrv, muteEnable);
            break;
        default:
            //Support only soft mute
            ASSERT(0);
            break;
    }
 }
    
/**
 * Function to mute specific channel (Woofer, MiddleA, MiddleB, Tweeter).
 * @param[in]   channel_maks    This parameter defines which channels should be muted.
 * Bit 3 corresponds to: Woofer,- 1 to mute; 0 - to unmute.
 * Bit 2 corresponds to: MiddleA,- 1 to mute; 0 - to unmute.
 * Bit 1 corresponds to: MiddleB,- 1 to mute; 0 - to unmute.
 * Bit 0 corresponds to: Tweeter,- 1 to mute; 0 - to unmute.
 * For example to mute only Woofer, MiddleA and MiddleB  and unmute Tweeter
 * channel mask will be : 0000 0000 0000 0000 0000 0000 0000 1110  ( 0x000E )
 *
 */
void AudioDrv_MuteChannel(uint32 channel_mask)
{
    if (channel_mask & AUDIO_WOOFER_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteWoofer(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_MIDDLEA_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteMiddleA(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_MIDDLEB_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteMiddleB(&dspAdau1451Drv, FALSE);
    }

    if (channel_mask & AUDIO_TWEETER_MUTE_CHANNEL_MASK)
    {
        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, TRUE);
    }
    else
    {
        DSPDrv1451_MuteTweeter(&dspAdau1451Drv, FALSE);
    }
}

    
    
 static void AudioDrv_Set_DspVol(uint8 volLevel)
 {
    DSPDrv1451_SetVol(&dspAdau1451Drv, volLevel);
    Setting_Set(SETID_VOLUME, &volLevel);
 }
 
    

//return -1 means can not find
static int32 AudioDrv_GetCrtIdIndex(eAudioSettId audioSettId)
{
    int32 ret= -1;
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(audioSettId == ctrIdEQIdMap[i].dspSettid)
        {
            ret= i;
            break;
        }
    } 
    
    return ret;
}


static uint16 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint16 degreeC;

    for (degreeC = 0; degreeC < TEMPERATURE_POSITIONS_NUM; degreeC++)
    {
        if (ntcValue >= audioNtcTempTable[degreeC])
        {
            break;
        }
    }
    return degreeC;
}


static void AudioDrv_SetOverheat(cAudioDrv *me, bool overheat)
{  
    /* audioOverheat occurs: Shutdown ampliifer for over-heat
     * recover from audioOverheat: do nothing, but allow MainApp to wakeup amplifier
     */
    TP_PRINTF("AudioDrv_SetOverheat: overheat=%d\r\n", overheat);
    audioOverheat= overheat;
    if(overheat) 
    {
        AMP_SHUTDOWN(audioGpioDrv);
    }
    else
    {
        AMP_WAKEUP(audioGpioDrv);
    }
}


static void AudioDrv_AmpHealthMonitor(cAudioDrv *me)
{
    bool amp_health = 0;
    bool ampWoofer1_error = FALSE;
    bool ampWoofer2_error = FALSE;
    bool ampMid_error     = FALSE;
    bool ampTweeter_error = FALSE;

    /* bit0: over-temperature error
     * bit1: output dc error
     * bit2: over current error
     * bit3: clock erorr
     */
    AudioAmpDrv_getErrorStatus(&audioAmpWoofer1Drv, &ampWoofer1_error);
    AudioAmpDrv_getErrorStatus(&audioAmpWoofer2Drv, &ampWoofer2_error);
    AudioAmpDrv_getErrorStatus(&audioAmpMidDrv,     &ampMid_error);
    AudioAmpDrv_getErrorStatus(&audioAmpTweeterDrv, &ampTweeter_error);

    amp_health = !(ampWoofer1_error || ampWoofer2_error || ampMid_error || ampTweeter_error);
    
    /* byte[3]: woofer1 amplifier reason 
     * byte[2]: woofer2 amplifier reason 
     * byte[1]: middle amplifier reason 
     * byte[0]: tweeter amplifier reason 
     */
    uint32 ampErrorReason= (ampWoofer1_error<<24) | (ampWoofer2_error<<16) | (ampMid_error<<8) | ampTweeter_error;
    Setting_Set(SETID_AMP_ERROR_REASON, &ampErrorReason);

    bool amp_healthPrev= TRUE;    
    amp_healthPrev= *(bool*)Setting_GetEx(SETID_AMP_HEALTH, &amp_healthPrev);
    Setting_Set(SETID_AMP_HEALTH, &amp_health);
 
    if(amp_healthPrev!=amp_health)
    {
        TP_PRINTF("\r\n\r\n\r\n*** AMP_HEALTH: %d (reason: wf1:0x%x, wf2:0x%x, mid:0x%x, tw:0x%x) ***\r\n\r\n\r\n", amp_health, ampWoofer1_error, ampWoofer2_error, ampMid_error, ampTweeter_error);
    }    
}



static void AudioDrv_UpdateHwVer()
{
    int32 rawResult = 0;
    uint16 ii;
    char *hwVersion= "unknown";
    ASSERT(audioAdcDrv.isCreated);
    
    //HW Version
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_HW_VER);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        for (ii = 0; ii < ArraySize(hwVersionArray); ii++)
        {
            if (hwVersionArray[ii].minVol <= rawResult && rawResult <= hwVersionArray[ii].maxVol)
            {
                hwVersion = (char*)hwVersionArray[ii].hwVersionStr;
                break;
            }
        }
        ASSERT(ii<ArraySize(hwVersionArray));
        Setting_Set(SETID_HW_VER, hwVersion);
        TP_PRINTF("\r\n\r\n*** HW_VERSION: %s *** \r\n\r\n\r\n", hwVersion);
    }
        
    
    //Continus ADC scanning
    ADCDrv_StartScanning(&audioAdcDrv);
}




static void AudioDrv_AmpSafetyMonitor(cAudioDrv *me)
{  
    uint16  tempWfAmp1New  = 0;
    uint16  tempWfAmp2New  = 0;
    uint16  tempWfSpkNew     = 0;
    uint16  tempMidSpkANew   = 0;
    uint16  tempMidSpkBNew   = 0;
    uint16  tempTwAmpNew     = 0;   
    eTempLevel tempLevelAudioNew = TL_NORMAL;
    int32 rawResult= 0;
    ASSERT(audioAdcDrv.isCreated);
    
    
    //(1)Get temperature for Woofer amplifier 1
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_1);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfAmp1New = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempWfAmp1)
        {
            tempWfAmp1New = ((tempWfAmp1New*TEMP_DETECT_SMOOTH_RATE) + (tempWfAmp1*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempWfAmp1New, &tempWfAmp1, &tempLevelWfAmp1, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_WF_AMP_1, &tempWfAmp1);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_1_REGISTER, (uint32)tempWfAmp1New);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_1_REGISTER);
        //TP_PRINTF("DSP Read back tempWfAmp1= %d\r\n", value);
    }
    
    
    //(2)Get temperature for Woofer amplifier 2
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_AMP_2);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfAmp2New = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempWfAmp2)
        {
            tempWfAmp2New = ((tempWfAmp2New*TEMP_DETECT_SMOOTH_RATE) + (tempWfAmp2*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempWfAmp2New, &tempWfAmp2, &tempLevelWfAmp2, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_WF_AMP_2, &tempWfAmp2);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_AMP_2_REGISTER, (uint32)tempWfAmp2New);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_AMP_2_REGISTER);
        //TP_PRINTF("DSP Read back tempWfAmp2= %d\r\n", value);
    }

    
    //(3)Get temperature for Woofer speaker 
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_WF_SPK);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempWfSpkNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempWfSpk)
        {
            tempWfSpkNew = ((tempWfSpkNew*TEMP_DETECT_SMOOTH_RATE) + (tempWfSpk*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempWfSpkNew, &tempWfSpk, &tempLevelWfSpk, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_WF_SPK, &tempWfSpk);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_WF_SPK_REGISTER, (uint32)tempWfSpkNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_WF_SPK_REGISTER);
        //TP_PRINTF("DSP Read back tempWfSpkNew= %d\r\n", value);
    }
   
    
    //(4)Get temperature for Middle spekaer A
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_A);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempMidSpkANew = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempMidSpkA)
        {
            tempMidSpkANew = ((tempMidSpkANew*TEMP_DETECT_SMOOTH_RATE) + (tempMidSpkA*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempMidSpkANew, &tempMidSpkA, &tempLevelMidSpkA, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_MID_SPK_A, &tempMidSpkA);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_A_REGISTER, (uint32)tempMidSpkANew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_A_REGISTER);
        //TP_PRINTF("DSP Read back tempMidSpkA= %d\r\n", value);
    }
   
    
    //(5)Get temperature for Middle spekaer B
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_MID_SPK_B);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempMidSpkBNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempMidSpkB)
        {
            tempMidSpkBNew = ((tempMidSpkBNew*TEMP_DETECT_SMOOTH_RATE) + (tempMidSpkB*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempMidSpkBNew, &tempMidSpkB, &tempLevelMidSpkB, spkTempLevels,  ArraySize(spkTempLevels));
        Setting_Set(SETID_TEMP_MID_SPK_B, &tempMidSpkB);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_MID_SPK_B_REGISTER, (uint32)tempMidSpkBNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_MID_SPK_B_REGISTER);
        //TP_PRINTF("DSP Read back tempMidSpkB= %d\r\n", value);
    }
   
    
    //(6)Get temperature for Tweeter Amplifier
    rawResult = ADCDrv_GetData(&audioAdcDrv, ADC_NTC_TW_AMP);
    if (ADC_DATA_IS_NOT_READY != rawResult)
    {
        tempTwAmpNew = AudioDrv_ConvertNtcToTemperature(rawResult);
        if (tempTwAmp)
        {
            tempTwAmpNew = ((tempTwAmpNew*TEMP_DETECT_SMOOTH_RATE) + (tempTwAmp*(100 - TEMP_DETECT_SMOOTH_RATE)))/100;
        }
        PowerDrv_UpdateTempLevel(tempTwAmpNew, &tempTwAmp, &tempLevelTwAmp, ampTempLevels,  ArraySize(ampTempLevels));
        Setting_Set(SETID_TEMP_TW_AMP, &tempTwAmp);
        DSPDrv1451_WriteDcValue32_0(&dspAdau1451Drv, DSP_TEMP_TW_AMP_REGISTER, (uint32)tempTwAmpNew);
        //uint32 value= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_TEMP_TW_AMP_REGISTER);
        //TP_PRINTF("DSP Read back tempTwAmp= %d\r\n", value);
    }
    

    //(4)Error Handling
    tempLevelAudioNew= MIN6(tempLevelWfAmp1, tempLevelWfAmp2, tempLevelWfSpk, tempLevelMidSpkA, tempLevelMidSpkB, tempLevelTwAmp);
//    if(tempLevelAudio!=tempLevelAudioNew)
//    {
//        switch(tempLevelAudioNew)
//        {
//        case TL_CRITICAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (CRITICAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_SERIOUS:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (SERIOUS) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//        
//        case TL_WARN:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (WARN) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);
//            AudioDrv_SetOverheat(me, TRUE);
//            break;
//       
//        case TL_NORMAL:
//            TP_PRINTF("\r\nERROR: AudioDrv_AmpSafetyMonitor: temp level %d -> %d (NORMAL) ***\r\n\r\n", tempLevelAudio, tempLevelAudioNew);            
//            AudioDrv_SetOverheat(me, FALSE);
//            break;
//             
//        default:
//            ASSERT(0);
//            break;
//        }
//    }
    tempLevelAudio= tempLevelAudioNew;
    Setting_Set(SETID_TEMP_LEVEL_AUDIO, &tempLevelAudioNew);
    
    
    //(5)Continues ADC scanning
    ADCDrv_StartScanning(&audioAdcDrv);
    
    
    //(6)Print every 5sec (AUDIO_PRINT_PREIOD_IN_MS)
    static int32 timeoutTick= 0;
    timeoutTick--;
    if(timeoutTick<=0)
    {   
        timeoutTick= AUDIO_PRINT_PREIOD_IN_MS / AUDIO_SRV_TIMEOUT_IN_MS;

        uint32 ampErrorReason=0, ampWoofer1_error=0, ampWoofer2_error=0, ampMiddle_error=0, ampTweeter_error=0;
        
        /* byte[3]: woofer1 amplifier reason 
         * byte[2]: woofer2 amplifier reason 
         * byte[1]: middle amplifier reason 
         * byte[0]: tweeter amplifier reason 
         */
        ampErrorReason= *(uint32*)Setting_GetEx(SETID_AMP_ERROR_REASON, &ampErrorReason);
        ampWoofer1_error= (ampErrorReason>>24) & 0xF;
        ampWoofer2_error= (ampErrorReason>>16) & 0xF;
        ampMiddle_error=  (ampErrorReason>>8)  & 0xF;
        ampTweeter_error= (ampErrorReason)     & 0xF;


        bool amp_health= TRUE;    
        amp_health= *(bool*)Setting_GetEx(SETID_AMP_HEALTH, &amp_health);

        float dspOutGainDb= 20.0 * log10(DSP_OUTPUT_GAIN_LINEAR);
        float volInput= DSPDrv1451_ReadInputVolume(&dspAdau1451Drv);
        
        float volWfOutput= DSPDrv1451_ReadWooferOutputVolume(&dspAdau1451Drv) + dspOutGainDb;
        float volMidAOutput= DSPDrv1451_ReadMiddleAOutputVolume(&dspAdau1451Drv) + dspOutGainDb;
        float volMidBOutput= DSPDrv1451_ReadMiddleBOutputVolume(&dspAdau1451Drv) + dspOutGainDb;
        float volTwOutput= DSPDrv1451_ReadTweeterOutputVolume(&dspAdau1451Drv) + dspOutGainDb;
        
        uint32 dspOverheatGainWf= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_GAIN_WF_REGISTER);
        uint32 dspOverheatGainMid= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_GAIN_MID_REGISTER);
        uint32 dspOverheatGainTw= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_GAIN_TW_REGISTER);
        uint32 dspOverheatCoilTempWf= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_COIL_TEMP_WF_REGISTER);
        uint32 dspOverheatCoilTempMidA= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_COIL_TEMP_MID_A_REGISTER);
        uint32 dspOverheatCoilTempMidB= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_COIL_TEMP_MID_B_REGISTER);
        uint32 dspOverheatCoilTempTw= DSPDrv1451_ReadDcValue32_0(&dspAdau1451Drv, DSP_READBACK_OVERHEAT_COIL_TEMP_TW_REGISTER);

        Setting_Set(SETID_AUDIO_SYS_IN_DB,              &volInput);
        Setting_Set(SETID_AUDIO_OUT_WF_DB,              &volWfOutput);
        Setting_Set(SETID_AUDIO_OUT_MID_A_DB,           &volMidAOutput);
        Setting_Set(SETID_AUDIO_OUT_MID_B_DB,           &volMidBOutput);
        Setting_Set(SETID_AUDIO_OUT_TW_DB,              &volTwOutput);
        
        Setting_Set(SETID_DSP_OVERHEAT_GAIN_WF,         &dspOverheatGainWf);
        Setting_Set(SETID_DSP_OVERHEAT_GAIN_MID,        &dspOverheatGainMid);
        Setting_Set(SETID_DSP_OVERHEAT_GAIN_TW,         &dspOverheatGainTw);
        Setting_Set(SETID_DSP_OVERHEAT_COIL_TEMP_WF,    &dspOverheatCoilTempWf);
        Setting_Set(SETID_DSP_OVERHEAT_COIL_TEMP_MID_A, &dspOverheatCoilTempMidA);
        Setting_Set(SETID_DSP_OVERHEAT_COIL_TEMP_MID_B, &dspOverheatCoilTempMidB);
        Setting_Set(SETID_DSP_OVERHEAT_COIL_TEMP_TW,    &dspOverheatCoilTempTw);

        //DSPDrv1451_ReadAsrcConversionRate(&dspAdau1451Drv, DSP_ASRC0); //DSP_ASRC_FROM_ASETK
        //DSPDrv1451_GetDspVer(&dspAdau1451Drv);
        
        bool hasMusicStream = 0;
        hasMusicStream= *(bool*)Setting_GetEx(SETID_MUSIC_DET, &hasMusicStream);


        /* Based on ADC and line-in schematics, calculate Vrms from Line in.
         * Note the lowest value of auxin_input_db_smooth is -90dB, because we use RMS table component on DSP, 
         * it do not support loewr value (ex. -93dB)
         */
        float adc_gain_db= ((float)AUDIO_AUXIN_GAIN)/2.0;
        float adc_org_in_db= (float)auxin_input_db_smooth - adc_gain_db;
        float auxin_mVrms=  2100.0 / 0.6756 * pow(10.0, adc_org_in_db/20.0); //ADC: 2.1Vrms as full-scale input, 0.6756 is line-in attenuation
        if(auxin_input_db_smooth<=-89.99)
        {
            auxin_mVrms= 0;
        }

        
        TP_PRINTF("dB/RMS:I=%.1f,AUX=%.1f[%.3fmVrms,D=%d],O=wf:%.0f/midA:%.0f/midB:%.0f/tw:%.0f. AMP:H=%d(wf1:0x%x,wf2:0x%x,mid:0x%x,tw:0x%x)\r\n", 
                        volInput, auxin_input_db_smooth, auxin_mVrms, hasMusicStream, volWfOutput, volMidAOutput, volMidBOutput, volTwOutput,
                        amp_health, ampWoofer1_error, ampWoofer2_error, ampMiddle_error, ampTweeter_error);
        TP_PRINTF("Temp:  WfAmp1=%dC[L%d], WfAmp2=%dC[L%d], WfSpk=%dC[L%d], MidSpkA=%dC[L%d], MidSpkB=%dC[L%d], TwAmp=%dC[L%d] => L%d\r\n", 
                      tempWfAmp1,   tempLevelWfAmp1,
                      tempWfAmp2,   tempLevelWfAmp2,
                      tempWfSpk,    tempLevelWfSpk,
                      tempMidSpkA,  tempLevelMidSpkA,
                      tempMidSpkB,  tempLevelMidSpkB,
                      tempTwAmp,    tempLevelTwAmp,
                      tempLevelAudio);
        TP_PRINTF("Temp:  WfCoil=%dC, MidCoilA=%dC, MidCoilB=%dC, TwCoil=%dC,  Gain: Wf=%d%%, Mid=%d%%, Tw=%d%%\r\n\r\n", 
                      dspOverheatCoilTempWf, dspOverheatCoilTempMidA, dspOverheatCoilTempMidB, dspOverheatCoilTempTw,
                      dspOverheatGainWf, dspOverheatGainMid, dspOverheatGainTw);
            
    }
}


#ifdef HAS_DSP_TUNING_DETECT    
static void AudioDrv_DspTuneUpdate(cAudioDrv *me)
{
    /* When insert DSP USBi cable, PA15 get high input from PA15,
     * but noise cause it trigger low sometime. Thus we need to debounce here.
     */
     
    //debounce for 0.5 seconds
    const uint32 timeoutTick= 100 / AUDIO_SRV_TIMEOUT_IN_MS;
    int8 dspTuneNew= GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_DSP_TUNE);
    
    if(dspTuneTmp != dspTuneNew) 
    {   //(Step-1) start debounce different DspTune
        debounceTick= 0;
        TP_PRINTF("DspTune (1)\r\n");
    }
    else
    {
        if(dspTuneCurr != dspTuneNew)
        {
            if( debounceTick < timeoutTick )
            {   //(Step-2) wait DspTune hold for 1s
                debounceTick++;
                TP_PRINTF("DspTune (2)\r\n");
            }
            else
            {   //(Setep-3) timeout, apply DspTune change, and turn on amplifier
                //When set dspTuneCurr, audio driver never turn off amplifier
                TP_PRINTF("DSP-TUNE= %d\r\n", dspTuneNew);
                if( dspTuneNew )
                {   //Enable amplifier when DSP cable insert
                    AudioDrv_SetAudio(me, AMP_SLEEP_MODE_ID, FALSE, /*not used*/0, /*not used*/0);
                    AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/FALSE);
                }
                DSPDrv1451_I2cEnable(&dspAdau1451Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer1Drv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpWoofer2Drv, !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpMidDrv,  !dspTuneNew);
                AudioAmpDrv_I2cEnable(&audioAmpTweeterDrv, !dspTuneNew);
                debounceTick= 0;
                dspTuneCurr= dspTuneNew;
            }
        }
        else
        {
            //(Step-4) DspTune not change
        }
    }
    dspTuneTmp= dspTuneNew;
}
#endif /* HAS_DSP_TUNING_DETECT */


/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Main Application
                  -------------------------

                  SW Module Document




@file        MainApp.c
@brief       Main application for SVS14_Ultra
@author      Christopher Alexander,Bob.Xu
@date        2014-04-24
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-20     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "./MainApp_priv.h"
#include "projBsp.h"
#include "DisplaySrv.h"
#include "SettingSrv.h"
#include "Menu.config"
#include "trace.h"
#include "AudioSrv.h"

/******* Below are product Feature definations **********/
#if defined(SVS_16_ULTRA_SB)
#define NUM_OF_FEATURES     12
static const uint8 projFeatureSet[NUM_OF_FEATURES] = 
{
    DISPLAY_ID,
    SYSTEM_TIMEOUT_ID,
    SYSTEM_STANDBY_ID,
    LP_ID,
    HP_ID,
    PEQ1_ID, 
    PEQ2_ID,
    PEQ3_ID,
    RGC_ID,
    PHASE_ID,
    POLARITY_ID,
    VOLUME_ID
};
#elif defined(SVS_16_ULTRA_PB)
#define NUM_OF_FEATURES     13
static const uint8 projFeatureSet[NUM_OF_FEATURES] = 
{
    DISPLAY_ID,
    SYSTEM_TIMEOUT_ID,
    SYSTEM_STANDBY_ID,
    LP_ID,
    HP_ID,
    PEQ1_ID, 
    PEQ2_ID,
    PEQ3_ID,
    RGC_ID,
    PHASE_ID,
    POLARITY_ID,
    TURNNING_ID,
    VOLUME_ID
};
#else
#define NUM_OF_FEATURES     13
static const uint8 projFeatureSet[NUM_OF_FEATURES] = 
{
    DISPLAY_ID,
    SYSTEM_TIMEOUT_ID,
    SYSTEM_STANDBY_ID,
    LP_ID,
    HP_ID,
    PEQ1_ID, 
    PEQ2_ID,
    PEQ3_ID,
    RGC_ID,
    PHASE_ID,
    POLARITY_ID,
    TURNNING_ID,
    VOLUME_ID
};
#endif


/* The objects owned by mainApp */
static cGpioDrv gpioDrv;
static cMenuDlg menuDlg;

/********************************************************************/
/*
* mandatoryAudioSett is the mandatory audio settings which has to be enabled 
* when the system is started.
*/
static const tPageIdDspSettIdMap mandatoryAudioSett[] =
{
    {PAGE_SETTING_VOL,      DSP_VOLUME_SETT_ID},
    {PAGE_SETTING_PHASE,    DSP_PHASE_SETT_ID},
    {PAGE_SETTING_POLARITY, DSP_POLARITY_SETT_ID},
};
/*
* optionalAudioSett is the optional audio settings which may be enabled or disabled 
* by the user
*/
static const tPageIdDspSettIdMap optionalAudioSett[] =
{
    {PAGE_SETTING_LP_STATUS,    DSP_EQ_CTRL_USER_LP},
    {PAGE_SETTING_PEQ1_STATUS,  DSP_EQ_CTRL_PEQ1},
    {PAGE_SETTING_PEQ2_STATUS,  DSP_EQ_CTRL_PEQ2},
    {PAGE_SETTING_PEQ3_STATUS,  DSP_EQ_CTRL_PEQ3},
    {PAGE_SETTING_RGC_STATUS,   DSP_EQ_CTRL_RGC}
};

#define SYS_SETTING_DISPLAY     0 // Index of sysSettings
#define SYS_SETTING_TIMEOUT     1
#define SYS_SETTING_STANDBY     2
#define SYS_BRIGHTNESS_LEVEL    3
static tSysSetting sysSettings[] =
{
    {PAGE_SETTING_DISPLAY,    0},
    {PAGE_SETTING_TIMEOUT,    0},
    {PAGE_SETTING_STANDBY,    0},
    {PAGE_SETTING_BRIGHTNESS, 0}
};

/* System settings */
static int16 scTimeThreshold      = DEFAULT_TIMEOUT_SEC; //screensaver timer threshold, 10 second
static uint32 scTimer             = 0; //timer of screensaver
static uint32 standbyTimer        = 0;
static uint32 logoDisplayTimer    = SECONDS_IN_MS(TWO_SECONDS)/ TEN_MS;
static int16 standbyMode          = AUTO_STANDBY;
static int16 displayMode          = 0;
static BOOL displayVol            = FALSE; //Control to send the string only once
static BOOL isScreenOn            = TRUE;
static tStandbyMusicCtrl  standbyMusicCtrl = {0,FALSE};
/********************************************************************/

/* pDatabase pointer to where all data saved */
static int16 * pDatabase = NULL;
static int16 * pPreset = NULL;

static tStateChange  stageChangeInfo ={STATE_MAX,0};

/* Menu and defualt page defination */
const static tPageNode * pDefaultPage = &volNode;

static eDisplayInfoStep displayInfoStep = DISP_INFO_STEP0;

#ifdef Q_SPY
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#else
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#endif

static uint8 txBuffer[NUM_OF_SCREEN_DIGIT+2]; /* sprintf reserve the last byte for '\0'*/

static BOOL isSysMute = FALSE;

/* 
 * These data is located in specific memory area. This will init the menu settings 
 * for setting server.
 */
static const int16 menuData[ArraySize(menuDataAttr)]@"MENU_SETTINGS" = 
{0,100,0,20,0,800,120,0,500,0,10,0,500,0,10,0,500,0,10,0,250,120,-200,0,0,200};
static const int16 preset1_region[ArraySize(menuDataAttr)]@"MENU_PRESET_1" = 
{0,100,0,20,0,800,120,0,500,0,10,0,500,0,10,0,500,0,10,0,250,120,-200,0,0,200};
static const int16 preset2_region[ArraySize(menuDataAttr)]@"MENU_PRESET_2" = 
{0,100,0,20,0,800,120,0,500,0,10,0,500,0,10,0,500,0,10,0,250,120,-200,0,0,200};
static const int16 preset3_region[ArraySize(menuDataAttr)]@"MENU_PRESET_3" = 
{0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};


static const int16 preset1OriginData[ArraySize(menuDataAttr)] = 
{0,100,0,20,0,800,120,0,500,0,10,0,500,0,10,0,500,0,10,0,250,120,-200,0,0,200};
static const int16 preset2OriginData[ArraySize(menuDataAttr)] = 
{0,100,0,20,0,800,120,0,500,0,10,0,500,0,10,0,500,0,10,0,250,120,-200,0,0,200};
static const int16 preset3OriginData[ArraySize(menuDataAttr)] = 
{0,0,0,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

static int16 currDataCopy[ArraySize(menuDataAttr)] = {0};

/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[10];
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[2];


/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    CAST_ME;
    ROM_DADA(menuData);
    ROM_DADA(preset1_region);
    ROM_DADA(preset2_region);
    ROM_DADA(preset3_region);
    ROM_DADA(PRESET_1_STRING);
    ROM_DADA(PRESET_2_STRING);
    ROM_DADA(PRESET_3_STRING);
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MainApp);
    QS_OBJ_DICTIONARY(MainApp_PreActive);
   
     /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), ACTIVATE_STATE_TIME_SIG,
                            MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);
    QTimeEvt_ctorX(&(MainApp->disCtrTimeEvt), (QActive*)me, DISPLAY_CTRL_TIME_SIG, 0U);
    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
    /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif

#ifdef HAS_BLE_CTRL
    QActive_subscribe((QActive*) me, SETTING_UPDATE_SIG);
#endif
}

void MainApp_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Application_Xtor((cApplication*)me);
    
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const *const e)
{
    tGPIODevice *pPowerConf;
    pPowerConf = (tGPIODevice*)getDevicebyId(POWER_DEV_ID,NULL);
    GpioDrv_Ctor(&gpioDrv,pPowerConf);
    GpioDrv_ClearBit(&gpioDrv,CTRL_BOARD_AMP_POWER_IO);
    AMP_STANDBY_ENABLE;
    /* pPreset is set to preset1 by default */
    pPreset = (int16*)Setting_Get(SETID_PRESET_1);
    /* initial the LED for demo usage */
    menuDlg.isCreated = FALSE;
    MainApp_ValidateCriticalInfo();
    return Q_TRAN(&MainApp_PreActive);
}

/* PreActive state */
static QState MainApp_PreActive(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            /* Disable power supply for amplify */
            MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            SwitchModeRespEvt* evt = (SwitchModeRespEvt*)e;
            if (evt->modeId == POWERING_UP_MODE)
            {
                MainApp_SwitchMode(MainApp, NORMAL_MODE);
            }
            else if (evt->modeId == NORMAL_MODE)
            {
                MainApp_RefreshDisCtrlTick(MainApp,TEN_MS);
            }
            return Q_HANDLED();
        }
        case DISPLAY_CTRL_TIME_SIG:
        {
            /* Step1: wait until setting server is ready */
            if(IS_SETTING_SRV_READY)
            {
                pDatabase = (int16*)Setting_Get(SETID_MENU_DATA);// init pDataBase
                //ensure the data is correct even reading from flash encountered errors
                MainApp_ValidateData(pDatabase);
                MainApp_ResetVolume();
                memcpy(currDataCopy, pDatabase, ArraySize(menuDataAttr)*sizeof(int16));
                /* Recover previous user settings */
                MainApp_RecoverPreSett(me);
            }
            else
            {
                MainApp_RefreshDisCtrlTick(MainApp, TEN_MS);
                return Q_HANDLED();
            }
            /* Step 2: display welcome info */
            MainApp_RefreshDisCtrlTick(MainApp, SECONDS_IN_MS(TWO_SECONDS));

            if(displayInfoStep <= DISP_INFO_STEP1)
            {
                DisplaySrv_SendString(initialWelcomeInfo[displayInfoStep]);
                displayInfoStep++;
                return Q_HANDLED();
            }
            /* Step 3: Enable power supply for amplify and go to active state*/
            AMP_STANDBY_DISABLE;
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,FALSE);
#ifdef HAS_SCREEN_DIM_CTRL
            DisplaySrv_SetDimTime(DEFAULT_TIMEOUT_SEC,TRUE);
#endif
            return Q_TRAN(MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            MainApp_StartMenu(me);
            /* Two tasks before go to activate state */
            /* Task 1: reset displayInfoStep*/
            displayInfoStep = DISP_INFO_STEP0;
            /* Task 2: Display default page info */
            /* Dsiplay the info */
            MainApp_DisplayPageInfo(pDefaultPage);
            /* End of task 2 */
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Standby state  - super state for "normal" behaviour */
static QState MainApp_Standby(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            standbyTimer = 0;
            AMP_STANDBY_ENABLE;
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,TRUE);
            MenuDlg_Disable(&menuDlg);
            MainApp_RefreshDisCtrlTick(MainApp,SECONDS_IN_MS(TWO_SECONDS));
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if(AUTO_STANDBY == standbyMode && KEY_EVT_UP == evt->keyEvent)
            {
                /* Note: you do not need to recover the previoud display strings
                 * since the menuDlg will catch this key event and update the screen
                */
                MainApp_UpdateStateChangeInfo(ACTIVE_STATE,HOLDING_TIME_50MS);
                return Q_TRAN(MainApp_PrepareStateChange);
            }
            else if(TRIGGER_STANDBY == standbyMode)
            {
                if(evt->keyId == POWER_KEY && KEY_EVT_UP == evt->keyEvent)
                {
                   MainApp_UpdateStateChangeInfo(ACTIVE_STATE,HOLDING_TIME_50MS);
                   return Q_TRAN(MainApp_PrepareStateChange);
                }
            }
            return Q_HANDLED();
        }
        case DISPLAY_CTRL_TIME_SIG:
        {
            BOOL hasMusic = *(BOOL*)Setting_Get(SETID_MUSIC_DET);
            if(hasMusic)
            {
                if(!standbyMusicCtrl.hasMusicBeforeStandby)
                {
                  /* There is no music when system enters to standby mode and now
                   * there is music stream, we wake up the system
                  */
                  return Q_TRAN(MainApp_Active);
                }
                else
                {
                   // has music before enter to standby, now still have music, clean the timer
                   standbyMusicCtrl.musicStreamTimer = 0;
                }
                
               /* if there is music when system enters to standby mode and now
                 * there is still music stream, we keep in standby
                */
            }
            else
            {
                if(standbyMusicCtrl.hasMusicBeforeStandby)
                {
                    /* There is music when system enters to standby mode and now
                    * the music disapear, we start the timer, if there is music
                    * coming again after the time threshold, we will wake up the system
                    */
                    standbyMusicCtrl.musicStreamTimer++;
                    if(standbyMusicCtrl.musicStreamTimer > (SECONDS_IN_MS(STANDBY_MUSIC_TIMER_THRESHOLD) / TEN_MS))
                    {
                        standbyMusicCtrl.hasMusicBeforeStandby = FALSE;
                    }
                }
            }
            if(TRIGGER_STANDBY == standbyMode)
            {
              if(!GpioDrv_ReadBit(&gpioDrv,TRIGGER_IO))
              {
                  return Q_TRAN(MainApp_Active);
              }
            }
            MainApp_RefreshDisCtrlTick(MainApp, TEN_MS);
            return Q_HANDLED();
        }
        case BLE_WRITE_DATA_REQ_SIG:
        case BLE_READ_DATA_REQ_SIG:
        case BLE_MENU_FEATURE_REQ_SIG:
        {
          if(AUTO_STANDBY == standbyMode || TRIGGER_STANDBY == standbyMode)
          {
            QActive_defer(me, &deferredReqQue, e);
            return Q_TRAN(MainApp_Active);
          }
          return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            displayInfoStep = DISP_INFO_STEP0;
            QTimeEvt_disarm(&(MainApp->disCtrTimeEvt));
            MainApp_ResetVolume();
            MainApp_StartMenu(me);
            MainApp_DisplayPageInfo(pDefaultPage);
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,FALSE);
            AMP_STANDBY_DISABLE;
            standbyMusicCtrl.musicStreamTimer = 0;
            standbyMusicCtrl.hasMusicBeforeStandby = FALSE;
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            scTimer = 0;
            standbyTimer = 0;
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, TEN_MS);
            QActive_recall(me, &deferredReqQue);
            MainApp_ResetStateChangeInfo();
            return Q_HANDLED();
        }
        case AUDIO_MUTE_RESP_SIG:
        {
            GpioDrv_SetBit(&gpioDrv,CTRL_BOARD_AMP_POWER_IO);
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            scTimer = 0; /* any key evt will reset the timer */
            standbyTimer = 0;
            displayVol = FALSE;
            if(POWER_KEY == evt->keyId && (evt->keyEvent == KEY_EVT_DOWN))
            {
                DisplaySrv_SendString(GOODBYE_STRING);
                MenuDlg_Disable(&menuDlg);
                MenuDlg_Reset(&menuDlg);
                if(AUTO_STANDBY == standbyMode || TRIGGER_STANDBY == standbyMode)
                {
                    MainApp_UpdateStateChangeInfo(STANDBY_STATE,SECONDS_IN_MS(TWO_SECONDS));
                }
                else if(ALWAYS_ON_STANDBY == standbyMode)
                {
                    MainApp_UpdateStateChangeInfo(DEACTIVE_STATE,SECONDS_IN_MS(TWO_SECONDS));
                }
                else
                {
                    ASSERT(0);
                }
                //check if there is music playing before going to standby
                MainApp_UpdateStandbyMusicStatus();
                return Q_TRAN(MainApp_PrepareStateChange);
            }
            else if(FACTORY_RESET_KEY == evt->keyId)
            {
                MenuDlg_Reset(&menuDlg);
                MainApp_RefreshMenuNodes();
                return Q_TRAN(MainApp_SysReset);
            }
            else if(SCREEN_OFF_ON_KEY == evt->keyId && KEY_EVT_DOWN == evt->keyEvent)
            {
              if(isScreenOn)
              {
                DisplaySrv_CleanScreen();
                isScreenOn = FALSE;
              }
              else
              {
                DisplaySrv_ResumeScreen();
                isScreenOn = TRUE;
              }
            }
            MainApp_LogoCtrlReset();
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, TEN_MS);
            return Q_HANDLED();
        }
        case ACTIVATE_STATE_TIME_SIG:
        {
            scTimer++;
            MainApp_RefreshSysSett();
            MainApp_UpdateStandbyTimer();
            if(standbyTimer >= (MINUTES_IN_MS(STANDBY_TIME_THRESHOLD_MIN) / TEN_MS))
            {
                //reset logoDisplayTimer for the next display, otherwise it wil have 2 seconds delay after dim
                MainApp_LogoCtrlReset();
                DisplaySrv_SendString(GOODBYE_STRING);
                MainApp_UpdateStateChangeInfo(STANDBY_STATE,SECONDS_IN_MS(TWO_SECONDS));
                return Q_TRAN(MainApp_PrepareStateChange);
            }
            if(scTimer >= (SECONDS_IN_MS(scTimeThreshold) / TEN_MS) && scTimeThreshold != 0)
            {
                if(DISPLAY_OFF == displayMode)
                {
                    /* Setting is off, then turn off the screen */
                    DisplaySrv_CleanScreen();
                    scTimer = 0;
                }
                else if(DISPLAY_LOGO == displayMode)
                {
                    logoDisplayTimer++;
                    if(logoDisplayTimer >= SECONDS_IN_MS(TWO_SECONDS)/ TEN_MS)
                    {
                        logoDisplayTimer = 0;
                        DisplaySrv_SendString(initialWelcomeInfo[displayInfoStep]);
                        if(DISP_INFO_STEP0 == displayInfoStep)
                        {
                            displayInfoStep = DISP_INFO_STEP1;
                        }
                        else if(DISP_INFO_STEP1 == displayInfoStep)
                        {
                            displayInfoStep = DISP_INFO_STEP0;
                        }
                    }
                }
                else if(DISPLAY_VOL == displayMode)
                {
                  if(!displayVol && (!isSysMute) && isScreenOn)
                  {
                    MainApp_DisplayPageInfo(&volNode);
                    displayVol = TRUE;
                  }
                }
            }
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, TEN_MS);
            return Q_HANDLED();
        }
        case BLE_WRITE_DATA_REQ_SIG:
        {
            BleWriteDataReq *pWriteDataReq = (BleWriteDataReq *)e;
            scTimer = 0;
            standbyTimer = 0;
            displayVol = FALSE;
            MainApp_ProcessBleData(me,pWriteDataReq);
            MainApp_LogoCtrlReset();
            MainApp_UpdateString();
#ifdef HAS_SCREEN_DIM_CTRL
            MainApp_RefreshDimTime();
#endif
            MainApp_RefreshSysSett();
            MainApp_RefreshMenuNodes();
            return Q_HANDLED();
        }
        case BLE_READ_DATA_REQ_SIG:
        {
            BleReadDataReq * pReadDataReq = (BleReadDataReq*)e;
            ASSERT(pReadDataReq->offset < (ArraySize(menuDataAttr) * 2));
            ASSERT(pReadDataReq->size <= MAX_DATA_SIZE);
            ASSERT(pReadDataReq->setting_id >=SETID_MENU_DATA &&  pReadDataReq->setting_id <= SETID_PRESET_3_NAME);
            if(pReadDataReq->setting_id == SETID_MENU_DATA)
            {
                uint16 * pData = (uint16*)Setting_Get(pReadDataReq->setting_id);
                MainApp_SendReadDataResp(&pData[(pReadDataReq->offset/2)],pReadDataReq->setting_id,pReadDataReq->size,pReadDataReq->offset);
            }else 
            {
                uint8 * pData = (uint8*)Setting_Get(pReadDataReq->setting_id);
                MainApp_SendReadDataResp(&pData[(pReadDataReq->offset)],pReadDataReq->setting_id,pReadDataReq->size,pReadDataReq->offset);                
            }
            return Q_HANDLED();
        }
        case BLE_RESET_ITEM_REQ_SIG:
        {
            BleResetItemReq *pResetReq = (BleResetItemReq*)e;
            MainApp_ResetItemData(pResetReq->featureId);
            MainApp_RefreshMenuNodes();
            return Q_TRAN(MainApp_ItemResetDisplay);
        }
        case BLE_MENU_FEATURE_REQ_SIG:
        {
            BleFeatureResp * pFeatureResp =  Q_NEW(BleFeatureResp,BLE_MENU_FEATURE_RESP_SIG);
            ASSERT(NUM_OF_FEATURES <= MAX_DATA_SIZE);
            memcpy(pFeatureResp->data,projFeatureSet,NUM_OF_FEATURES);
            pFeatureResp->numberOfFeature = NUM_OF_FEATURES;
            SendToServer(BLE_CTRL_SRV_ID,(QEvt*)pFeatureResp);
            return Q_HANDLED();
        }
        case VIEW_DLG_REQ_SIG:
        {
            uint8 settIndex = 0;
            MenuDataUpdate * pMenuDataEvt = (MenuDataUpdate *)e;
            if(PAGE_SETTING_RESET_YES == pMenuDataEvt->pPageNode->pageSettId)
            {
                MenuDlg_Disable(&menuDlg);
                MenuDlg_Reset(&menuDlg);
                MainApp_RefreshMenuNodes();
                return Q_TRAN(MainApp_SysReset);
            }
            else
            {
                if(MainApp_HandleSysSett(me,pMenuDataEvt) || MainApp_HandleEqSett(me,pMenuDataEvt))
                {
                    MainApp_RefreshMenuNodes();
                    return Q_HANDLED();
                }
                else if(MainApp_HandlePreset(me,pMenuDataEvt))
                {
                    MainApp_RefreshMenuNodes();
                    return Q_HANDLED();
                }
                if(pMenuDataEvt->keyEvt == KEY_EVT_DOWN || pMenuDataEvt->keyEvt == KEY_EVT_REPEAT)
                {
                    /* Find index in database */
                    settIndex = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
                    /* update database */
                    MainApp_UpdateDatabase(pMenuDataEvt,settIndex);
                    /* Sett audio */
                    MainApp_SetAudio(me,pMenuDataEvt->pPageNode,settIndex);
                    /* Dsiplay the info */
                    MainApp_DisplayPageInfo(pMenuDataEvt->pPageNode);
                    /* Do not send indication to BLE when it is change by BLE */
                    if(pMenuDataEvt->keyId == VOLUME_DOWN_KEY || pMenuDataEvt->keyId == VOLUME_UP_KEY)
                    {
                        return Q_HANDLED();
                    }
                    else
                    {
                        MainApp_SendReadDataResp((void*)(&pDatabase[settIndex]),SETID_MENU_DATA,sizeof(uint16),settIndex * sizeof(uint16));
                    }
                    MainApp_RefreshMenuNodes();
                }
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            displayInfoStep = DISP_INFO_STEP0;
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* DeActive state  -- power off */
static QState MainApp_PrepareStateChange(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            MainApp_RefreshDisCtrlTick(MainApp,stageChangeInfo.holdingTime);
            return Q_HANDLED();
        }
        case ACTIVATE_STATE_TIME_SIG:
        {
            /*
            * This is for the case the the system has timer event in the queue beore
            * it enters the current state.
            */
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            return Q_HANDLED();
        }
        case BLE_WRITE_DATA_REQ_SIG:
        case BLE_READ_DATA_REQ_SIG:
        case BLE_MENU_FEATURE_REQ_SIG:
        case VIEW_DLG_REQ_SIG:
        {
            if(stageChangeInfo.targetState == ACTIVE_STATE)
            {
              QActive_defer(me, &deferredReqQue, e);
            }
            return Q_HANDLED();
        }
        case DISPLAY_CTRL_TIME_SIG:
        {
            if(stageChangeInfo.targetState == STANDBY_STATE)
            {
                DisplaySrv_CleanScreen();
                return Q_TRAN(MainApp_Standby);
            }
            else if(stageChangeInfo.targetState == DEACTIVE_STATE)
            {
                DisplaySrv_CleanScreen();
                return Q_TRAN(MainApp_DeActive);
            }
            else if(stageChangeInfo.targetState == ACTIVE_STATE)
            {
                return Q_TRAN(MainApp_Active);
            }
            else
            {
                ASSERT(0);
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(&(MainApp->disCtrTimeEvt));
            return Q_HANDLED();
        }
        default:
        {
            if(stageChangeInfo.targetState == STATE_MAX)
            {
                ASSERT(0);
                /*in release mode, this Q_TRAN will help to recover the system*/
                return Q_TRAN(MainApp_Active);
            }
            break;
        }
    }
    return Q_SUPER(&QHsm_top);
}

static QState MainApp_SysReset(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            AMP_STANDBY_ENABLE;
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,TRUE);
            MainApp_RefreshDisCtrlTick(MainApp,SECONDS_IN_MS(TWO_SECONDS));
            MainApp_FactoryReset(me);
            MainApp_RecoverPreSett(me);
            DisplaySrv_SendString(RESET_DONE_STRING);
            return Q_HANDLED();
        }
        case DISPLAY_CTRL_TIME_SIG:
        {
            if(displayInfoStep < DISP_INFO_BYE)
            {
                DisplaySrv_SendString(initialWelcomeInfo[displayInfoStep]);
                MainApp_RefreshDisCtrlTick(MainApp,SECONDS_IN_MS(TWO_SECONDS));
                displayInfoStep++;
                return Q_HANDLED();
            }
            return Q_TRAN(MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            displayInfoStep = DISP_INFO_STEP0;
            MenuDlg_Reset(&menuDlg);
            MainApp_StartMenu(me);
            MainApp_DisplayPageInfo(pDefaultPage);
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,FALSE);
            AMP_STANDBY_DISABLE;
            QTimeEvt_disarm(&(MainApp->disCtrTimeEvt));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* DeActive state  -- power off */
static QState MainApp_DeActive(QActive * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            AMP_STANDBY_ENABLE;
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,TRUE);
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if(evt->keyEvent == KEY_EVT_DOWN && evt->keyId == POWER_KEY)
            {
               return Q_TRAN(MainApp_PreActive);
            }
            else
            {
               return Q_HANDLED();
            }
        }
        case Q_EXIT_SIG:
        {
            AMP_STANDBY_DISABLE;
            AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,FALSE);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}


static QState MainApp_ItemResetDisplay(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            DisplaySrv_SendString(REVERTED_STRING);
            MainApp_RefreshDisCtrlTick(MainApp,SECONDS_IN_MS(ONE_SECONDS));
            return Q_HANDLED();
        }
        case BLE_RESET_ITEM_REQ_SIG:
        {
            BleResetItemReq *pResetReq = (BleResetItemReq*)e;
            MainApp_ResetItemData(pResetReq->featureId);
            MainApp_RefreshMenuNodes();
            return Q_HANDLED();
        }
        case ACTIVATE_STATE_TIME_SIG:
        {
            /*
            * This is for the case that the timer event is already in the Queue
            * when the state is transfer from active to MainApp_ItemResetDisplay
            */  
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        case BLE_WRITE_DATA_REQ_SIG:
        case BLE_READ_DATA_REQ_SIG:
        case BLE_MENU_FEATURE_REQ_SIG:
        case VIEW_DLG_REQ_SIG:
        {
            QActive_defer(me, &deferredReqQue, e);
            return Q_TRAN(MainApp_Active);
        }
        case AUDIO_MUTE_RESP_SIG:
        case DISPLAY_CTRL_TIME_SIG:
        {
            MenuDlg_Reset(&menuDlg);
            MainApp_StartMenu(me);
            MainApp_DisplayPageInfo(pDefaultPage);
            return Q_TRAN(MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(&(MainApp->disCtrTimeEvt));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}
/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void MainApp_SwitchMode(cMainApp * const me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

static void MainApp_FormatString(int8 settIndex)
{
    
    memcpy(txBuffer,CLEAN_SCREEN,NUM_OF_SCREEN_DIGIT); // clean the buff
    if(FLOAT_TYPE(menuDataAttr[settIndex].valPerStep))
    {
      snprintf((char*)txBuffer, sizeof(txBuffer), (char*)menuDataAttr[settIndex].pUnitString, \
          ((float)pDatabase[settIndex]/(float)VALUE_MAGNIFICATION));
      MainApp_ProcessPEQBootString(settIndex);
    }
    else
    {
      snprintf((char*)txBuffer, sizeof(txBuffer), (char*)menuDataAttr[settIndex].pUnitString, \
          (pDatabase[settIndex]/VALUE_MAGNIFICATION));
    }  
}

static BOOL MainApp_HandleSysSett(QActive * const me, MenuDataUpdate * pMenuDataEvt)
{
    BOOL hasSysSett = TRUE;
    uint8 i;
    switch(pMenuDataEvt->pPageNode->pageSettId)
    {
      case PAGE_SETTING_DISPLAY:
      case PAGE_SETTING_STANDBY:
        {
            i = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
            MainApp_UpdateDatabase(pMenuDataEvt,i);
            MainApp_RefreshSysSett();
            if(PAGE_SETTING_DISPLAY == pMenuDataEvt->pPageNode->pageSettId)
            {
              MainApp_SendDisplayString(i);
            }
            else
            {
              MainApp_SendStandbyString(i);
            }
            MainApp_SendReadDataResp((void*)(&pDatabase[i]),SETID_MENU_DATA,sizeof(uint16),i * sizeof(uint16));
        }
        break;
      case PAGE_SETTING_TIMEOUT:
        {
            i = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
            MainApp_UpdateDatabase(pMenuDataEvt,i);
            MainApp_RefreshSysSett();
            if(scTimeThreshold == DISABLED)
            {
                DisplaySrv_SendString(DISPLAY_OFF_STRING);
#ifdef HAS_SCREEN_DIM_CTRL
                DisplaySrv_SetDimTime(scTimeThreshold,FALSE);
#endif
            }
            else
            {
                MainApp_FormatString(i);
                DisplaySrv_SendString(txBuffer);
#ifdef HAS_SCREEN_DIM_CTRL
                DisplaySrv_SetDimTime(scTimeThreshold,TRUE);
#endif
            }
            MainApp_SendReadDataResp((void*)(&pDatabase[i]),SETID_MENU_DATA,sizeof(uint16),i * sizeof(uint16));
        }
        break;
      default:
        {
            hasSysSett = FALSE;
        }
        break;
    }
    return hasSysSett;
}

static BOOL MainApp_HandlePreset(QActive * const me, MenuDataUpdate * pMenuDataEvt)
{
    BOOL hasSysSett = TRUE;
    eSettingId settingId = SETID_MAX;
    /* step1:Process IR button */
    switch(pMenuDataEvt->keyId)
    {
      case IR_PRESET_KEY_1:
      {
        settingId = SETID_PRESET_1;
        break;
      }
      case IR_PRESET_KEY_2:
      {
        settingId = SETID_PRESET_2;
        break;
      }
      case IR_PRESET_KEY_3:
      {
        settingId = SETID_PRESET_3;
        break;
      }
      default:
        break;
    }
    /* Here we have the settingId != SETID_MAX because we are checking the IR_PRESET_KEY_1/2/3 */
    if(pMenuDataEvt->keyEvt == KEY_EVT_VERY_LONG_HOLD && settingId != SETID_MAX)
    {
         /* copy pDatabase to preset */
        Setting_Set(settingId, pDatabase);
        DisplaySrv_SendString(SAVED_STRING);
        return hasSysSett; 
    }
    else if(settingId != SETID_MAX && pMenuDataEvt->keyEvt != KEY_EVT_SHORT_PRESS)
    {
        /*
         *This meavs one of the IR preset button is pressed,however, it is not a short press
         * and very long hold, so we ignore the key evt.
        */
        return hasSysSett;
    }
    /* Step2 Process request from BLE */
    switch(pMenuDataEvt->pPageNode->pageSettId)
    {
      case PAGE_SETTING_PRE1_LOAD:
      case PAGE_SETTING_PRE2_LOAD:
      case PAGE_SETTING_PRE3_LOAD:
      case PAGE_SETTING_PRE1_SAVE:
      case PAGE_SETTING_PRE2_SAVE:
      case PAGE_SETTING_PRE3_SAVE:
      case PAGE_SETTING_PRE4_LOAD:
        {
            /* Preset is another special case */
            MainApp_HandlePresetCase(me,pMenuDataEvt->pPageNode->pageSettId);
        }
        break;
      default:
        {
            hasSysSett = FALSE;
        }
        break;
    }
    return hasSysSett;
}

static BOOL MainApp_HandleEqSett(QActive * const me, MenuDataUpdate * pMenuDataEvt)
{
    BOOL hasSysSett = TRUE;
    switch(pMenuDataEvt->pPageNode->pageSettId)
    {
      case PAGE_SETTING_LP_ON:
      case PAGE_SETTING_HP_ON:
      case PAGE_SETTING_PEQ1_ON:
      case PAGE_SETTING_PEQ2_ON:
      case PAGE_SETTING_PEQ3_ON:
      case PAGE_SETTING_RGC_ON:
      case PAGE_SETTING_LP_OFF:
      case PAGE_SETTING_HP_OFF:
      case PAGE_SETTING_PEQ1_OFF:
      case PAGE_SETTING_PEQ2_OFF:
      case PAGE_SETTING_PEQ3_OFF:
      case PAGE_SETTING_RGC_OFF:
        {
          /* EQ on and off is special case */
          MainApp_HandleOnOffCase(me,pMenuDataEvt->pPageNode->pageSettId);
        }
        break;
      case PAGE_SETTING_RESET_NO:
        {
            return hasSysSett;
        }
      default:
        {
            hasSysSett = FALSE;
        }
        break;
    }
    return hasSysSett;
}

static void MainApp_FactoryReset(QActive * const me)
{
    int8 i = 0;
    /* Reset current value */
    for(i = 0; i < ArraySize(menuDataAttr); i++)
    {
        pDatabase[i] = menuDataAttr[i].defaultVal;
    }
    /* Reset all presets to default value */
    Setting_Set(SETID_MENU_DATA, pDatabase);
    Setting_Set(SETID_PRESET_1, preset1OriginData);
    Setting_Set(SETID_PRESET_2, preset2OriginData);
    Setting_Set(SETID_PRESET_3, preset3OriginData);
    Setting_Set(SETID_PRESET_1_NAME, PRESET_1_ORIGIN_STRING);
    Setting_Set(SETID_PRESET_2_NAME, PRESET_2_ORIGIN_STRING);
    Setting_Set(SETID_PRESET_3_NAME, PRESET_3_ORIGIN_STRING);
    MainApp_UpdateString();
    MainApp_SendBtCmd(BT_FACTORY_RESET);
}

static void MainApp_SyncSettFromBle(QActive * const me, uint8 settIndex)
{
    ePageSettingId  settingId;
    settingId = menuDataAttr[settIndex].settingId;
    /* Sett settings and display related info */
    if(settingId >= PAGE_SETTING_LP_STATUS && settingId <= PAGE_SETTING_RGC_STATUS)
    {
        /* EQ on and off is special case */
        MainApp_HandleBleOnOffCase(me,menuDataAttr[settIndex].settingId);
        return;
    }
    else if(settingId >= PAGE_SETTING_PRE1_LOAD && settingId <= PAGE_SETTING_PRE3_SAVE)
    {
        /* Preset is another special case */
        MainApp_HandlePresetCase(me,menuDataAttr[settIndex].settingId);
    }
    else if(settingId == PAGE_SETTING_STANDBY)
    {
        MainApp_SendStandbyString(settIndex);
    }
    else if(settingId == PAGE_SETTING_DISPLAY)
    {
        MainApp_SendDisplayString(settIndex);
    }
    else if(settingId == PAGE_SETTING_TIMEOUT)
    {
        if(pDatabase[settIndex] == DISABLED)
        {
            DisplaySrv_SendString(DISPLAY_OFF_STRING);
        }
        else
        {
            MainApp_FormatString(settIndex);
            DisplaySrv_SendString(txBuffer);
        }
    }
    else if(PAGE_SETTING_BRIGHTNESS == settingId)
    {
        DispalySrv_SetBrightnessLevel(pDatabase[settIndex]/VALUE_MAGNIFICATION);
    }
    else if(PAGE_SETTING_POLARITY == settingId)
    {
        MainApp_SetPolarityText(settIndex);
        DisplaySrv_SendString(txBuffer);
        AudioSrv_SetEq(menuDataAttr[settIndex].dspSettId, TRUE);
        //in below sett Audio, it has display update, so we need to return directly
        return;
    }
#ifdef SVS_16_ULTRA_PB
    else if(PAGE_SETTING_TUNNING == settingId)
    {
        MainApp_SetTunningText(settIndex);
        DisplaySrv_SendString(txBuffer);
        AudioSrv_SetEq(menuDataAttr[settIndex].dspSettId, TRUE);
        //in below sett Audio, it has display update, so we need to return directly
        return;
    }
#endif
    /* Sett audio */
    if(DSP_SETT_ID_MAX != menuDataAttr[settIndex].dspSettId)
    {
      AudioSrv_SetEq(menuDataAttr[settIndex].dspSettId, TRUE);
      /* Display the info */
      MainApp_FormatString(settIndex);
      if(PAGE_SETTING_PHASE == settingId) // degree is a special case
      {
         txBuffer[NUM_OF_SCREEN_DIGIT-1] = PHASE_DEGREE;
      }
      DisplaySrv_SendString(txBuffer);
    }
}

static void MainApp_SendDisplayString(uint8 index)
{
    int16 displayMode = pDatabase[index]/VALUE_MAGNIFICATION;
    switch(displayMode)
    {
      case DISPLAY_VOL:
        {
            DisplaySrv_SendString(VOLUME_STRING);
            break;
        }
      case DISPLAY_LOGO:
        {
            DisplaySrv_SendString(DISPLAY_LOGO_STRING);
            break;
        }
      case DISPLAY_OFF:
        {
            DisplaySrv_SendString(DISPLAY_OFF_STRING);
            break;
        }
    default:break;
    }
}

static void MainApp_SendStandbyString(uint8 index)
{
    int16 modeOfstandby = pDatabase[index]/VALUE_MAGNIFICATION;
    switch(modeOfstandby)
    {
      case AUTO_STANDBY:
        {
            DisplaySrv_SendString(DISPLAY_AUTO_STRING);
            break;
        }
      case TRIGGER_STANDBY:
        {
            DisplaySrv_SendString(DISPLAY_TRIGGER_STRING);
            break;
        }
      case ALWAYS_ON_STANDBY:
        {
            DisplaySrv_SendString(DISPLAY_ALWAYS_ON_STRING);
            break;
        }
    default:break;
    }
}

static void MainApp_RecoverPreSett(QActive * const me)
{
    MainApp_RefreshSysSett();
#ifdef HAS_SCREEN_DIM_CTRL
    MainApp_RefreshDimTime();
#endif
    DispalySrv_SetBrightnessLevel(sysSettings[SYS_BRIGHTNESS_LEVEL].sysSetting);
    MainApp_RecoverAduioSett(me, mandatoryAudioSett, ArraySize(mandatoryAudioSett), TRUE);
    MainApp_RecoverAduioSett(me, optionalAudioSett, ArraySize(optionalAudioSett), FALSE);
}

static void MainApp_RefreshSysSett()
{
    int8 i = 0;
    int8 j = 0;
    for(i = 0; i < ArraySize(sysSettings); i++)
    {
        for(j = 0; j < ArraySize(menuDataAttr); j++)
        {
            if(sysSettings[i].settingId == menuDataAttr[j].settingId)
            {
                sysSettings[i].sysSetting = pDatabase[j]/VALUE_MAGNIFICATION;
            }
        }
    }
    displayMode = sysSettings[SYS_SETTING_DISPLAY].sysSetting;
    scTimeThreshold = sysSettings[SYS_SETTING_TIMEOUT].sysSetting;
    standbyMode = sysSettings[SYS_SETTING_STANDBY].sysSetting;
}
static void MainApp_RecoverAduioSett(QActive * const me, const tPageIdDspSettIdMap * pRecover, uint8 num, BOOL isMandatory)
{
    int8 i = 0;
    int8 j = 0;
    /* sett optional audio settings */
    for(i = 0; i < num; i++)
    {
        for(j = 0; j < ArraySize(menuDataAttr); j++)
        {
            if(pRecover[i].settingId == menuDataAttr[j].settingId)
            {
                BOOL enabled = TRUE;
                if(!isMandatory && (DISABLED == (pDatabase[j]/VALUE_MAGNIFICATION)))
                {
                    enabled = FALSE;
                }
                AudioSrv_SetEq(pRecover[i].dspSettId, enabled);
                break;
            }
        }
    }
}

static void MainApp_NextRGCValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case RGC_FREQ_31:
        pDatabase[index] = RGC_FREQ_25;
        break;
      case RGC_FREQ_40:
        pDatabase[index] = RGC_FREQ_31;
        break;
      default:break;
    }
}

static void MainApp_PreRGCValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case RGC_FREQ_25:
        pDatabase[index] = RGC_FREQ_31;
        break;
      case RGC_FREQ_31:
        pDatabase[index] = RGC_FREQ_40;
        break;
      default:break;
    }
}

static void MainApp_PrePEQFreValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case PEQ_FREQ_20:
        pDatabase[index] = PEQ_FREQ_22;
        break;
      case PEQ_FREQ_22:
        pDatabase[index] = PEQ_FREQ_25;
        break;
      case PEQ_FREQ_25:
        pDatabase[index] = PEQ_FREQ_28;
        break;
      case PEQ_FREQ_28:
        pDatabase[index] = PEQ_FREQ_30;
        break;
      default:break;
    }
}

static void MainApp_NextPEQFreValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case PEQ_FREQ_22:
        pDatabase[index] = PEQ_FREQ_20;
        break;
      case PEQ_FREQ_25:
        pDatabase[index] = PEQ_FREQ_22;
        break;
      case PEQ_FREQ_28:
        pDatabase[index] = PEQ_FREQ_25;
        break;
      case PEQ_FREQ_30:
        pDatabase[index] = PEQ_FREQ_28;
        break;
      default:break;
    }
}

static void MainApp_UpdateDatabase(MenuDataUpdate * pMenuDataEvt, uint8 index)
{
    switch(pMenuDataEvt->keyId)
    {
     case PREV_KEY:
       {
         if(PAGE_SETTING_RGC_FREQ == pMenuDataEvt->pPageNode->pageSettId)
         {
            MainApp_PreRGCValue(index);
            return;
         }
         else if(IS_PEQ_FREQ && pDatabase[index] < PEQ_FREQ_30)
         {
            MainApp_PrePEQFreValue(index);
            return;
         }
         if(pDatabase[index] < menuDataAttr[index].maxVal)
         {
            pDatabase[index] += menuDataAttr[index].valPerStep;
         }
         else if(PAGE_SETTING_DISPLAY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_DISPLAY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_STANDBY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_STANDBY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_POLARITY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_DISPLAY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_POLARITY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_STANDBY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_TUNNING == pMenuDataEvt->pPageNode->pageSettId &&\
          pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* Tunning is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_TUNNING == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* Tunning is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
       }
       break;
     case NEXT_KEY:
       {
         if(PAGE_SETTING_RGC_FREQ == pMenuDataEvt->pPageNode->pageSettId)
         {
            MainApp_NextRGCValue(index);
            return;
         }
         else if(IS_PEQ_FREQ && pDatabase[index] <= PEQ_FREQ_30)
         {
            MainApp_NextPEQFreValue(index);
            return;
         }
         if(pDatabase[index] > menuDataAttr[index].minVal)
         {
            pDatabase[index] -= menuDataAttr[index].valPerStep;
         }
         else if(PAGE_SETTING_DISPLAY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_DISPLAY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_STANDBY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_STANDBY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_POLARITY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_PHASE is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_POLARITY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_PHASE is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_TUNNING == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_PHASE is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_TUNNING == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_PHASE is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
       }
       break;
       case IR_VOLUME_UP_KEY:
       case VOLUME_UP_KEY:
         if(pDatabase[index] < menuDataAttr[index].maxVal)
         {
            pDatabase[index] += menuDataAttr[index].valPerStep;
         }
         break;
      case IR_VOLUME_DOWN_KEY:
      case VOLUME_DOWN_KEY:
         if(pDatabase[index] > menuDataAttr[index].minVal)
         {
            pDatabase[index] -= menuDataAttr[index].valPerStep;
         }
         break;
      default:break;
    }
    /* Copy self to self, actually it only sends a update evt */
    Setting_Set(SETID_MENU_DATA, pDatabase);
}

static void MainApp_DisplayPageInfo(const tPageNode * pPageNode)
{
    switch(pPageNode->pageType)
    {
      case PAGE_NAVIGATION_TYPE:
        {
            DisplaySrv_SendString(pPageNode->pPageText);
        }
      break;
      case PAGE_ACTION_TYPE:
        {
            uint8 settIndex = 0;
            /* Find index in database */
            settIndex = MainApp_SearchSettIndex(pPageNode->pageSettId);
            if(PAGE_SETTING_POLARITY == pPageNode->pageSettId)
            {
                MainApp_SetPolarityText(settIndex);
            }
#ifdef SVS_16_ULTRA_PB
            else if(PAGE_SETTING_TUNNING == pPageNode->pageSettId)
            {
                MainApp_SetTunningText(settIndex);
            }
#endif
            else
            {
                MainApp_FormatString(settIndex);
                /* Dsiplay the info */
                if(PAGE_SETTING_PHASE == menuDataAttr[settIndex].settingId)
                {
                    txBuffer[NUM_OF_SCREEN_DIGIT-1] = PHASE_DEGREE;
                }
            }
            DisplaySrv_SendString(txBuffer);
        }
      break;
      default: break;
    }
}
static void MainApp_SetAudio(QActive * const me, const tPageNode * pPageNode, uint8 index)
{
    if(PAGE_NAVIGATION_TYPE != pPageNode->pageType)
    {
         MainApp_DisableMute(me);
         AudioSrv_SetEq(menuDataAttr[index].dspSettId, TRUE);
    }
}
static uint8 MainApp_SearchSettIndex(ePageSettingId pageSettId)
{
    int8 i = 0;
    for(i = 0; i < ArraySize(menuDataAttr); i++)
    {
        if(pageSettId == menuDataAttr[i].settingId)
        {
           break;
        }
    }
    ASSERT(i != ArraySize(menuDataAttr));
    return i;
}

static void MainApp_HandleBleOnOffCase(QActive * const me, ePageSettingId pageSettId)
{
    BOOL  enabled = FALSE;
    uint8 i = MainApp_SearchSettIndex(pageSettId);
    switch(pageSettId)
    {
      case PAGE_SETTING_LP_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(LOW_PASS_OFF_STRINGP);
            }
            else
            {
                DisplaySrv_SendString(LOW_PASS_ON_STRING);
            }
        }
        break;
      case PAGE_SETTING_HP_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(HIGH_PASS_OFF_STRING);
            }
            else
            {
                DisplaySrv_SendString(HIGH_PASS_ON_STRING);
            }
        }
        break;
      case PAGE_SETTING_PEQ1_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(PEQ1_OFF_STRING);
            }
            else
            {
                DisplaySrv_SendString(PEQ1_ON_STRING);
            }
        }
        break;
      case PAGE_SETTING_PEQ2_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(PEQ2_OFF_STRING);
            }
            else
            {
                DisplaySrv_SendString(PEQ2_ON_STRING);
            }
        }
        break;
      case PAGE_SETTING_PEQ3_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(PEQ3_OFF_STRING);
            }
            else
            {
                DisplaySrv_SendString(PEQ3_ON_STRING);
            }
        }
        break;
      case PAGE_SETTING_RGC_STATUS:
        {
            if(DISABLED == pDatabase[i])
            {
                DisplaySrv_SendString(RGC_OFF_STRING);
            }
            else
            {
                DisplaySrv_SendString(RGC_ON_STRING);
            }
        }
        break;
      default:
          ASSERT(0);
        break;
    }

    if(pDatabase[i])
    {
        enabled = TRUE;
    }
    Setting_Set(SETID_MENU_DATA, pDatabase);
    MainApp_DisableMute(me);
    AudioSrv_SetEq(menuDataAttr[i].dspSettId, enabled);
}

static void MainApp_HandleOnOffCase(QActive * const me, ePageSettingId pageSettId)
{
    ePageSettingId realSettId;
    BOOL           enabled = FALSE;
    switch(pageSettId)
    {
       case PAGE_SETTING_LP_OFF:
       case PAGE_SETTING_LP_ON:
         {
            realSettId = PAGE_SETTING_LP_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ1_OFF:
       case PAGE_SETTING_PEQ1_ON:
         {
            realSettId = PAGE_SETTING_PEQ1_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ2_OFF:
       case PAGE_SETTING_PEQ2_ON:
         {
             realSettId = PAGE_SETTING_PEQ2_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ3_OFF:
       case PAGE_SETTING_PEQ3_ON:
         {
             realSettId = PAGE_SETTING_PEQ3_STATUS;
         }
         break;
       case PAGE_SETTING_RGC_OFF:
       case PAGE_SETTING_RGC_ON:
         {
             realSettId = PAGE_SETTING_RGC_STATUS;
         }
        default: break;
    }
    if(pageSettId >= PAGE_SETTING_LP_ON && pageSettId <= PAGE_SETTING_RGC_ON)
    {
        enabled = TRUE;
    }
    else if (pageSettId >= PAGE_SETTING_LP_OFF && pageSettId <= PAGE_SETTING_RGC_OFF)
    {
        enabled = FALSE;
    }
    else
    {
        /* It is not on off case, somewhere is wrong */
        ASSERT(0);
    }
    int8 i = 0;
    /* update data base and set the audio */
    i = MainApp_SearchSettIndex(realSettId);
    if(enabled)
    {
        pDatabase[i] = ENABLED * VALUE_MAGNIFICATION;
    }
    else
    {
        pDatabase[i] = DISABLED;
    }
    Setting_Set(SETID_MENU_DATA, pDatabase);
    MainApp_DisableMute(me);
    AudioSrv_SetEq(menuDataAttr[i].dspSettId, enabled);
    MainApp_SendReadDataResp((void*)(&pDatabase[i]),SETID_MENU_DATA,ONE_ITEM * sizeof(uint16),i * sizeof(uint16));
}

static BOOL MainApp_LoadPresetData(int16 * pPreset)
{
    int8 i = 0;
    BOOL thereIsDiff = FALSE;
    MainApp_ValidateData(pPreset);
    /* Reset current value */
    for(i = EQ_SETTING_START_INDEX; i < ArraySize(menuDataAttr); i++)
    {
        if(pDatabase[i] != pPreset[i])
        {
            thereIsDiff = TRUE;
            pDatabase[i] = pPreset[i];
        }
    }
    return thereIsDiff;
}

static void MainApp_HandlePresetCase(QActive * const me,ePageSettingId pageSettId)
{
    eSettingId settingId = SETID_MAX;
    switch(pageSettId)
    {
       case PAGE_SETTING_PRE1_LOAD:
       case PAGE_SETTING_PRE1_SAVE:
         {
            settingId = SETID_PRESET_1;
         }
         break;
       case PAGE_SETTING_PRE2_LOAD:
       case PAGE_SETTING_PRE2_SAVE:
         {
            settingId = SETID_PRESET_2;
         }
         break;
       case PAGE_SETTING_PRE3_LOAD:
       case PAGE_SETTING_PRE3_SAVE:
         {
            settingId = SETID_PRESET_3;
         }
        default: break;
    }
    if(IS_PRESET_LOAD_ID)
    {
        if(PAGE_SETTING_PRE4_LOAD != pageSettId)
        {
          pPreset = (int16*)Setting_Get(settingId);
          ASSERT(pPreset);
        }
        if(PRESET_EMPTY == pPreset[PRESET_ENPTY_CHECK_INDEX] && PAGE_SETTING_PRE3_LOAD == pageSettId)// check if preset is empty
        {
            DisplaySrv_SendString(EMPTY_STRING);
        }
        else if(PAGE_SETTING_PRE4_LOAD == pageSettId)
        {
            int8 i = 0;
            for(i = EQ_SETTING_START_INDEX; i < ArraySize(menuDataAttr); i++)
            {
                pDatabase[i] = menuDataAttr[i].defaultVal;
            }
            Setting_Set(SETID_MENU_DATA, pDatabase);
            MainApp_RecoverPreSett(me);
            MainApp_DisableMute(me);
            MainApp_SendReadDataResp((void*)&pDatabase[0],SETID_MENU_DATA,ArraySize(menuDataAttr)*sizeof(uint16),NO_OFFSET);
            DisplaySrv_SendString(REVERTED_STRING);
        }
        else
        {
            /* copy pPreset to current data */
            if(MainApp_LoadPresetData(pPreset))
            {
                Setting_Set(SETID_MENU_DATA, pDatabase);
                MainApp_RecoverPreSett(me);
                MainApp_SendReadDataResp((void*)&pDatabase[0],SETID_MENU_DATA,ArraySize(menuDataAttr)*sizeof(uint16),NO_OFFSET);
                MainApp_DisableMute(me);
            }
            DisplaySrv_SendString(LOADED_STRING);
        }
    }
    else
    {
        /* copy pDatabase to preset */
        Setting_Set(settingId, pDatabase);
        DisplaySrv_SendString(SAVED_STRING);
    }
}

static void MainApp_LogoCtrlReset()
{
    //reset logoDisplayTimer for the next display, otherwise it wil have 2 seconds delay after dim
    logoDisplayTimer  = SECONDS_IN_MS(TWO_SECONDS)/ TEN_MS;
    //This reset will ensure that the logo display start from SVS....
    displayInfoStep = DISP_INFO_STEP0;
}

static void MainApp_UpdateString()
{
    uint8 * pString = NULL;
    pString = (uint8*)Setting_Get(SETID_PRESET_1_NAME);
    memcpy(PRESET_1_CURRENT_STRING, pString, 8);
    pString = (uint8*)Setting_Get(SETID_PRESET_2_NAME);
    memcpy(PRESET_2_CURRENT_STRING, pString, 8);
    pString = (uint8*)Setting_Get(SETID_PRESET_3_NAME);
    memcpy(PRESET_3_CURRENT_STRING, pString, 8);
}

//This function will check the ligality of the data which is posted by BLE.
static BOOL MainApp_DataVerification(BleWriteDataReq* pBleDataEvt)
{
    uint8 startIndex = (pBleDataEvt->offset)/sizeof(uint16);
    ASSERT(startIndex < ArraySize(menuDataAttr));
    ASSERT(pBleDataEvt->size <= (SIZE_OF_LARGE_EVENTS - sizeof(eSettingId) - sizeof(uint16) - sizeof(uint16)));
    uint8 i = 0;
    int16 data = 0;
    if(SETID_MENU_DATA == pBleDataEvt->setting_id)
    {
        for(i = 0; i < pBleDataEvt->size; i += sizeof(uint16))
        {
            memcpy((void*)(&data),(void*)(&(pBleDataEvt->data[0])),sizeof(uint16));
            if(data < menuDataAttr[startIndex].minVal || data > menuDataAttr[startIndex].maxVal)
            {
                return FALSE;
            }
            startIndex++;
        }
    }
    else
    {
        ASSERT(pBleDataEvt->size <= NUM_OF_SCREEN_DIGIT);
        for(i = 0; i < pBleDataEvt->size; i++)
        {
            if(!IS_CHARACTER_LEGAL)
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

static void MainApp_ProcessBleData(QActive * const me,BleWriteDataReq* pBleDataEvt)
{
    if(MainApp_DataVerification(pBleDataEvt))
    {
      if(SETID_MENU_DATA == pBleDataEvt->setting_id)
      {
          uint8 startIndex = (pBleDataEvt->offset)/sizeof(uint16);
          memcpy(&pDatabase[startIndex], pBleDataEvt->data, pBleDataEvt->size);
          MainApp_SyncSettFromBle(me,startIndex);
          //ask setting server to write data to flash
          Setting_Set(SETID_MENU_DATA, pDatabase);
      }
      else
      {
          Setting_Set(pBleDataEvt->setting_id, (&pBleDataEvt->data[0]));
      }
    }
    else 
    {
        //in release mode, the wrong data will be simply igonred
        ASSERT(0);
    }
}

static void MainApp_DisableMute(QActive * const me)
{
    if(isSysMute)
    {
        isSysMute = FALSE;
        AudioSrv_SendMuteReq(me,AUDIO_AMP_MUTE,FALSE);
    }
}

#ifdef HAS_SCREEN_DIM_CTRL
static void MainApp_RefreshDimTime()
{
    if(scTimeThreshold == DISABLED)
    {
        DisplaySrv_SetDimTime(scTimeThreshold,FALSE);
    }
    else
    {
        DisplaySrv_SetDimTime(scTimeThreshold,TRUE);
    }
}
#endif

static void MainApp_UpdateStandbyTimer()
{
    BOOL hasMusic = *(BOOL*)Setting_Get(SETID_MUSIC_DET);
    if(hasMusic)
    {
        standbyTimer = 0;
    }
    else
    {
        if(AUTO_STANDBY == standbyMode)
        {
            standbyTimer++;
        }
        else
        {
            if(TRIGGER_STANDBY == standbyMode && GpioDrv_ReadBit(&gpioDrv,TRIGGER_IO))
            {
                standbyTimer++;
            }
            else
            {
                standbyTimer = 0;
            }
        }
    }
}


static void MainApp_StartMenu(QActive * const me)
{
    if(menuDlg.isCreated)
    {
      MenuDlg_Enable(&menuDlg);
    }
    else
    {
      MenuDlg_Ctor(&menuDlg, (QActive*)me, &menu);  
    }
    MainApp_InitPageStatus();
}

//update the defualt display page nodes
static void MainApp_InitPageStatus()
{
    uint8 j;
    for(j = 0; j < ArraySize(menuDataAttr); j++)
    {
        switch(menuDataAttr[j].settingId)
        {
          case PAGE_SETTING_LP_STATUS:
            MainApp_UpdatePageStatus(&lpOff,&lpOn,j);
            break;
          case PAGE_SETTING_PEQ1_STATUS:
            MainApp_UpdatePageStatus(&peq1Off,&peq1On,j);
            break;
          case PAGE_SETTING_PEQ2_STATUS:
            MainApp_UpdatePageStatus(&peq2Off,&peq2On,j);
            break;
          case PAGE_SETTING_PEQ3_STATUS:
            MainApp_UpdatePageStatus(&peq3Off,&peq3On,j);
            break;
          case PAGE_SETTING_RGC_STATUS:
            MainApp_UpdatePageStatus(&rgcOff,&rgcOn,j);
            break;
          default:
            break;
        }
    }
}

static void MainApp_UpdatePageStatus(tPageNode * pageNodeOff,tPageNode * pageNodeOn, uint8 i)
{
     if((pDatabase[i]/VALUE_MAGNIFICATION) == ENABLED)
    {
        pageNodeOn->pageStatus = PAGE_ACTIVE;
        pageNodeOff->pageStatus = PAGE_DEACTIVE;
    }
    else
    {
        pageNodeOff->pageStatus = PAGE_ACTIVE;
        pageNodeOn->pageStatus = PAGE_DEACTIVE;
    } 
}

static void MainApp_ResetVolume()
{
    int8 settIndex = MainApp_SearchSettIndex(PAGE_SETTING_VOL);
    if(pDatabase[settIndex] >= menuDataAttr[settIndex].defaultVal)
    {
        pDatabase[settIndex] = menuDataAttr[settIndex].defaultVal;
        AudioSrv_SetEq(DSP_VOLUME_SETT_ID, TRUE);
        MainApp_SendReadDataResp((void*)(&pDatabase[settIndex]),SETID_MENU_DATA,sizeof(uint16),settIndex * sizeof(uint16));
    }
}

static void MainApp_ResetItemData(uint8 featureId)
{
    BOOL dataReseted = FALSE;
    BOOL isEqOn = FALSE;
    switch(featureId)
    {
      case DISPLAY_ID:
      {
        dataReseted = MainApp_ResetData(PAGE_SETTING_DISPLAY);
        if(dataReseted)
        {
           MainApp_SendReadDataResp((void*)&pDatabase[DISPLAY_OFFSET/2],SETID_MENU_DATA,sizeof(uint16),DISPLAY_OFFSET);
        }
      }
        break;
      case SYSTEM_TIMEOUT_ID:
      {
        dataReseted = MainApp_ResetData(PAGE_SETTING_TIMEOUT);
        if(dataReseted)
        {
            MainApp_SendReadDataResp((void*)(&pDatabase[TIMEOUT_OFFSET/2]),SETID_MENU_DATA,sizeof(uint16),TIMEOUT_OFFSET);
        }
      }
        break;
      case SYSTEM_STANDBY_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_STANDBY);
         if(dataReseted)
         {
            MainApp_SendReadDataResp((void*)(&pDatabase[STANDBY_OFFSET/2]),SETID_MENU_DATA,sizeof(uint16),STANDBY_OFFSET);
         }
      }
        break;
      case LP_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_LP_STATUS);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_LP_FRE);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_LP_SLO);
         if(dataReseted)
         {
            MainApp_InitPageStatus();
            MainApp_SendReadDataResp((void*)(&pDatabase[LP_STATUS_OFFSET/2]),SETID_MENU_DATA,6,LP_STATUS_OFFSET);
            isEqOn = MainApp_IsEqOn(pDatabase[LP_STATUS_OFFSET/2]);
            AudioSrv_SetEq(DSP_EQ_CTRL_USER_LP, isEqOn);
         }
      }
        break;
      case PEQ1_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_PEQ1_STATUS);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ1_FRE);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ1_BOOST);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ1_Q);
         if(dataReseted)
         {
            MainApp_InitPageStatus();
            MainApp_SendReadDataResp((void*)(&pDatabase[PEQ1_STATUS_OFFSET/2]),SETID_MENU_DATA,8,PEQ1_STATUS_OFFSET);
            isEqOn = MainApp_IsEqOn(pDatabase[PEQ1_STATUS_OFFSET/2]);
            AudioSrv_SetEq(DSP_EQ_CTRL_PEQ1, isEqOn);
         }
      }
        break;
      case PEQ2_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_PEQ2_STATUS);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ2_FRE);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ2_BOOST);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ2_Q);
         if(dataReseted)
         {
            MainApp_InitPageStatus();
            MainApp_SendReadDataResp((void*)(&pDatabase[PEQ2_STATUS_OFFSET/2]),SETID_MENU_DATA,8,PEQ2_STATUS_OFFSET);
            isEqOn = MainApp_IsEqOn(pDatabase[PEQ2_STATUS_OFFSET/2]);
            AudioSrv_SetEq(DSP_EQ_CTRL_PEQ2, isEqOn);
         }
      }
        break;
      case PEQ3_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_PEQ3_STATUS);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ3_FRE);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ3_BOOST);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_PEQ3_Q);
         if(dataReseted)
         {
            MainApp_InitPageStatus();
            MainApp_SendReadDataResp((void*)(&pDatabase[PEQ3_STATUS_OFFSET/2]),SETID_MENU_DATA,8,PEQ3_STATUS_OFFSET);
            isEqOn = MainApp_IsEqOn(pDatabase[PEQ3_STATUS_OFFSET/2]);
            AudioSrv_SetEq(DSP_EQ_CTRL_PEQ3, isEqOn);
         }
      }
        break;
      case RGC_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_RGC_STATUS);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_RGC_FREQ);
         dataReseted |= MainApp_ResetData(PAGE_SETTING_RGC_SLOPE);
         if(dataReseted)
         {
            MainApp_InitPageStatus();
            MainApp_SendReadDataResp((void*)(&pDatabase[RGC_STATUS_OFFSET/2]),SETID_MENU_DATA,6,RGC_STATUS_OFFSET);
            isEqOn = MainApp_IsEqOn(pDatabase[RGC_STATUS_OFFSET/2]);
            AudioSrv_SetEq(DSP_EQ_CTRL_RGC, isEqOn);
         }
      }
        break;
      case PHASE_ID:
      {
        dataReseted = MainApp_ResetData(PAGE_SETTING_PHASE);
        if(dataReseted)
        {
            MainApp_SendReadDataResp((void*)(&pDatabase[PHASE_OFFSET/2]),SETID_MENU_DATA,2,PHASE_OFFSET);
            AudioSrv_SetEq(DSP_PHASE_SETT_ID, TRUE);
        }
      }
        break;
      case VOLUME_ID:
      {
        dataReseted = MainApp_ResetData(PAGE_SETTING_VOL);
        if(dataReseted)
        {
            MainApp_SendReadDataResp((void*)(&pDatabase[VOL_OFFSET/2]),SETID_MENU_DATA,2,VOL_OFFSET);
            AudioSrv_SetEq(DSP_VOLUME_SETT_ID, TRUE);
        }
      }
        break;
      case POLARITY_ID:
      {
         dataReseted = MainApp_ResetData(PAGE_SETTING_POLARITY);
         if(dataReseted)
         {
            MainApp_SendReadDataResp((void*)(&pDatabase[POLARITY_OFFSET/2]),SETID_MENU_DATA,2,POLARITY_OFFSET);
            AudioSrv_SetEq(DSP_POLARITY_SETT_ID, TRUE);
         }
      }
        break;
      case TURNNING_ID:
      {
        dataReseted = MainApp_ResetData(PAGE_SETTING_TUNNING);
        if(dataReseted)
        {
           MainApp_SendReadDataResp((void*)(&pDatabase[TUNNING_OFFSET/2]),SETID_MENU_DATA,2,TUNNING_OFFSET);
           AudioSrv_SetEq(DSP_TUNNING_SETT_ID, TRUE);
        }
      }
        break;
      case PRESET_NAME_ID:
        {
            MainApp_ResetPresetName(SETID_PRESET_1_NAME,PRESET_1_ORIGIN_STRING);
            MainApp_ResetPresetName(SETID_PRESET_2_NAME,PRESET_2_ORIGIN_STRING);
            MainApp_ResetPresetName(SETID_PRESET_3_NAME,PRESET_3_ORIGIN_STRING);
            MainApp_UpdateString();
        }
        break;
      case BRIGHTNESS_ID:
      {
          dataReseted = MainApp_ResetData(PAGE_SETTING_BRIGHTNESS);
          if(dataReseted)
          {
            MainApp_SendReadDataResp((void*)(&pDatabase[BRIGHTNESS_OFFSET/2]),SETID_MENU_DATA,2,BRIGHTNESS_OFFSET);
            DispalySrv_SetBrightnessLevel(pDatabase[BRIGHTNESS_OFFSET/2]/VALUE_MAGNIFICATION);
          }
      }
      break;
     default:
        ASSERT(0);
        break;
    }
    //triger setting server to write data to flash
    if(dataReseted)
    {
        Setting_Set(SETID_MENU_DATA, pDatabase);
    }
}

static BOOL MainApp_ResetData(ePageSettingId pageSettingId)
{
    uint8 i = 0;
    for(i = 0; i <= ArraySize(menuDataAttr); i++)
    {
        if(pageSettingId == menuDataAttr[i].settingId &&pDatabase[i] != menuDataAttr[i].defaultVal)
        {
            pDatabase[i] = menuDataAttr[i].defaultVal;
            return TRUE;
        }
    }
    return FALSE;
}

static void MainApp_ResetPresetName(eSettingId presetNameId, const uint8 * pOriginalString)
{
    uint8 * pString = NULL;
    int32 compareResult = STRING_EQUAL;
    pString = (uint8*)Setting_Get(presetNameId);
    compareResult = strcmp((const char *)pString,(const char *)pOriginalString);
    if(compareResult != STRING_EQUAL)
    {
        Setting_Set(presetNameId, pOriginalString);
        MainApp_SendReadDataResp(pString,presetNameId,NUM_OF_SCREEN_DIGIT,0); 
    }
}

static void MainApp_SendReadDataResp(void * pDataToSend, eSettingId settId, uint16 size, uint16 offset)
{
    ASSERT((size % 2) == 0);
    if(size <= SMALL_DATA_SIZE)
    {
        BleReadDataSmallResp * pDataResponse =  Q_NEW(BleReadDataSmallResp,BLE_READ_DATA_RESP_SIG);
        pDataResponse->setting_id = settId;
        pDataResponse->size = size;
        pDataResponse->offset = offset;
        memcpy((void*)(&(pDataResponse->data[0])),(void*)pDataToSend,size);
        SendToServer(BLE_CTRL_SRV_ID,(QEvt*)pDataResponse);
    }
    else if(size <= MEDIUM_DATA_SIZE)
    {
        BleReadDataMediumResp * pDataResponse =  Q_NEW(BleReadDataMediumResp,BLE_READ_DATA_RESP_SIG);
        pDataResponse->setting_id = settId;
        pDataResponse->size = size;
        pDataResponse->offset = offset;
        memcpy((void*)(&(pDataResponse->data[0])),(void*)pDataToSend,size);
        SendToServer(BLE_CTRL_SRV_ID,(QEvt*)pDataResponse);        
    }
    else
    {
        BleReadDataLargeResp * pDataResponse =  Q_NEW(BleReadDataLargeResp,BLE_READ_DATA_RESP_SIG);
        pDataResponse->setting_id = settId;
        pDataResponse->size = size;
        pDataResponse->offset = offset;
        memcpy((void*)(&(pDataResponse->data[0])),(void*)pDataToSend,size);
        SendToServer(BLE_CTRL_SRV_ID,(QEvt*)pDataResponse);
    }
}

static BOOL MainApp_IsEqOn(int16 statusValue)
{
    switch(statusValue)
    {
      case EQ_ON:
        return TRUE;
      case EQ_OFF:
        return FALSE;
      default:ASSERT(0);
        break;
    }
    return FALSE;
}

static void MainApp_RefreshMenuNodes()
{
    uint8 i = 0 ;
    for(i = 0; i < ArraySize(nodesToUpdate); i += 2)
    {
        uint8 index = 0;
        BOOL isOn = FALSE;
        ePageSettingId    pageSettId = PAGE_SETTING_ID_MAX;
        switch(nodesToUpdate[i]->pageSettId)
        {
          case PAGE_SETTING_LP_OFF:
            pageSettId = PAGE_SETTING_LP_STATUS;
            break;
          case PAGE_SETTING_PEQ1_OFF:
            pageSettId = PAGE_SETTING_PEQ1_STATUS;
            break;
          case PAGE_SETTING_PEQ2_OFF:
            pageSettId = PAGE_SETTING_PEQ2_STATUS;
            break;
          case PAGE_SETTING_PEQ3_OFF:
            pageSettId = PAGE_SETTING_PEQ3_STATUS;
            break;
          case PAGE_SETTING_RGC_OFF:
            pageSettId = PAGE_SETTING_RGC_STATUS;
            break;
          default:
            ASSERT(0);
            break;
        }
        if(pageSettId != PAGE_SETTING_ID_MAX)
        {
          index = MainApp_SearchSettIndex(pageSettId);
          isOn = MainApp_IsEqOn(pDatabase[index]);
          if(isOn)
          {
              nodesToUpdate[i]->pageStatus = PAGE_DEACTIVE;
              nodesToUpdate[i+1]->pageStatus = PAGE_ACTIVE;
          }
          else
          {
              nodesToUpdate[i]->pageStatus = PAGE_ACTIVE;
              nodesToUpdate[i+1]->pageStatus = PAGE_DEACTIVE;
          }
        }
    }
}


static void MainApp_RefreshDisCtrlTick(cMainApp * const me, const uint16 tickTime)
{
    QTimeEvt_disarm(&(me->disCtrTimeEvt));
    QTimeEvt_armX(&(me->disCtrTimeEvt), GET_TICKS_IN_MS(tickTime), 0);
}

static void MainApp_ValidateData(int16 * pData)
{
    uint8 i;
    for(i = 0; i < ArraySize(menuDataAttr); i++)
    {
        if(pData[i] < menuDataAttr[i].minVal || pData[i] > menuDataAttr[i].maxVal)
        {
            pData[i] = menuDataAttr[i].defaultVal;
        }
    }
}


static void MainApp_ValidateCriticalInfo()
{
    uint8 i;
    i = MainApp_SearchSettIndex(PAGE_SETTING_LP_STATUS);
    ASSERT(i == EQ_SETTING_START_INDEX);
    ASSERT(i == (LP_STATUS_OFFSET/2));
    ASSERT(ArraySize(menuDataAttr) == NUM_OF_MENU_SETT_ITEMS);
    //the array write to flash should be in size of multiple of 4
    ASSERT((NUM_OF_MENU_SETT_ITEMS%2) == 0);
    ASSERT(MAX_DATA_SIZE == (ArraySize(menuDataAttr)*2));
    
    //DSP data index check
    i = MainApp_SearchSettIndex(PAGE_SETTING_LP_FRE);
    ASSERT(DB_INDEX_OF_LP == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_PEQ1_FRE);
    ASSERT(DB_INDEX_OF_PEQ1 == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_PEQ2_FRE);
    ASSERT(DB_INDEX_OF_PEQ2 == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_PEQ3_FRE);
    ASSERT(DB_INDEX_OF_PEQ3 == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_RGC_FREQ);
    ASSERT(DB_INDEX_OF_RGC == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_VOL);
    ASSERT(DB_INDEX_OF_VOL == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_PHASE);
    ASSERT(DB_INDEX_OF_PHASE == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_POLARITY);
    ASSERT(DB_INDEX_OF_POLARITY == i);
    i = MainApp_SearchSettIndex(PAGE_SETTING_TUNNING);
    ASSERT(DB_INDEX_OF_TUNNING == i);
}

/* This function handles a special customer requirement that when PEQ boot is less than
* -10.0(float type), the screen doesn't have enough position to display all characters
*  Capitial 'B' of the unit 'dB' will be will be removed
*/

static void MainApp_ProcessPEQBootString(int8 settIndex)
{
    if(menuDataAttr[settIndex].settingId == PAGE_SETTING_PEQ1_BOOST || \
       menuDataAttr[settIndex].settingId == PAGE_SETTING_PEQ2_BOOST || \
       menuDataAttr[settIndex].settingId == PAGE_SETTING_PEQ3_BOOST)
    {
        if(pDatabase[settIndex] > PEQ_BOOST_DISPLAY_THRESHOLD)
        {
            txBuffer[7] = 'd';
            txBuffer[8] = 'B';
        }
        else if(pDatabase[settIndex] <= PEQ_BOOST_DISPLAY_THRESHOLD)
        {
            txBuffer[8] = 'd';
        }
    }
}

static void MainApp_UpdateStandbyMusicStatus()
{
    BOOL hasMusic = *(BOOL*)Setting_Get(SETID_MUSIC_DET);
    if(hasMusic)
    {
        standbyMusicCtrl.hasMusicBeforeStandby = TRUE;
    }
    else
    {
        standbyMusicCtrl.hasMusicBeforeStandby = FALSE;
    }
}


static void MainApp_SendBtCmd(eBtCmd btCmd)
{
    BtCmdEvt *pEvt = Q_NEW(BtCmdEvt,BLE_CONSUMING_REQ_SIG);
    pEvt->btCmd = btCmd;
    SendToServer(BLE_CTRL_SRV_ID, (QEvt*)pEvt);
}

static void MainApp_UpdateStateChangeInfo(eTargetState targetState, int32 holdTime)
{
    stageChangeInfo.targetState = targetState;
    if(0 == holdTime)
    {
        stageChangeInfo.holdingTime++;
    }
    else
    {
        stageChangeInfo.holdingTime = holdTime;
    }
}

static void MainApp_ResetStateChangeInfo()
{
    stageChangeInfo.targetState = STATE_MAX;
    stageChangeInfo.holdingTime = 0;
}

static void MainApp_SetPolarityText(uint8 settIndex)
{
    if(POLARITY_POSITIVE== pDatabase[settIndex])
    {
      memcpy(txBuffer,POLARITY_POSITIVE_STRING,NUM_OF_SCREEN_DIGIT);
    }
    else if(POLARITY_NEGATIVE== pDatabase[settIndex])
    {
      memcpy(txBuffer,POLARITY_NEGATIVE_STRING,NUM_OF_SCREEN_DIGIT);
    }
}
#ifdef SVS_16_ULTRA_PB
static void MainApp_SetTunningText(uint8 settIndex)
{
    if(PORT_TUNNING_STANDARD == pDatabase[settIndex])
    {
      memcpy(txBuffer,TUNNING_STANDARD,NUM_OF_SCREEN_DIGIT);
    }
    else if(PORT_TUNNING_EXTENDED == pDatabase[settIndex])
    {
      memcpy(txBuffer,TUNNING_EXTENDED,NUM_OF_SCREEN_DIGIT);
    }
    else if(PORT_TUNNING_SEALED == pDatabase[settIndex])
    {
      memcpy(txBuffer,TUNNING_SEALED,NUM_OF_SCREEN_DIGIT);
    }
}
#endif
/****************************Amplify Control******************************************/

static void AMP_StandbyCtrl(BOOL standbyEnable)
{
    if(standbyEnable)
    {
        GpioDrv_SetBit(&gpioDrv,AMP_STANDBY_IO);
    }
    else 
    {
        GpioDrv_ClearBit(&gpioDrv,AMP_STANDBY_IO);
    }
}

//    int32 acVotage;
//    acVotage = ADCDrv_GetData(&adcDrvForAmp,AC_DETECT_PIN);
//    BOOL isAcDetected = FALSE;
//    if(acVotage >= 2V)
//    {
//        isAcDetected = TRUE;
//    }
//    return isAcDetected;
//    }
//    return isAcDetected;
//}
/*** use interrupt for fail detect ***/

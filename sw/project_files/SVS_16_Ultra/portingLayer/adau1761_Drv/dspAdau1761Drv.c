/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  dsp 1761 driver
                  -------------------------

                  SW Module Document




@file        dsp_adau1761_driver.c
@brief       This file implements the drivers for adau1761 
@author      Jerry Guo,Edmond Sung, Bob.Xu 
@date        2014-08-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-17     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 

Change History:
VERSION    : 2    DRAFT      2014-09-28     Daniel.Duan, Bob.Xu  
DESCRIPTION: Refactor audio sever, to add BT tone support
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include <stdio.h>
#include <math.h>
#include "trace.h"
#include "cplus.h"
#include "commonTypes.h"
#include "I2CDrv.h"
#include "SettingSrv.h"
#include "DspDrv1761.h"
#include "timer.h"
#include "./dspAdau1761Drv_priv.h"
#include "./dspAdau1761Drv_IC_1.h"
#include "./dspAdau1761Drv_IC_1_PARAM.h"
#include "./dspAdau1761Drv_IC_1_REG.h"
#include "DspDrv.Conf"

#ifndef NULL
#define NULL                             (0)
#endif

#ifndef DspDrv1761_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif
static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out);
static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out);

static int16 *pSettData;
static cDSPDrv1761 * pDspObj;
static BOOL          isPhaseInited = FALSE;
static uint16 phaseTimer = INVALIDE_TIMER;

static tDspInitSection DspInitSection[]=
{
    {&DspDrv1761_InitSection0, 50},
    {&DspDrv1761_InitSection1, 100},
    {&DspDrv1761_InitSection2, 50},
};


static tCtrIdEQIdMap ctrIdEQIdMap[] = 
{
   /* DSP setting ID  index of setting db*/
   {DSP_EQ_CTRL_USER_LP, DB_INDEX_OF_LP},
   {DSP_EQ_CTRL_RGC,     DB_INDEX_OF_RGC},
   {DSP_EQ_CTRL_PEQ1,    DB_INDEX_OF_PEQ1},
   {DSP_EQ_CTRL_PEQ2,    DB_INDEX_OF_PEQ2},
   {DSP_EQ_CTRL_PEQ3,    DB_INDEX_OF_PEQ3},
   {DSP_PHASE_SETT_ID,   DB_INDEX_OF_PHASE},
   {DSP_VOLUME_SETT_ID,  DB_INDEX_OF_VOL},
   {DSP_POLARITY_SETT_ID,DB_INDEX_OF_POLARITY},
   {DSP_TUNNING_SETT_ID, DB_INDEX_OF_TUNNING}
};

void DSPDrv1761_Ctor(cDSPDrv1761 * me, cI2CDrv *pI2cObj)
{
    me->i2cObj        = pI2cObj;
    me->pInitTable    = DspInitSection;
    me->sectionSize   = ArraySize(DspInitSection);
    me->initPhase     = 0;
    me->max_vol       = MAX_VOLUME;
    me->default_vol   = DEFAULT_VOLUME;
    me->isCreated     = TRUE;
    me->deviceAddr    = DSP_I2C_ADDRESS;
#ifdef HAS_MENU
    pSettData         = (int16*)Setting_Get(SETID_MENU_DATA);
#endif
    pDspObj           = me;
}

void DSPDrv1761_Xtor(cDSPDrv1761 * me)
{
    me->pInitTable    = NULL;
    me->sectionSize   = 0;
    me->initPhase     = 0;
    me->isCreated     = FALSE;
}


uint16 DSPDrv1761_Init(cDSPDrv1761 * me)
{
    uint16 delaytime;
    ASSERT(me);
    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
        return 0;
    }
    return (delaytime);
}

/**
 * Mutes the DSP DAC output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1761_Mute(cDSPDrv1761 *me, eAudioMuteType muteType, BOOL muteEnable)
{
    uint8 mixer_lr = 0;//mixer LR_RIGHT
    uint8 mixer_ll = 0;//mixer LR_LEFT
    uint8  temp[3] = {0};
    ASSERT(me->deviceAddr);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_LEFT_ADDR,  MIXER_REG_LENGTH, (uint8*)&mixer_ll);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_RIGHT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_lr);
    switch(muteEnable)
    {
    case TRUE:
      {
        mixer_ll = (mixer_ll & 0xFD); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
        mixer_lr = (mixer_lr & 0xF7); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
      }
      break;
    case FALSE:
      {
        mixer_ll = (mixer_ll | 0x02); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
        mixer_lr = (mixer_lr | 0x08); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
      }
      break;
    }
}

/**
 * Set volume
 *
 * @param      uint8        target volume
 * @return     void
 */
static void DSPDrv1761_SetVol(cDSPDrv1761 *me, uint8 vol)
{
    /* write DSP register */
    uint8        vol_iic[4] = {0};
    uint16       reg;

    if(vol > MAX_VOLUME)
    {
        vol = MAX_VOLUME;
    }

    reg = VOLUME_CTRL_ADDRESS;
    vol_iic[0] = 0;
    vol_iic[1] = 0;
    vol_iic[2] = 0;
    vol_iic[3] = vol;

    DspDrv1761_SafeLoadData(me, 1, vol_iic, reg);
}
/**
* Audio related setting intrance
* @param[in]    me             dsp object
* @param[in]    dspSettId      dsp setting ID
* @param[in]    enable         disable or enable the settings
*/
void DSPDrv1761_SetAudio(cDSPDrv1761 *me, eAudioSettId dspSettId, BOOL enable)
{
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
        {
            break;
        }
    }
    ASSERT(dspSettId < DSP_SETT_ID_MAX);
    switch(dspSettId)
    {
      case DSP_VOLUME_SETT_ID:
        {
          if(enable)
          {
            /* Convert it to positive */
            uint8 volume = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION+MAX_VOLUME;
            DSPDrv1761_SetVol(me,volume);
          }
          else
          {
            DSPDrv1761_SetVol(me,0);
          }
        }
        break;
      case DSP_EQ_CTRL_RGC:
        {
          uint16        freq;
          eUserRGCSlope slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserRGCSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
          DspDrv1761_SetRGC(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_USER_LP:
        {
          uint16         freq;
          eUserLpSlope  slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserLpSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
          DspDrv1761_SetUserLp(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_USER_HP:
        {
          uint16         freq;
          eUserHpSlope  slope;
          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
          slope = (eUserHpSlope)((pSettData[ctrIdEQIdMap[i].dbIndex+1])/VALUE_MAGNIFICATION);
          DspDrv1761_SetUserHp(me, freq, slope, enable);
        }
        break;
      case DSP_EQ_CTRL_PEQ1:
      case DSP_EQ_CTRL_PEQ2:
      case DSP_EQ_CTRL_PEQ3:
        DspDrv1761_SetPeq(me, dspSettId, i, enable);
        break;
      case DSP_PHASE_SETT_ID:
        DspDrv1761_SetPhase(me, (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION);
        break;
      case DSP_POLARITY_SETT_ID:
        DspDrv1761_SetPolarity(me, (ePolarityType)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
        break;
      case DSP_TUNNING_SETT_ID:
        DspDrv1761_SetTuning(me, (eTuningRange)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
        break;
      default:break;
    }
}

void DspDrv1761_SetLimiter(cDSPDrv1761 *me, int16 limiterLevel)
{
   uint8 *coefficientArray = NULL;
   switch(limiterLevel)
   {
     case LIMITER_LEVEL_MINUS_20_DB:
       coefficientArray = limiter_minus_20;
       break;
     case LIMITER_LEVEL_MINUS_22_DB:
       coefficientArray = limiter_minus_22;
       break;
     case LIMITER_LEVEL_MINUS_24_DB:
       coefficientArray = limiter_minus_24;
       break;
     case LIMITER_LEVEL_MINUS_26_DB:
       coefficientArray = limiter_minus_26;
       break;
     case LIMITER_LEVEL_MINUS_28_DB:
       coefficientArray = limiter_minus_28;
       break;
     case LIMITER_LEVEL_MINUS_30_DB:
       coefficientArray = limiter_minus_30;
       break;
     default:
       {
          ASSERT(0);
          break;
       }
   }
   SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, LIMITER_COEFFICIENT_CTRL_ADDRESS, LIMITER_COEFFICIENT_DATA_SIZE, coefficientArray);
}
/************************************************************
**************private functions******************************
*************************************************************/
static void DspDrv1761_I2cRead(cDSPDrv1761 *me, uint32 regAddr, uint16 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = regAddr,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };
    I2CDrv_MasterRead(me->i2cObj, &i2cMsg);
}

/**
 * Write data to DSP by I2C.
 *
 * @param      uint8           device I2C address
 *
 * @param      uint8           data byte number
 *
 * @param      const uint8*    pointer to data array
 *
 * @return     void
 */
static void DspDrv1761_I2cWrite(cDSPDrv1761 *me, uint8 bytes, const uint8 *data)
{
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = NULL,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };

    I2CDrv_MasterWrite(me->i2cObj, &i2cMsg);
}

static void SIGMA_WRITE_REGISTER_BLOCK(uint8 device_add, uint16 reg_add, uint16 bytes, const uint8* data)
{
    ASSERT(bytes <= MAX_TX_DATA); /* Note: the size should not more than ADAU1451_REGISTER_LEN. */
    uint8 buffer[MAX_TX_DATA];
    tI2CMsg i2cMsg=
    {
        .devAddr = device_add,
        .regAddr = NULL,
        .length = bytes+2
    };
    buffer[0]=((reg_add&0xff00)>>8);
    buffer[1]=(reg_add&0x00ff);
    memcpy(&buffer[2], data, bytes);
    i2cMsg.pMsg = &buffer[0];
    I2CDrv_MasterWrite(pDspObj->i2cObj, &i2cMsg);
}


/**
 * Safeload process
 *
 * @param      uint8                data length in word(4 bytes)
 * @param      uint8*               data array
 * @param      uint16               target address
 * @return     void
 */
static void DspDrv1761_SafeLoadData(cDSPDrv1761 *me, uint8 num, const uint8 *array, uint16 addr)
{
    uint8  temp[6] = {0};
    uint16 curr_ptr;
    uint8  currIdx, curr_cnt;
    ASSERT(me->deviceAddr);
    ASSERT((num <= SAFE_LOAD_DATA_SIZE_MAX) && (num > 0));
    /* step1: set modulo size */
    curr_ptr = SAFE_LOAD_MODULO_SIZE_ADD;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    curr_ptr++;
    currIdx = 0;
    /* step2: write safeload data */
    while(currIdx < num * 4)
    {
        temp[0] = (curr_ptr & 0xff00) >> 8;
        temp[1] = curr_ptr & 0x00ff;
        for(curr_cnt = 0; curr_cnt < 4; curr_cnt++)
        {
            temp[curr_cnt + 2] = array[currIdx];
            currIdx++;
        }
        curr_ptr++;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }

    curr_ptr = SAFE_LOAD_ADD_FOR_TARGET_ADD;
    
    /* step3: write target addr */
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[2] = 0;
    temp[3] = 0;
    temp[4] = (((addr - 1)& 0xff00) >> 8);
    temp[5] = (addr - 1) & 0x00ff;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    /* step4: trigger safeload */
    curr_ptr++;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);
}

static void DspDrv1761_SetPolarity(cDSPDrv1761 *me, ePolarityType polarityType)
{
    uint8    temp[4] = {0};
    uint8    polarityChannel[4] = {0};
    /* get addr */
    
    temp[0] = 0x00;
    temp[1] = 0x80;
    temp[2] = 0x00;
    temp[3] = 0x00;
    if(polarityType == POLARITY_NEGATIVE)
    {
        temp[0] = 0xFF;
    }
    DspDrv1761_I2cRead(me, POLARITY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&polarityChannel);
    if(polarityChannel[3] == POLARITY_CHANNEL_0)
    {
        polarityChannel[3] = POLARITY_CHANNEL_1;
        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_1_ADDRESS);
    }
    else if(polarityChannel[3] == POLARITY_CHANNEL_1)
    {
        polarityChannel[3] = POLARITY_CHANNEL_0;
        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_0_ADDRESS);
    }
    DspDrv1761_SafeLoadData(me, 1, polarityChannel, POLARITY_CHANNEL_CTRL_ADDRESS);
}


static void DspDrv1761_SetPhaseCB(void * pCbPara)
{
    uint8    delayChannel[4] = {0};

    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(isPhaseInited)
    {
        if(delayChannel[3] == DELAY_CHANNEL_0)
        {
            delayChannel[3] = DELAY_CHANNEL_1;
        }
        else if(delayChannel[3] == DELAY_CHANNEL_1)
        {
            delayChannel[3] = DELAY_CHANNEL_0;
        }
    }
    isPhaseInited = TRUE;
    DspDrv1761_SafeLoadData(pDspObj, 1, delayChannel, DELAY_CHANNEL_CTRL_ADDRESS);
    phaseTimer = INVALIDE_TIMER;
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */
static void DspDrv1761_SetPhase(cDSPDrv1761 *me, uint8 phaseShift)
{
    uint8    delayChannel[4] = {0};
    uint8    temp[4] = {0};
    uint16   tmp = 0;
    tmp = phaseShift * MAX_DELAY_SAMPLES;
    temp[0] = 0x00;
    temp[1] = 0x00;
    temp[2] = ((tmp/180)& 0xff00) >> 8;
    temp[3] = (tmp/180)& 0x00ff;
    if(phaseShift == 0)
    {
        temp[3] = NO_PHASE_SHIFT;
    }
    if(phaseTimer != INVALIDE_TIMER)
    {
        Timer_StopTimer(phaseTimer);
    }
    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(delayChannel[3] == DELAY_CHANNEL_0)
    {
        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_1_ADDRESS);
    }
    else if(delayChannel[3] == DELAY_CHANNEL_1)
    {
        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_0_ADDRESS);
    }
    Timer_StartTimer(600,&phaseTimer, DspDrv1761_SetPhaseCB, NULL);
}

static void DspDrv1761_InitSection0(void *p)
{
    cDSPDrv1761 * me = (cDSPDrv1761*)p;
    uint16 attached_device_index = 0;
    const tDevice * pDevice = NULL;
    do
    {
        pDevice = getDevicebyId(AUDIO_DEV_ID,&attached_device_index);
        attached_device_index++;
        if(I2C_DEV_TYPE == pDevice->deviceType)
        {
            break;
        }
    }while(pDevice);
    I2CDrv_Ctor(me->i2cObj,(tI2CDevice*)pDevice);
    me->i2cObj->registeredUser++;
}

static void DspDrv1761_InitSection1(void *p)
{
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R0_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R1_DSP_RUN_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLKCTRLREGISTER_IC_1_ADDR, REG_CLKCTRLREGISTER_IC_1_BYTE, R2_CLKCTRLREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLLCRLREGISTER_IC_1_ADDR, REG_PLLCRLREGISTER_IC_1_BYTE, R3_PLLCRLREGISTER_IC_1_Default );
}

static void DspDrv1761_InitSection2(void *p)
{
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_CONTROL_0_IC_1_ADDR , R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_SIZE, R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ALC_CONTROL_0_IC_1_ADDR , R6_ALC_CONTROL_REGISTERS_IC_1_SIZE, R6_ALC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_MICCTRLREGISTER_IC_1_ADDR, REG_MICCTRLREGISTER_IC_1_BYTE, R7_MICCTRLREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_RECORD_PWR_MANAGEMENT_IC_1_ADDR , R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ADC_CONTROL_0_IC_1_ADDR , R9_ADC_CONTROL_REGISTERS_IC_1_SIZE, R9_ADC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLAYBACK_MIXER_LEFT_CONTROL_0_IC_1_ADDR , R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CONVERTER_CTRL_0_IC_1_ADDR , R11_CONVERTER_CONTROL_REGISTERS_IC_1_SIZE, R11_CONVERTER_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DAC_CONTROL_0_IC_1_ADDR , R12_DAC_CONTROL_REGISTERS_IC_1_SIZE, R12_DAC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_PAD_CONTROL_0_IC_1_ADDR , R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_COMM_PORT_PAD_CTRL_0_IC_1_ADDR , R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_JACKREGISTER_IC_1_ADDR, REG_JACKREGISTER_IC_1_BYTE, R15_JACKREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_ENABLE_REGISTER_IC_1_ADDR, REG_DSP_ENABLE_REGISTER_IC_1_BYTE, R21_DSP_ENABLE_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CRC_IDEAL_1_IC_1_ADDR , R22_CRC_REGISTERS_IC_1_SIZE, R22_CRC_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_GPIO_0_CONTROL_IC_1_ADDR , R23_GPIO_REGISTERS_IC_1_SIZE, R23_GPIO_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_NON_MODULO_RAM_1_IC_1_ADDR , R24_NON_MODULO_REGISTERS_IC_1_SIZE, R24_NON_MODULO_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_WATCHDOG_ENABLE_IC_1_ADDR , R25_WATCHDOG_REGISTERS_IC_1_SIZE, R25_WATCHDOG_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R26_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_INPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_INPUTS_IC_1_BYTE, R27_ROUTING_MATRIX_INPUTS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_OUTPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_OUTPUTS_IC_1_BYTE, R28_ROUTING_MATRIX_OUTPUTS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_ADDR, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_BYTE, R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_SLEW_MODES_IC_1_ADDR, REG_DSP_SLEW_MODES_IC_1_BYTE, R30_DSP_SLEW_MODES_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_BYTE, R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLOCK_ENABLE_REG_0_IC_1_ADDR , R32_CLOCK_ENABLE_REGISTERS_IC_1_SIZE, R32_CLOCK_ENABLE_REGISTERS_IC_1_Default );
	uint16 i;
    for(i = 0; i * 5 < PROGRAM_SIZE_IC_1; i++)
    {
       SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1+i, 5, &Program_Data_IC_1[i*5] ); /* 40 bit dsp prgram ram, 64*4 = 256 bytes */
    }
    for(i = 0; i * 4 < PARAM_SIZE_IC_1; i++)
    {
        SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PARAM_ADDR_IC_1+i, 4, &Param_Data_IC_1[i*4] ); /* 32 bit dsp prgram ram */
    }
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, NON_MODULO_RAM_ADDR_IC_1, NON_MODULO_RAM_SIZE_IC_1, NON_MODULO_RAM_Data_IC_1 );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R36_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R37_DSP_RUN_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R38_DEJITTER_REGISTER_CONTROL_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R39_DEJITTER_REGISTER_CONTROL_IC_1_Default );
}


/**
 * Format input int32 data array into array of uint8, according to the designated number of int32
 *
 * @param      int32*          start address of the input int32 array
 *
 * @param      uint8*          output data array pointer
 *
 * @param      uint8           number of input int32 data
 *
 * @return     void
 */
static void DspDrv1761_FormatFiltData(int32* in, uint8* out, uint8 num)
{
    uint32        temp;
    uint8          cnt;
    int32*        ptr0;
    uint8*        ptr1;

    ptr0 = in;
    ptr1 = out;

    for(cnt = 0; cnt < num; cnt++)
    {
        temp  = (uint32)(*ptr0);
        *ptr1 = (uint8)((temp >> 24) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 16) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 8) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)(temp & 0xFF);
        ptr1++;
        ptr0++;
    }
}

/**
 * This function is used to convert filter Parameter (Q factor, center freq, etc) into 5 DSP parameters
 *
 * @param   tDspFiltRawParam                 the filter parameter raw input
 * @param   uint8*                           pointer to the output data
 * @return  void
 */
static void DspDrv1761_CalFiltParam(tDspFiltRawParam in, uint8* out)
{
    /* calculate common param for all filter */
    double w0 = 2.0*PI*in.freq/DSP_SAMPLING_FREQ;
    double A = pow(10.0, in.boost/40.0);
    double gainLinear = pow(10.0, in.gain/20.0);
    double a0, a1, a2, b0, b1, b2, S, alpha;
    int32  temp[EQ_CTRL_RAM_SLOT_NUM];

    S = in.q;
    if(in.en == FALSE)
    {
        temp[0] = 0x00800000;
        temp[1] = 0x00000000;
        temp[2] = 0x00000000;
        temp[3] = 0x00000000;
        temp[4] = 0x00000000;
        /* change the data from int32 to uint8 */
        DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
        return;
    }
    else if(in.q == 0)
    {
        S = 0.05;
    }

    switch(in.dspFiltType)
    {
#ifdef HAS_PEAKING_FILTER
        case FILTER_TYPE_PEAKING:
        {
            alpha = sin(w0) / (2.0 * S);

            a0 = 1.0 + alpha / A;
            a1 = -2.0 * cos(w0);
            a2 = 1.0 - alpha / A;
            b0 = (1.0 + alpha * A) * gainLinear;
            b1 = - ( 2.0 * cos(w0)) * gainLinear;
            b2 = ( 1.0 - A * alpha) * gainLinear;
            
            /*  speical behavior when speical inputs
             *  (inspired by Sigma Studio outputs)
             * */
            if(in.boost == 0.00)
            {
                b1=0;
                b2=0;
                a1=0;
                a2=0;
            }
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_LOW_SHELF_FILTER
        case FILTER_TYPE_TONE_LOW_SHELF:
        {
            alpha = (sin(w0)/ 2 ) * sqrt( ( A + 1/A ) * ( 1 / S - 1) + 2);
            a0 = (A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 =  -2*( (A-1) + (A+1)*cos(w0) );
            a2 = (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha;
            b0 =  A*( (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha ) * gainLinear;
            b1 = 2*A*( (A-1) - (A+1)*cos(w0) ) * gainLinear;
            b2 =  A*( (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha ) * gainLinear;
            
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_HIGH_SHELF_FILTER
        case FILTER_TYPE_TONE_HIGH_SHELF:
        {
            alpha = (sin(w0)/2)*sqrt((A+1/A)*(1/S-1)+2);
            a0 = (A+1)-(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 = 2*((A-1)-(A+1)*cos(w0));
            a2 = (A+1)-(A-1)*cos(w0)-2*sqrt(A)*alpha;
            b0 = A*((A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha)*gainLinear;
            b1 = -2*A*((A-1)+(A+1)*cos(w0))*gainLinear;
            b2 = A*((A+1)+(A-1)*cos(w0)-2*sqrt(A)*alpha)*gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_LOW_PASS_FILTER
        case FILTER_TYPE_GENERAL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = (1-cos(w0))*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_HIGH_PASS_FILTER
        case FILTER_TYPE_GENERAL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_LOW_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_LOW_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_HIGH_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_HIGH_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2.0*cos(w0);
            a2 = 1.0-alpha;
            b0 = (1.0+cos(w0))*gainLinear/2.0;
            b1 = -(1.0+cos(w0))*gainLinear;
            b2 = (1.0+cos(w0))*gainLinear/2.0;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_LOW_PASS_FILTER
        case FILTER_TYPE_BESSEL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_HIGH_PASS_FILTER
        case FILTER_TYPE_BESSEL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_LOW_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_LOW_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * (1.0 - a1);
            b1 = 0;
            b2 = 0;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_HIGH_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_HIGH_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * a1;
            b1 = 0 - b0;
            b2 = 0;
        }
        break;
#endif
        default:
        {
            /* wrong data in */
            ASSERT(0);
        }
        break;
    }

    /* check data */
    ASSERT((a1 > -16.0) && (a1 < 15.99));
    ASSERT((a2 > -16.0) && (a2 < 15.99));
    ASSERT((b0 > -16.0) && (b0 < 15.99));
    ASSERT((b1 > -16.0) && (b1 < 15.99));
    ASSERT((b2 > -16.0) && (b2 < 15.99));

    /* feed into output structure */
    temp[0] = (int32)(b0*(1L << 23));
    temp[1] = (int32)(b1*(1L << 23));
    temp[2] = (int32)(b2*(1L << 23));
    temp[3] = (int32)(a1*(1L << 23));
    temp[4] = (int32)(a2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}

/**
 * Set BGC
 *
 * @param      int8            boost
 * @param      bool            enable or disable
 * @return     void
 */
static void DspDrv1761_SetRGC(cDSPDrv1761 *me, uint16 freq, eUserRGCSlope slope, bool en)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8             currIdx;
    uint32            regAddress = RGC_CTRL_ADDRESS;

    rawData.freq        = freq;
    rawData.boost       = RGC_BOOST;
    rawData.gain        = RGC_GAIN;
    rawData.q           = RGC_QFACTOR;
    rawData.en          = en;
    rawData.dspFiltType = FILTER_TYPE_BUTTWORTH_HIGH_PASS;

    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);
        /* check slope */
    switch(slope)
    {
        case USER_RGC_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_RGC_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        default:
            ASSERT(0);
            break;
    }

    uint8 i = 0;
    for(i = 0; i < NUM_OF_RGC_SET_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me,EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }
        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}


static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out)
{
    double w,G1,a11,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];
    
    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    G1 = w/(w+1);
    a11 = (w-1)/(w+1);
    
    B0 = G1;
    B1 = G1;
    B2 = 0;
    A1 = -a11;
    A2 = 0;
    
    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}


static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out)
{
    double w,G2,a21,a22,alpha,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];
    
    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    alpha = (1 - 2*w*delta + w*w);
    G2 = w*w / alpha;
    a21 = -(2 * (w*w - 1) / alpha);
    a22 = -((1 + 2*w*delta + w*w) / alpha);

    B0 = G2;
    B1 = 2*G2;
    B2 = G2;
    A1 = a21;
    A2 = a22;
    
    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}

/**
 * Set User LP
 *
 * @param      int8            boost
 * @param      eUserLpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserLp(cDSPDrv1761 *me, uint16 freq, eUserLpSlope slope, bool en)
{
    double delta2 = cos(3*PI/4);
    double delta3 = cos(4*PI/6);
    double delta4_1 = cos(5*PI/8);
    double delta4_2 = cos(7*PI/8);
    double delta = 0;
    uint8 finalData[EQ_CTRL_RAM_BYTE_NUM];
    int32 bypassData[5];
    bypassData[0] = 0x00800000;
    bypassData[1] = 0x00000000;
    bypassData[2] = 0x00000000;
    bypassData[3] = 0x00000000;
    bypassData[4] = 0x00000000;
    memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
    if(en)
    {
        finalData[3] = 0x01;
        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
    }
    else
    {
        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
        return;
    }
    /* check slope */
    switch(slope)
    {
        case USER_LP_SLOPE_6DB:
            
            DspDrv1761_CalculateFirstOrder(me,freq,finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_12DB:
            delta = delta2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_18DB:
            delta = delta3;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_CalculateFirstOrder(me,freq,finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_24DB:
            delta = delta4_1;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            delta = delta4_2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, 5, finalData, LP_CTRL_ADDRESS+5);
            break;
        default:
            ASSERT(0);
            break;
    }
}

/**
 * Set User HP
 *
 * @param      int8            boost
 * @param      eUserHpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserHp(cDSPDrv1761 *me, uint16 freq, eUserHpSlope slope, bool en)
{
    tDspFiltRawParam     rawData;
    uint8                finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8                currIdx;
    uint32               regAddress = HP_CTRL_ADDRESS;

    rawData.freq         = freq;
    rawData.boost        = USER_HP_BOOST;
    rawData.gain         = USER_HP_GAIN;
    rawData.q            = USER_HP_QFACTOR;
    rawData.en           = en;
    rawData.dspFiltType  = FILTER_TYPE_FIRST_ORDER_HIGH_PASS;


    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_HP_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_HP_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        case USER_HP_SLOPE_18DB:
            currIdx = CTR_ADDR_GROUP_3;
            break;

        case USER_HP_SLOPE_24DB:
            currIdx = CTR_ADDR_GROUP_4;
            break;

        default:
            ASSERT(0);
            break;
    }
    ASSERT(currIdx < EQ_CTRL_NUM);
    uint8 i = 0;
    for(i = 0; i < NUM_OF_FILTER_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }
        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}

/**
 * Set Tuning
 *
 * @param      eTuningRange           range
 * @return     void
 */
static void DspDrv1761_SetTuning(cDSPDrv1761 *me, eTuningRange range)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];

    rawData.freq      = TUNING_FREQ;
    rawData.gain      = TUNING_GAIN;
    rawData.q         = TUNING_QFACTOR;
    rawData.dspFiltType = FILTER_TYPE_BUTTWORTH_HIGH_PASS;

    /* check range */
    switch(range)
    {
        case TUNING_RANGE_20HZ:
            rawData.boost = TUNING_BOOST0;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_16HZ:
            rawData.boost = TUNING_BOOST1;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_SEALED:
            rawData.en    = FALSE;
            break;

        default:
            ASSERT(0);
            break;
    }

    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);
    DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, TUNNING_ADDRESS);
}

/**
 * Set PEQ
 *
 * @param      eDspSettId       dsp setting ID
 * @param      uint8            the setting position in ctrIdEQIdMap
 * @param      enable           Enable or disable the settings
 */
static void DspDrv1761_SetPeq(cDSPDrv1761 *me, eAudioSettId dspSettId,uint8 settIndex, BOOL enable)
{
    tDspFiltRawParam rawData;
    uint8            finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8            currIdx;
    uint32           regAddress = PEQ_CTRL_ADDRESS;

    rawData.gain  = PARAM_EQ_GAIN;
    rawData.freq = (pSettData[ctrIdEQIdMap[settIndex].dbIndex])/VALUE_MAGNIFICATION;
    rawData.boost = ((double)(pSettData[ctrIdEQIdMap[settIndex].dbIndex+1]))/VALUE_MAGNIFICATION;;
    rawData.q = (pSettData[ctrIdEQIdMap[settIndex].dbIndex+2])/VALUE_MAGNIFICATION;;
    rawData.en = enable;
    rawData.dspFiltType = FILTER_TYPE_PEAKING;

    DspDrv1761_CalFiltParam(rawData, finalData);

    switch(dspSettId)
    {
        case DSP_EQ_CTRL_PEQ1:
          {
            currIdx = ADDR_OFFSET_0;
          }
            break;
        case DSP_EQ_CTRL_PEQ2:
          {
            currIdx = ADDR_OFFSET_1;
          }
            break;

        case DSP_EQ_CTRL_PEQ3:
          {
            currIdx = ADDR_OFFSET_2;
          }
            break;

        default:
            ASSERT(0);
            break;
    }
    ASSERT(currIdx < EQ_CTRL_NUM);
    uint8 i = 0;
    while(i < PARAMETRIC_EQ_MAX)
    {
      if(i == currIdx)
      {
          /* Set the right parametric EQ */
          DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
      }
      regAddress += EQ_CTRL_RAM_SLOT_NUM;
      i++;
    }
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */

/* 
 * Below are the public functions which are not used in SVS but have to
 * be declared to supress compiling errors
 */

BOOL DSPDrv1761_IsAuxin(cDSPDrv1761 *me)                                                                                                                                                                                                                                                                                                              
{
    return FALSE;
}

BOOL DSPDrv1761_HasMusicStream(cDSPDrv1761 *me)
{
    BOOL   ret = FALSE;
    uint8  readDataFromDsp[ADAU1761_AUDIO_DETECT_LEN + 1] = {0};
    uint32 readValue = 0;

    /* read audio detection */
    DspDrv1761_I2cRead(me, MUSIC_STREAM_STATUS_ADDRESS, ADAU1761_AUDIO_DETECT_LEN, (uint8*)&readDataFromDsp);
    readValue = (readDataFromDsp[2] << 8) | readDataFromDsp[3];
    if (readValue > MUSIC_DETECTED_THRESHOLD)
    {
        ret = TRUE;
    }
    return ret;
}

void DSPDrv1761_SetInputChannel(cDSPDrv1761 *me, eAudioChannel inputChannel)
{
  
}


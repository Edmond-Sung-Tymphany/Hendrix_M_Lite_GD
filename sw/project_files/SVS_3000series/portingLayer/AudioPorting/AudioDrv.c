/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document

@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AdcDrv.h"
#include "I2CDrv.h"
#include "GPIODrv.h"
#include "DspDrv1761.h"
#include "AudioDrv.config"
#include "timer.h"

/***********************************************
 * Definition
 ***********************************************/
//#define AUDIO_DRV_TEMP_DEBUG
#define AUDIO_DRV_ENABLE_OVERHEAT_PROTECTION



/***********************************************
 * Type
 ***********************************************/


/***********************************************
 * Extern Function
 ***********************************************/


/***********************************************
 * Global Variable
 ***********************************************/
static cI2CDrv      dspI2cObj;
static cDSPDrv1761 DspADAU1761Drv;

#ifdef AUDIO_DRV_TEMP_DEBUG
int32 dbgTempIncr= 20;  //when init audio drv, init temp +40C.
int32 dbgDiff= 1;
#endif

static cGpioDrv gpioAudio;

static bool audioOverheat = FALSE;

cADCDrv adcAudio;

static int32 musicDetTimer;
static int32 jackDetTimer;
static int32 tempMonTimer;

static uint16 volFadeTimerId= 0;
static tVolFadeParam volFadeParam= {0};

/* Record requester id for volume fading request */
static uint32 requester_id = 0;

/***********************************************
 * Temperature of Amplifier
 ***********************************************/
typedef struct
{
    uint32  adcValue;
    eAmpTempLevel level;
}tAmpTemp;


/*  Calculate: voltage = 3.3V * (R /(R+2.2K)), AdcValue= (4096/3.3) * voltage
 *  Example: 80'C, R = 1.669
 *           voltage = 3.3 * (1.669/ (1.669 + 2.2)) = 1.423V
 *           AdcValue = (4096/3.3) * 1.423 = 1766.923
*/
const static tAmpTemp ampTempArray[] =
{
    {1149,  AMP_TL_CRITICAL  },  // 105'C
    {1257,  AMP_TL_WARN_5    },  // 100'C
    {1373,  AMP_TL_WARN_4    },  // 95'C
    {1498,  AMP_TL_WARN_3    },  // 90'C
    {1610,  AMP_TL_WARN_2    },  // 85'C
    {1767,  AMP_TL_WARN_1    },  // 80'C
    {-1,    AMP_TL_NORMAL    },  // 3.3
};
/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds,
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);
    audioOverheat = FALSE;

    //Initialize Audio GPIO pins
    gpioAudio.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(gpioAudio.gpioConfig);
    GpioDrv_Ctor(&gpioAudio, gpioAudio.gpioConfig);

    //Initialize Audio ADC pins
    adcAudio.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(adcAudio.ADCConfig);
    ADCDrv_Ctor(&adcAudio, adcAudio.ADCConfig);

    //Initialize DSP
    dspI2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cObj.pConfig);
    DSPDrv1761_Ctor(&DspADAU1761Drv, &dspI2cObj);

    //Shutdown all amplifier
    AMP_MUTE(gpioAudio);
    AMP_WAKEUP(gpioAudio); //latch the power of amplifier, charge the amplifier to stable
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    DSPDrv1761_Xtor(&DspADAU1761Drv);

    //Shutdown all amplifier
    AMP_MUTE(gpioAudio);
    AMP_SHUTDOWN(gpioAudio); //pull low SDZ

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {
        if(me->nextDelayTime == 0)
        {
            //1st step
        }

        //2nd-Nst step
        me->nextDelayTime = DSPDrv1761_Init(&DspADAU1761Drv);

        //Last step
        if(me->nextDelayTime == 0)
        {
            /* unmute after I2C programming */
            //AMP_UNMUTE(gpioAudio);
            AMP_WAKEUP(gpioAudio);

            /* Set default settings */
            jackDetTimer = AUDIO_ACTIVE_AUXIN_JACK_DET_TIME;
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;

            memset(&volFadeParam, 0, sizeof(volFadeParam));
            volFadeParam.isFadingInProg = FALSE;

            DSPDrv1761_SetAudio(&DspADAU1761Drv, DSP_VOLUME_SETT_ID, TRUE);

            /* Set to NORMAL temp level, to make sure boot threshold is 76, not 73
             */
            eTempLevel tempLevel= AMP_TL_NORMAL;
            Setting_Set(SETID_AMP_TEMP_LEVEL, &tempLevel);

            /* Update temp and level, to let MainApp check overheat on boot up
             */
            tempMonTimer = AUDIO_SRV_TIMEOUT_IN_MS; //trigger temp monitor now
            musicDetTimer = AUDIO_SRV_TIMEOUT_IN_MS;
            jackDetTimer = AUDIO_SRV_TIMEOUT_IN_MS;
            AudioDrv_TempMonitor();

            //Finish
            me->drvIsReady = TRUE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    return TRUE;
}


void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}


/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
//    DSPDrv1761_SetInputChannel(&DspADAU1761Drv, audioChannel);
}

void AudioDrv_SetLineInMultiRoomChannel(eAudioChannel audioChannel)
{
//    DSPDrv1451_SetLineInMultiRoomChannel(&DspADAU1451Drv, audioChannel);
}



void AudioDrv_UpdateStatus(cAudioDrv *audioDrvObj)
{
    AudioDrv_TempMonitor();
    AudioDrv_CheckJackInStatus();
    AudioDrv_CheckMusicStreamStatus();
}


/* When jack in:
 *   1 unmute auxin input, MCU may detect auxin signel, and let ASE trigger source change
 *   2 DSP wakeup to detect auxin signal
 * 
 * When jack not appear:
 *   1 mute auxin input
 *   2 dsp sleep when no audio output
 */
void AudioDrv_CheckJackInStatus(void)
{

}


/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    bool prevStatus, currentStatus;
    static uint8 statusCount = 0;

    if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
    {
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;

        currentStatus =DSPDrv1761_HasMusicStream(&DspADAU1761Drv);
        prevStatus = *(bool*)Setting_Get(SETID_MUSIC_DET);

        if(currentStatus != prevStatus)
        {
            statusCount++;
            if(statusCount >= AUDIO_HAS_MUSIC_TIMES)
            {
                statusCount = 0;
                Setting_Set(SETID_MUSIC_DET, &currentStatus);

                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = currentStatus;
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
            }
        }
        else
        {
            statusCount = 0;
        }
    }
}


static void AudioDrv_StopFadeVolume()
{
//    if (volFadeParam.isFadingInProg == TRUE)
//    {
//        TP_PRINTF("Volume fade: Stop volume fading and reply ASE (red_id=%d)\r\n", requester_id);
//        //AseNgSrv_ReplyVolumeFade(requester_id, TRUE);
//        bool ret= Timer_StopTimer(volFadeTimerId);
//        ASSERT(ret); //FALSE means Fade volume timer is not running
//        volFadeParam.isFadingInProg = FALSE;
//        requester_id = 0;
//    }
}


static void AudioDrv_SetFadeVolume(cAudioDrv *me, uint32 target_volume, uint32 fade_duration)
{
//    /* The start volume should always be equal to current volume. */
//    uint8 start_volume = *(uint8*)Setting_Get(SETID_VOLUME);
//    uint32 fadeRange = TYM_DIFF(target_volume, start_volume);
//
//    /* fade_duration should not be less than ADUIO_MIN_FADE_STEP_TIME */
//    if(fade_duration < ADUIO_MIN_FADE_STEP_TIME)
//    {
//        fade_duration= ADUIO_MIN_FADE_STEP_TIME;
//    }

//    if(((fadeRange <= (MAX_VOLUME - MIN_VOLUME)) && fadeRange > 0)
//        && (target_volume >= MIN_VOLUME && target_volume <= MAX_VOLUME)
//        && (start_volume >= MIN_VOLUME && start_volume <= MAX_VOLUME))
//    {
//        volFadeParam.fadeType     = (target_volume > start_volume)? TRUE : FALSE;
//        volFadeParam.fadeStep     = ADUIO_MIN_FADE_STEP;
//        volFadeParam.fadeStepTime = (fade_duration * volFadeParam.fadeStep)/fadeRange;
//        volFadeParam.targetVol    = target_volume;
//        volFadeParam.isFadingInProg = TRUE;
//        if(ADUIO_MIN_FADE_STEP_TIME > volFadeParam.fadeStepTime)
//        {
//            volFadeParam.fadeStepTime = ADUIO_MIN_FADE_STEP_TIME;
//            volFadeParam.fadeStep = (volFadeParam.fadeStepTime * fadeRange)/fade_duration;
//            ASSERT(volFadeParam.fadeStep>0);
//        }
//        Timer_StartTimer((uint32)volFadeParam.fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, &volFadeParam);
//    }
//    else
//    {
//        TP_PRINTF("The volume fade parameters are invalid. \r\n");
//        //TODO: reply FAIL to ASE
//    }

}

static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
//    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
//    /* get current volume value */
//    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);

//    //printf("AudioDrv_VolFadeTimerCallBack: fadeType=%d, step=%d, vol:(curr=%d,tgt=%d) \r\n",
//    //           pVolFadeParam->fadeType, pVolFadeParam->fadeStep, volLevel, pVolFadeParam->targetVol);

//    ASSERT(pVolFadeParam->isFadingInProg==TRUE);

//    /* For issue FS-202, sometimes AudioDrv_VolFadeTimerCallBack() repeated execute and set the same volume.
//     * The only possible condition is fadeStep==0, but there is no reason for it.
//     * Before find root cause, we add workaround here.
//     */
//    if(pVolFadeParam->fadeStep==0)
//    {
//        ASSERT(0);
//        TP_PRINTF("\r\n\r\n\r\n*** ERROR: AudioDrv_VolFadeTimerCallBack fadeStep==0 ***\r\n\r\n\r\n\r\n");
//        return;
//    }

//    /* change volume*/
//    if(pVolFadeParam->fadeType)
//    {
//        /* volume fade up*/
//        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
//        {
//            volLevel = pVolFadeParam->targetVol;
//        }
//        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
//        {
//            volLevel = MAX_VOLUME;
//        }
//        else
//        {
//            volLevel += pVolFadeParam->fadeStep;
//        }
//    }
//    else
//    {
//        /* volume fade down*/
//        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
//        {
//            volLevel = pVolFadeParam->targetVol;
//        }
//        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
//        {
//            volLevel = MIN_VOLUME;
//        }
//        else
//        {
//            volLevel -= pVolFadeParam->fadeStep;
//        }
//    }
//    Setting_Set(SETID_VOLUME, &volLevel);
//    AudioDrv_DspVolSetId_Handler();

//    if((volLevel != pVolFadeParam->targetVol)
//        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
//    {
//        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
//    }
//    else
//    {
//        /* Reply Ase-tk when volume fade completed. */
//        AudioDrv_StopFadeVolume();
//        TP_PRINTF("Volume fade: finish, vol=%d, req_id=%d\r\n", volLevel, requester_id);
//    }
}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady))
    {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch(audioSettId)
    {
        case AMP_SLEEP_MODE_ID:
        {
            TP_PRINTF("AMP_SLEEP_MODE_ID=%d\r\n",enabled);
            if(enabled)
            {
                AMP_SHUTDOWN(gpioAudio); //pull low SDZ
                DSPDrv1761_RunDSP(&DspADAU1761Drv, FALSE);
            }
            else
            {
                AMP_WAKEUP(gpioAudio); //pull HIGH SDZ
                DSPDrv1761_RunDSP(&DspADAU1761Drv, TRUE);
            }
            break;
        }
        case AUDIO_OVERHEAT_MODE_ID:
        {
            AudioDrv_SetOverheat(me, TRUE);
            break;
        }
        case AUDIO_VOL_FADE_SETT_ID:
        {
            break;
        }
        case DSP_PASSTHROUGH_SETT_ID:
        {
            TP_PRINTF("EQ_BYPASS=%d\r\n",enabled);
            DSPDrv1761_EQBypass(&DspADAU1761Drv, enabled);
            break;
        }
        default:
        {
            DSPDrv1761_SetAudio(&DspADAU1761Drv, audioSettId, enabled);
            break;
        }

}



//    switch (audioSettId)
//    {
//        case DSP_VOLUME_SETT_ID:
//        {
//            AudioDrv_StopFadeVolume();
//            uint8 volume= (uint8)param;
//            Setting_Set(SETID_VOLUME, &volume);
//            AudioDrv_DspVolSetId_Handler();
//            break;
//        }
//        case DSP_EQ_CTRL_RGC:
//        {
//
//            break;
//        }
//        case DSP_EQ_CTRL_USER_LP:
//        {

//            break;
//        }
//        case DSP_EQ_CTRL_USER_HP:
//        {

//            break;
//        }
//        case DSP_EQ_CTRL_PEQ1:
//        case DSP_EQ_CTRL_PEQ2:
//        case DSP_EQ_CTRL_PEQ3:
//        {
//
//            break;
//        }
//        case DSP_PHASE_SETT_ID:
//        {

//            break;
//        }
//        case DSP_POLARITY_SETT_ID:
//        {

//            break;
//        }
//        case DSP_TUNNING_SETT_ID:
//        {
//            /* In DSP tuning mode, always power on and unmute amplifier */
//            TP_PRINTF("DSP-TUNNING = %d\r\n", enabled);
//            if (enabled)
//            {
//                AMP_WAKEUP(gpioAudio);
//                AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, FALSE);
//                AudioDrv_SetChannel(AUDIO_CHANNEL_I2S_2); // auxin
//            }
//            /* DSP and AMP I2C bus should be disable when tuning DSP. */
//            DSPDrv1761_I2cEnable(&DspADAU1761Drv, !enabled);
//            break;
//        }

//        case AMP_SLEEP_MODE_ID:
//        {
//            if(!audioOverheat)
//            {
//                //TP_PRINTF("amp shutdown=%d\r\n", enabled);
//                if (enabled)
//                {
//                    AMP_SHUTDOWN(gpioAudio);
//                }
//                else
//                {
//                    AMP_WAKEUP(gpioAudio);
//                }
//            }
//            break;
//        }
//        case AUDIO_OVERHEAT_MODE_ID:
//        {
//            AudioDrv_SetOverheat(me, enabled);
//            break;
//        }
//
//        case AUDIO_VOL_FADE_SETT_ID:
//        {  /* param ( vv:ffffff    8 bits volume : 24 bits fade duration )
//              param2 request id */
//            uint32 target_volume= param >> 24;
//            requester_id = param2;
//            uint32 fade_duration= param & 0xFFFFFF;
//            AudioDrv_StopFadeVolume();
//            AudioDrv_SetFadeVolume(me, target_volume, fade_duration);
//            break;
//        }
//        default:
//             break;
//    }
}


/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    ASSERT(muteType < AUDIO_MUTE_TYPE_MAX);
    switch (muteType)
    {
        case AUDIO_DSP_DACOUT_MUTE:
        {
            TP_PRINTF("dsp mute=%d\r\n", muteEnable);
            DSPDrv1761_Mute(&DspADAU1761Drv, AUDIO_DSP_DACOUT_MUTE, muteEnable);
            break;
        }
        case AUDIO_AMP_MUTE:
        {
            TP_PRINTF("amp mute=%d\r\n", muteEnable);
            if(muteEnable)
            {
                AMP_MUTE(gpioAudio);
            }
            else
            {
                AMP_UNMUTE(gpioAudio);
            }
            break;
        }
        default:
            break;
    }
}

static uint16 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint8 degreeC = 0;

//    for (degreeC = 0; degreeC < TEMPERATURE_POSITIONS_NUM; degreeC++)
//    {
//        if (ntcValue > audioNtcTempTable[degreeC])
//        {
//            break;
//        }
//    }
    return degreeC;
}

static void AudioDrv_SetOverheat(cAudioDrv *me, bool overheat)
{
    /* audioOverheat occurs: Shutdown ampliifer for over-heat
     * recover from audioOverheat: do nothing, but allow MainApp to wakeup amplifier
     */
    TP_PRINTF("AudioDrv_SetOverheat: overheat=%d\r\n", overheat);
    audioOverheat = overheat;

    if(overheat)
    {
        AMP_SHUTDOWN(gpioAudio);
    }
    else
    {
        AMP_WAKEUP(gpioAudio);
    }
}


void AudioDrv_UpdateTempLevel(int16 tempNew, int16 tempOld, eTempLevel *pLevel, const sRange *levels, uint32 numLevel)
{
    eTempLevel tempLevelNew;
    int16 i;

    //config check
    ASSERT( numLevel==TL_NUM );

    if( tempOld < tempNew  ) //raise curve
    {
        //Check if new curve cross over "lower bound"
        for (i = 0; i < numLevel; i++)
        {
            if ( tempOld<=levels[i].lower && levels[i].lower<=tempNew  )
            {
                tempLevelNew= (eTempLevel)i;
                break;
            }
        }
        //Do not cross over, keep previous level
        if(i >= numLevel)
        {
            tempLevelNew= *pLevel;
        }
    }
    else //down curve (include equal)
    {
        //Check if new curve cross over "upper bound"
        for (i = numLevel-1; i >=0; i--)
        {
            if ( tempOld>=levels[i].upper && levels[i].upper >= tempNew )
            {
                tempLevelNew= (eTempLevel)i;
                break;
            }
        }
        //Do not cross over, keep previous level
        if(i < 0)
        {
            tempLevelNew= *pLevel;
        }
    }

    /* When boot up, temperature leavel may not mapping to temperature
     * For this case, the above for-loop can not assign level, thus we assign here
     */
    if(tempNew<=levels[TL_NORMAL].upper)
    {
        tempLevelNew= TL_NORMAL;
    }
    if(tempNew>=levels[TL_CRITICAL].lower)
    {
        tempLevelNew= TL_CRITICAL;
    }
    ASSERT(tempLevelNew<TL_NUM);

    //Store result
    *pLevel= tempLevelNew;
}


/**
 * Function to update amplifier temperature.
 */
static void AudioDrv_TempMonitor()
{
    int8 i;
    int8 currentTempLevel;
    int8 prevTempLevel;
    uint32 adcValue;

    if((tempMonTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
    {
        tempMonTimer = AUDIO_AMP_TEMP_CHECK_TIME;

        adcValue = ADCDrv_GetData(&adcAudio, ADC_AMP_OTP);
        //TP_PRINTF("level=%d\r\n", adcValue);
        for(i = 0; i < ArraySize(ampTempArray); i++)
        {
            if(adcValue <= ampTempArray[i].adcValue)
            {
                currentTempLevel = ampTempArray[i].level;
                prevTempLevel = *(int8*)Setting_Get(SETID_AMP_TEMP_LEVEL);

                if(currentTempLevel != prevTempLevel)
                {
                    //TP_PRINTF("update from %d to %d\r\n", prevTempLevel, currentTempLevel);
                    Setting_Set(SETID_AMP_TEMP_LEVEL, (void*)&currentTempLevel);

                    if(AMP_TL_CRITICAL == currentTempLevel)
                    {
                        AMP_MUTE(gpioAudio);
                    }
                    else
                    {
                        AMP_UNMUTE(gpioAudio);
                        DspDrv1761_SetLimiter(&DspADAU1761Drv, currentTempLevel);
                    }
                }

                break;
            }
        }
    }
}


static void AudioDrv_DspVolSetId_Handler(void)
{
//    uint8 volumeLevel = MIN_VOLUME;

//    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);
//    if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
//    {
//          DSPDrv1761_SetAudio(&DspADAU1761Drv, DSP_VOLUME_SETT_ID, TRUE);
//    }
//    else
//    {
//        ASSERT(0);
//    }
}



void AudioDrv_CaptureAnalogData()
{

}


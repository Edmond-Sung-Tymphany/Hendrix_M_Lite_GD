/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  dsp 1761 driver
                  -------------------------

                  SW Module Document




@file        dsp_adau1761_driver.c
@brief       This file implements the drivers for adau1761
@author      Jerry Guo,Edmond Sung, Bob.Xu
@date        2014-08-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-17     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :

Change History:
VERSION    : 2    DRAFT      2014-09-28     Daniel.Duan, Bob.Xu
DESCRIPTION: Refactor audio sever, to add BT tone support
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include <stdio.h>
#include <math.h>
#include "trace.h"
#include "cplus.h"
#include "commonTypes.h"
#include "I2CDrv.h"
#include "SettingSrv.h"
#include "GPIODrv.h"
#include "timer.h"
#include "DspDrv1761.h"
#include "dspAdau1761Drv_priv.h"
#include "attachedDevices.h"
#include "dspAdau1761Drv_IC_1.h"
#include "dspAdau1761Drv_IC_1_PARAM.h"
#include "dspAdau1761Drv_IC_1_REG.h"


#ifndef NULL
#define NULL                             (0)
#endif


#define DspDrv1761_DEBUG_ENABLE
#ifndef DspDrv1761_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif

static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out);
static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out);

static cDSPDrv1761 *pDspObj = NULL;
static int16 *pMenuData;
static BOOL          isPhaseInited = FALSE;
static uint16 phaseTimer = INVALIDE_TIMER;
static uint16 prev_volume;

const static tDspInitSection DspInitSection[]=
{
    {&DspDrv1761_InitSection0, 50},
    {&DspDrv1761_InitSection1, 100},
    {&DspDrv1761_InitSection2, 50},
};


const static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
   /* DSP setting ID  index of setting db*/
   {DSP_EQ_CTRL_USER_LP,    DB_INDEX_OF_LP     },
   {DSP_EQ_CTRL_RGC,        DB_INDEX_OF_RGC    },
   {DSP_EQ_CTRL_PEQ1,       DB_INDEX_OF_PEQ1   },
   {DSP_EQ_CTRL_PEQ2,       DB_INDEX_OF_PEQ2   },
   {DSP_EQ_CTRL_PEQ3,       DB_INDEX_OF_PEQ3   },
   {DSP_PHASE_SETT_ID,      DB_INDEX_OF_PHASE  },
   {DSP_VOLUME_SETT_ID,     DB_INDEX_OF_VOL    },
   {DSP_POLARITY_SETT_ID,   DB_INDEX_OF_POLARITY},
   {DSP_EQ_CTRL_TUNING,     DB_INDEX_OF_TUNNING }
};


void DSPDrv1761_Ctor(cDSPDrv1761 * me, cI2CDrv *pI2cObj)
{
    me->i2cObj        = pI2cObj;
    me->pInitTable    = DspInitSection;
    me->sectionSize   = ArraySize(DspInitSection);
    me->initPhase     = 0;
    me->max_vol       = MAX_VOLUME;
    me->default_vol   = DEFAULT_VOLUME;
    me->isCreated     = TRUE;
    me->deviceAddr    = pI2cObj->pConfig->devAddress;
#ifdef HAS_DSP_TUNING_MODE
    me->i2cEnable     = FALSE;
#else
    me->i2cEnable     = TRUE;
#endif

    pMenuData         = (int16*)Setting_Get(SETID_MENU_DATA);
    pDspObj           = me;
}


void DSPDrv1761_Xtor(cDSPDrv1761 * me)
{
    I2CDrv_Xtor(me->i2cObj);
    
    me->pInitTable    = NULL;
    me->sectionSize   = 0;
    me->initPhase     = 0;
    me->isCreated     = FALSE;
    me->i2cEnable     = FALSE;
}


uint16 DSPDrv1761_Init(cDSPDrv1761 * me)
{
    uint16 delaytime;
    ASSERT(me);

    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
        return 0;
    }

    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    
    return (delaytime);
}

/************************************************************
**************private functions******************************
*************************************************************/
static void DspDrv1761_I2cRead(cDSPDrv1761 *me, uint32 regAddr, uint16 bytes, const uint8 *data)
{
    if(!me->i2cEnable)
    {
        return;
    }

    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = regAddr,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };

    I2CDrv_MasterRead(me->i2cObj, &i2cMsg);
}

/**
 * Write data to DSP by I2C.
 *
 * @param      uint8           device I2C address
 *
 * @param      uint8           data byte number
 *
 * @param      const uint8*    pointer to data array
 *
 * @return     void
 */
static void DspDrv1761_I2cWrite(cDSPDrv1761 *me, uint8 bytes, const uint8 *data)
{
    if(!me->i2cEnable)
    {
        return;
    }

    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = NULL,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };

    bool ret= I2CDrv_MasterWrite(me->i2cObj, &i2cMsg);
    ASSERT(ret == TP_SUCCESS);
}

static void DSPDrv1761_Writer_Register(cDSPDrv1761* me, uint32 regAddr, uint16 size, const uint8 *pData)
{
    uint8 buffer[2+ADAU1761_MAX_TX_BYTES];
    ASSERT(size<=ADAU1761_MAX_TX_BYTES); /* Note: the size should not more than ADAU1451_REGISTER_LEN. */

    buffer[0]=(regAddr>>8);
    buffer[1]=(regAddr&0xff);
    memcpy(&buffer[2], pData, size);
    DspDrv1761_I2cWrite(me, (2+size), (uint8*)buffer);
}

/**
 * Safeload process
 *
 * @param      uint8                data length in word(4 bytes)
 * @param      uint8*               data array
 * @param      uint16               target address
 * @return     void
 */
static void DspDrv1761_SafeLoadData(cDSPDrv1761 *me, uint8 num, const uint8 *array, uint16 addr)
{
    uint8  temp[6] = {0};
    uint16 curr_ptr;
    uint8  currIdx, curr_cnt;

    ASSERT(me->deviceAddr);
    ASSERT((num <= SAFE_LOAD_DATA_SIZE_MAX) && (num > 0));

    /* step1: set modulo size */
    curr_ptr = SAFE_LOAD_MODULO_SIZE_ADD;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = (curr_ptr & 0x00ff);
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    curr_ptr++;
    currIdx = 0;
    /* step2: write safeload data */
    while(currIdx < num * 4)
    {
        temp[0] = (curr_ptr & 0xff00) >> 8;
        temp[1] = (curr_ptr & 0x00ff);
        for(curr_cnt = 0; curr_cnt < 4; curr_cnt++)
        {
            temp[curr_cnt + 2] = array[currIdx];
            currIdx++;
        }
        curr_ptr++;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }

    curr_ptr = SAFE_LOAD_ADD_FOR_TARGET_ADD;

    /* step3: write target addr */
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = (curr_ptr & 0x00ff);
    temp[2] = 0;
    temp[3] = 0;
    temp[4] = (((addr - 1)& 0xff00) >> 8);
    temp[5] = (addr - 1) & 0x00ff;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    /* step4: trigger safeload */
    curr_ptr++;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = (curr_ptr & 0x00ff);
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);
}


void DSPDrv1761_SetAudio(cDSPDrv1761 *me, eAudioSettId dspSettId, BOOL enable)
{
    uint8 i;
    uint8 index = 0;

    /* validate*/
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
        {
            index =  ctrIdEQIdMap[i].dbIndex;
            break;
        }
    }

    ASSERT(dspSettId < DSP_SETT_ID_MAX);

    switch(dspSettId)
    {
        case DSP_VOLUME_SETT_ID:
        {
            uint8 volume = pMenuData[index] / VALUE_MAGNIFICATION + MAX_VOLUME;
            DSPDrv1761_SetVol(me, volume > MAX_VOLUME ? MAX_VOLUME : volume);
            break;
        }
        case DSP_EQ_CTRL_RGC:
        {
            uint16 freq = pMenuData[index] / VALUE_MAGNIFICATION;
            eUserRGCSlope slope = (eUserRGCSlope) (pMenuData[index + 1] / VALUE_MAGNIFICATION);
            DspDrv1761_SetRGC(me, freq, slope, enable);
            break;
        }
        case DSP_EQ_CTRL_USER_LP:
        {
            uint16 freq = pMenuData[index] / VALUE_MAGNIFICATION;
            eUserLpSlope slope = (eUserLpSlope) (pMenuData[index + 1] / VALUE_MAGNIFICATION);
            DspDrv1761_SetUserLp(me, freq, slope, enable);
            break;
        }

#ifdef SVS_PB3000
        case DSP_EQ_CTRL_TUNING:
        {
            eTuningRange range = (eTuningRange)(pMenuData[index] / VALUE_MAGNIFICATION);
            DspDrv1761_SetTuning(me, range);
            break;
        }
#endif
        case DSP_EQ_CTRL_PEQ1:
        case DSP_EQ_CTRL_PEQ2:
        case DSP_EQ_CTRL_PEQ3:
        {
            tDspFiltRawParam rawData;
            rawData.gain    = PARAM_EQ_GAIN;
            rawData.freq    = pMenuData[index] / VALUE_MAGNIFICATION;
            rawData.boost   = (double)(pMenuData[index + 1] / VALUE_MAGNIFICATION);
            rawData.q       = pMenuData[index + 2] / VALUE_MAGNIFICATION;;
            rawData.en      = enable;
            rawData.dspFiltType = FILTER_TYPE_PEAKING;
            DspDrv1761_SetPeq(me, dspSettId, rawData);
            break;
        }
        case DSP_PHASE_SETT_ID:
        {
            uint8 phaseShift = pMenuData[index] / VALUE_MAGNIFICATION;
            DspDrv1761_SetPhase(me, phaseShift);
            break;
        }
        case DSP_POLARITY_SETT_ID:
        {
            ePolarityType polarityType = (ePolarityType)(pMenuData[index] / VALUE_MAGNIFICATION);
            DspDrv1761_SetPolarity(me, polarityType);
            break;
        }
        default:
        {
            break;
        }
    }
}


/**
 * Mutes the DSP DAC output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1761_Mute(cDSPDrv1761 *me, eAudioMuteType muteType, BOOL muteEnable)
{
    uint8 mixer_lr = 0;//mixer LR_RIGHT
    uint8 mixer_ll = 0;//mixer LR_LEFT
    uint8  temp[3] = {0};

    ASSERT(me->deviceAddr);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_LEFT_ADDR,  MIXER_REG_LENGTH, (uint8*)&mixer_ll);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_RIGHT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_lr);

    if(muteEnable)
    {
        mixer_ll = (mixer_ll & 0xFD); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = (PLAYBACK_LR_LEFT_ADDR & 0x00ff);
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        mixer_lr = (mixer_lr & 0xF7); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = (PLAYBACK_LR_RIGHT_ADDR & 0x00ff);
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }
    else
    {
        mixer_ll = (mixer_ll | 0x02); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = (PLAYBACK_LR_LEFT_ADDR & 0x00ff);
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        mixer_lr = (mixer_lr | 0x08); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = (PLAYBACK_LR_RIGHT_ADDR & 0x00ff);
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }
}


/**
 * Set PGA Gain Adj
 *
 * @param bool enable: TRUE - added on -4.5dB; FALSE - set back to 0dB (default)
 * @return     void
 */
void DSPDrv1761_SetPGAGainAdj(cDSPDrv1761 *me, bool enable)
{
    uint8 temp[6]= {0};

    // address
    temp[0] = (VOLUME_PGA_GAIN_ADJ_ADDRESS >> 8) & 0x00FF;
    temp[1] = VOLUME_PGA_GAIN_ADJ_ADDRESS & 0x00FF;

    // value
    if(enable)
    {
        // -4.5db
        temp[2] = 0x00;
        temp[3] = 0x4C;
        temp[4] = 0x3E;
        temp[5] = 0xA8;
    }
    else
    {
        // 0db
        temp[2] = 0x00;
        temp[3] = 0x80;
        temp[4] = 0x00;
        temp[5] = 0x00;
    }

    DspDrv1761_I2cWrite(me, sizeof(temp), temp);
}

/**
 * Set PGA Gain
 *
 * @param bool enable: TRUE - added on +6dB; FALSE - set back to 0dB (default)
 * @return     void
 */
void DSPDrv1761_SetPGAGain(cDSPDrv1761 *me, bool enable)
{
    uint8  temp[3] = {0};

    if (enable)
    {
        temp[0] = 0x40;
        temp[1] = 0x0E;
        temp[2] = 0x5B; /* +4.5 dB */ /*0x63;*/     /* +6dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0F;
        temp[2] = 0x5B; /* +4.5dB */   /*0x63;*/     /* +6dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0B;
        temp[2] = 0x0F;     /* +6dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0D;
        temp[2] = 0x0F;     /* +6dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }
    else
    {
        temp[0] = 0x40;
        temp[1] = 0x0E;
        temp[2] = 0x43;     /* 0dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0F;
        temp[2] = 0x43;     /* 0dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0B;
        temp[2] = 0x0D;     /* 0dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);

        temp[0] = 0x40;
        temp[1] = 0x0D;
        temp[2] = 0x0D;     /* 0dB */
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }
}

/**
 * Set volume
 *
 * @param      uint8        target volume
 * @return     void
 */
static void DSPDrv1761_SetVol(cDSPDrv1761 *me, uint8 vol)
{
    /* write DSP register */
    uint8 vol_iic[4] = {0, 0, 0, vol};
    bool setPGA;

    #define VOLUME_THRESHOLD        (54)
    prev_volume = vol;

    DspDrv1761_SafeLoadData(me, 1, vol_iic, VOLUME_CTRL_ADDRESS);
    
    /* set PGA gain */    
    setPGA = vol < VOLUME_THRESHOLD ? FALSE : TRUE;
    DSPDrv1761_SetPGAGain(me, setPGA);
    DSPDrv1761_SetPGAGainAdj(me, setPGA);
}

static void DspDrv1761_SetPolarity(cDSPDrv1761 *me, ePolarityType polarityType)
{
    uint8    temp[4] = {0};
    uint8    polarityChannel[4] = {0};

    /* get addr */
    temp[0] = 0x00;
    temp[1] = 0x80;
    temp[2] = 0x00;
    temp[3] = 0x00;

    if(polarityType == POLARITY_NEGATIVE)
    {
        temp[0] = 0xFF;
    }
    
    DspDrv1761_I2cRead(me, POLARITY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&polarityChannel);
    if(polarityChannel[3] == POLARITY_CHANNEL_0)
    {
        polarityChannel[3] = POLARITY_CHANNEL_1;
        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_1_ADDRESS);
    }
    else if(polarityChannel[3] == POLARITY_CHANNEL_1)
    {
        polarityChannel[3] = POLARITY_CHANNEL_0;
        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_0_ADDRESS);
    }

    DspDrv1761_SafeLoadData(me, 1, polarityChannel, POLARITY_CHANNEL_CTRL_ADDRESS);
}


static void DspDrv1761_SetPhaseCB(void * pCbPara)
{
    uint8    delayChannel[4] = {0};

    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(isPhaseInited)
    {
        if(delayChannel[3] == DELAY_CHANNEL_0)
        {
            delayChannel[3] = DELAY_CHANNEL_1;
        }
        else if(delayChannel[3] == DELAY_CHANNEL_1)
        {
            delayChannel[3] = DELAY_CHANNEL_0;
        }
    }
    isPhaseInited = TRUE;
    DspDrv1761_SafeLoadData(pDspObj, 1, delayChannel, DELAY_CHANNEL_CTRL_ADDRESS);
    phaseTimer = INVALIDE_TIMER;
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */
static void DspDrv1761_SetPhase(cDSPDrv1761 *me, uint8 phaseShift)
{
    uint8    delayChannel[4] = {0};
    uint8    temp[4] = {0};
    uint16   tmp = 0;

    tmp = phaseShift * MAX_DELAY_SAMPLES;
    temp[0] = 0x00;
    temp[1] = 0x00;
    temp[2] = ((tmp/180)& 0xff00) >> 8;
    temp[3] = (tmp/180)& 0x00ff;

    if(phaseShift == 0)
    {
        temp[3] = NO_PHASE_SHIFT;
    }
    if(phaseTimer != INVALIDE_TIMER)
    {
        Timer_StopTimer(phaseTimer);
    }

    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(delayChannel[3] == DELAY_CHANNEL_0)
    {
        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_1_ADDRESS);
    }
    else if(delayChannel[3] == DELAY_CHANNEL_1)
    {
        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_0_ADDRESS);
    }
    Timer_StartTimer(600,&phaseTimer, DspDrv1761_SetPhaseCB, NULL);
}

static void DspDrv1761_InitSection0(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection0\r\n");
    cDSPDrv1761 * me = (cDSPDrv1761*)p;
    const tDevice * pDevice = NULL;
    pDevice = getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(pDevice);
    I2CDrv_Ctor(me->i2cObj,(tI2CDevice*)pDevice);
    me->i2cObj->registeredUser++;
}

static void DspDrv1761_InitSection1(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection1\r\n");
    cDSPDrv1761 * me = (cDSPDrv1761*)p;
	DSPDrv1761_Writer_Register(me, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R0_SAMPLE_RATE_SETTING_IC_1_Default );
	DSPDrv1761_Writer_Register(me, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R1_DSP_RUN_REGISTER_IC_1_Default );
	DSPDrv1761_Writer_Register(me, REG_CLKCTRLREGISTER_IC_1_ADDR, REG_CLKCTRLREGISTER_IC_1_BYTE, R2_CLKCTRLREGISTER_IC_1_Default );
	DSPDrv1761_Writer_Register(me, REG_PLLCRLREGISTER_IC_1_ADDR, REG_PLLCRLREGISTER_IC_1_BYTE, R3_PLLCRLREGISTER_IC_1_Default );
}

static void DspDrv1761_InitSection2(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection2\r\n");
    cDSPDrv1761 * me = (cDSPDrv1761*)p;
    DSPDrv1761_Writer_Register(me, REG_SERIAL_PORT_CONTROL_0_IC_1_ADDR , R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_SIZE, R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_ALC_CONTROL_0_IC_1_ADDR , R6_ALC_CONTROL_REGISTERS_IC_1_SIZE, R6_ALC_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_MICCTRLREGISTER_IC_1_ADDR, REG_MICCTRLREGISTER_IC_1_BYTE, R7_MICCTRLREGISTER_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_RECORD_PWR_MANAGEMENT_IC_1_ADDR , R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_ADC_CONTROL_0_IC_1_ADDR , R9_ADC_CONTROL_REGISTERS_IC_1_SIZE, R9_ADC_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_PLAYBACK_MIXER_LEFT_CONTROL_0_IC_1_ADDR , R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_CONVERTER_CTRL_0_IC_1_ADDR , R11_CONVERTER_CONTROL_REGISTERS_IC_1_SIZE, R11_CONVERTER_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DAC_CONTROL_0_IC_1_ADDR , R12_DAC_CONTROL_REGISTERS_IC_1_SIZE, R12_DAC_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_SERIAL_PORT_PAD_CONTROL_0_IC_1_ADDR , R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_COMM_PORT_PAD_CTRL_0_IC_1_ADDR , R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_JACKREGISTER_IC_1_ADDR, REG_JACKREGISTER_IC_1_BYTE, R15_JACKREGISTER_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DSP_ENABLE_REGISTER_IC_1_ADDR, REG_DSP_ENABLE_REGISTER_IC_1_BYTE, R21_DSP_ENABLE_REGISTER_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_CRC_IDEAL_1_IC_1_ADDR , R22_CRC_REGISTERS_IC_1_SIZE, R22_CRC_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_GPIO_0_CONTROL_IC_1_ADDR , R23_GPIO_REGISTERS_IC_1_SIZE, R23_GPIO_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_NON_MODULO_RAM_1_IC_1_ADDR , R24_NON_MODULO_REGISTERS_IC_1_SIZE, R24_NON_MODULO_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_WATCHDOG_ENABLE_IC_1_ADDR , R25_WATCHDOG_REGISTERS_IC_1_SIZE, R25_WATCHDOG_REGISTERS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R26_SAMPLE_RATE_SETTING_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_ROUTING_MATRIX_INPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_INPUTS_IC_1_BYTE, R27_ROUTING_MATRIX_INPUTS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_ROUTING_MATRIX_OUTPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_OUTPUTS_IC_1_BYTE, R28_ROUTING_MATRIX_OUTPUTS_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_ADDR, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_BYTE, R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DSP_SLEW_MODES_IC_1_ADDR, REG_DSP_SLEW_MODES_IC_1_BYTE, R30_DSP_SLEW_MODES_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_BYTE, R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_CLOCK_ENABLE_REG_0_IC_1_ADDR , R32_CLOCK_ENABLE_REGISTERS_IC_1_SIZE, R32_CLOCK_ENABLE_REGISTERS_IC_1_Default );
    uint16 i;
    for(i = 0; i * 5 < PROGRAM_SIZE_IC_1; i++)
    {
       DSPDrv1761_Writer_Register( me, PROGRAM_ADDR_IC_1+i, 5, &Program_Data_IC_1[i*5] ); /* 40 bit dsp prgram ram, 64*4 = 256 bytes */
    }
    for(i = 0; i * 4 < PARAM_SIZE_IC_1; i++)
    {
        DSPDrv1761_Writer_Register( me, PARAM_ADDR_IC_1+i, 4, &Param_Data_IC_1[i*4] ); /* 32 bit dsp prgram ram */
    }
    DSPDrv1761_Writer_Register(me, NON_MODULO_RAM_ADDR_IC_1, NON_MODULO_RAM_SIZE_IC_1, NON_MODULO_RAM_Data_IC_1 );
    DSPDrv1761_Writer_Register(me, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R36_SAMPLE_RATE_SETTING_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R37_DSP_RUN_REGISTER_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R38_DEJITTER_REGISTER_CONTROL_IC_1_Default );
    DSPDrv1761_Writer_Register(me, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R39_DEJITTER_REGISTER_CONTROL_IC_1_Default );
}



/**
 * Format input int32 data array into array of uint8, according to the designated number of int32
 *
 * @param      int32*          start address of the input int32 array
 *
 * @param      uint8*          output data array pointer
 *
 * @param      uint8           number of input int32 data
 *
 * @return     void
 */
static void DspDrv1761_FormatFiltData(int32* in, uint8* out, uint8 num)
{
    uint32        temp;
    uint8          cnt;
    int32*        ptr0;
    uint8*        ptr1;

    ptr0 = in;
    ptr1 = out;

    for(cnt = 0; cnt < num; cnt++)
    {
        temp  = (uint32)(*ptr0);
        *ptr1 = (uint8)((temp >> 24) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 16) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 8) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)(temp & 0xFF);
        ptr1++;
        ptr0++;
    }
}

/**
 * This function is used to convert filter Parameter (Q factor, center freq, etc) into 5 DSP parameters
 *
 * @param   tDspFiltRawParam                 the filter parameter raw input
 * @param   uint8*                           pointer to the output data
 * @return  void
 */
static void DspDrv1761_CalFiltParam(tDspFiltRawParam in, uint8* out)
{
    /* calculate common param for all filter */
    double w0 = 2.0*PI*in.freq/DSP_SAMPLING_FREQ;
    double A = pow(10.0, in.boost/40.0);
    double gainLinear = pow(10.0, in.gain/20.0);
    double a0, a1, a2, b0, b1, b2, S, alpha;
    int32  temp[EQ_CTRL_RAM_SLOT_NUM];

    S = in.q;
    if(in.en == FALSE)
    {
        temp[0] = 0x00800000;
        temp[1] = 0x00000000;
        temp[2] = 0x00000000;
        temp[3] = 0x00000000;
        temp[4] = 0x00000000;
        /* change the data from int32 to uint8 */
        DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
        return;
    }
    else if(in.q == 0)
    {
        S = 0.05;
    }

    switch(in.dspFiltType)
    {
#ifdef HAS_PEAKING_FILTER
        case FILTER_TYPE_PEAKING:
        {
            alpha = sin(w0) / (2.0 * S);

            a0 = 1.0 + alpha / A;
            a1 = -2.0 * cos(w0);
            a2 = 1.0 - alpha / A;
            b0 = (1.0 + alpha * A) * gainLinear;
            b1 = - ( 2.0 * cos(w0)) * gainLinear;
            b2 = ( 1.0 - A * alpha) * gainLinear;

            /*  speical behavior when speical inputs
             *  (inspired by Sigma Studio outputs)
             * */
            if(in.boost == 0.00)
            {
                b1=0;
                b2=0;
                a1=0;
                a2=0;
            }
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_LOW_SHELF_FILTER
        case FILTER_TYPE_TONE_LOW_SHELF:
        {
            alpha = (sin(w0)/ 2 ) * sqrt( ( A + 1/A ) * ( 1 / S - 1) + 2);
            a0 = (A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 =  -2*( (A-1) + (A+1)*cos(w0) );
            a2 = (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha;
            b0 =  A*( (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha ) * gainLinear;
            b1 = 2*A*( (A-1) - (A+1)*cos(w0) ) * gainLinear;
            b2 =  A*( (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha ) * gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_HIGH_SHELF_FILTER
        case FILTER_TYPE_TONE_HIGH_SHELF:
        {
            alpha = (sin(w0)/2)*sqrt((A+1/A)*(1/S-1)+2);
            a0 = (A+1)-(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 = 2*((A-1)-(A+1)*cos(w0));
            a2 = (A+1)-(A-1)*cos(w0)-2*sqrt(A)*alpha;
            b0 = A*((A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha)*gainLinear;
            b1 = -2*A*((A-1)+(A+1)*cos(w0))*gainLinear;
            b2 = A*((A+1)+(A-1)*cos(w0)-2*sqrt(A)*alpha)*gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_LOW_PASS_FILTER
        case FILTER_TYPE_GENERAL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = (1-cos(w0))*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_HIGH_PASS_FILTER
        case FILTER_TYPE_GENERAL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_LOW_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_LOW_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_HIGH_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_HIGH_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2.0*cos(w0);
            a2 = 1.0-alpha;
            b0 = (1.0+cos(w0))*gainLinear/2.0;
            b1 = -(1.0+cos(w0))*gainLinear;
            b2 = (1.0+cos(w0))*gainLinear/2.0;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_LOW_PASS_FILTER
        case FILTER_TYPE_BESSEL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_HIGH_PASS_FILTER
        case FILTER_TYPE_BESSEL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_LOW_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_LOW_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * (1.0 - a1);
            b1 = 0;
            b2 = 0;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_HIGH_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_HIGH_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * a1;
            b1 = 0 - b0;
            b2 = 0;
        }
        break;
#endif
        default:
        {
            /* wrong data in */
            ASSERT(0);
        }
        break;
    }

    /* check data */
    ASSERT((a1 > -16.0) && (a1 < 15.99));
    ASSERT((a2 > -16.0) && (a2 < 15.99));
    ASSERT((b0 > -16.0) && (b0 < 15.99));
    ASSERT((b1 > -16.0) && (b1 < 15.99));
    ASSERT((b2 > -16.0) && (b2 < 15.99));

    /* feed into output structure */
    temp[0] = (int32)(b0*(1L << 23));
    temp[1] = (int32)(b1*(1L << 23));
    temp[2] = (int32)(b2*(1L << 23));
    temp[3] = (int32)(a1*(1L << 23));
    temp[4] = (int32)(a2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}


void DspDrv1761_SetI2Smode(cDSPDrv1761 *me, BOOL isMaster)
{
//    ASSERT(me && me->isCreated);
//    
//    //read
//    uint8   data_read[1] = {0};
//    DspDrv1761_I2cRead(me, ADAU1761_I2S_CONTROL_ADDR, sizeof(data_read), data_read);    
//    if(isMaster)
//    {
//        TYM_SET_BIT(data_read[0], 0x1);
//    }
//    else
//    {
//        TYM_CLR_BIT(data_read[0], 0x1);
//    }
//    
//    //write
//    uint8 data_write[3] = {0};
//    uint32 reg_addr= ADAU1761_I2S_CONTROL_ADDR;
//    data_write[0] = reg_addr >> 8;
//    data_write[1] = reg_addr & 0x00FF;
//    data_write[2] = data_read[0];
//    DspDrv1761_I2cWrite(me, sizeof(data_write), (uint8*)data_write);
}


/**
 * Set BGC
 *
 * @param      int8            boost
 * @param      bool            enable or disable
 * @return     void
 */
static void DspDrv1761_SetRGC(cDSPDrv1761 *me, uint16 freq, eUserRGCSlope slope, bool en)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8             currIdx;
    uint32            regAddress = RGC_CTRL_ADDRESS;
    uint8             i = 0;

    rawData.freq        = freq;
    rawData.boost       = RGC_BOOST;
    rawData.gain        = RGC_GAIN;
    rawData.q           = RGC_QFACTOR;
    rawData.en          = en;
    rawData.dspFiltType = FILTER_TYPE_BUTTWORTH_HIGH_PASS;

    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_RGC_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_RGC_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        default:
            ASSERT(0);
            break;
    }

    for(i = 0; i < NUM_OF_RGC_SET_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me,EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }

        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}

void DspDrv1761_SetLimiter(cDSPDrv1761 *me, int16 limiterLevel)
{
    uint8 *coefficientArray = NULL;
    
    switch(limiterLevel)
    {
        case AMP_TL_NORMAL:
            coefficientArray = (uint8 *)limiter_minus_20;
            break;
        case AMP_TL_WARN_1:
            coefficientArray = (uint8 *)limiter_minus_21;
            break;
        case AMP_TL_WARN_2:
            coefficientArray = (uint8 *)limiter_minus_22;
            break;
        case AMP_TL_WARN_3:
            coefficientArray = (uint8 *)limiter_minus_24;
            break;
        case AMP_TL_WARN_4:
            coefficientArray = (uint8 *)limiter_minus_26;
            break;
        case AMP_TL_WARN_5:
            coefficientArray = (uint8 *)limiter_minus_28;
            break;
        case AMP_TL_CRITICAL:
            coefficientArray = (uint8 *)limiter_minus_29;
            break;
        default:
            ASSERT(0);
            break;
    }

    if(NULL != coefficientArray)
    {
        DSPDrv1761_Writer_Register(me, LIMITER_COEFFICIENT_CTRL_ADDRESS, LIMITER_COEFFICIENT_DATA_SIZE, coefficientArray);
    }
}

static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out)
{
    double w,G1,a11,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];

    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    G1 = w/(w+1);
    a11 = (w-1)/(w+1);

    B0 = G1;
    B1 = G1;
    B2 = 0;
    A1 = -a11;
    A2 = 0;

    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

    /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}


static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out)
{
    double w,G2,a21,a22,alpha,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];

    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    alpha = (1 - 2*w*delta + w*w);
    G2 = w*w / alpha;
    a21 = -(2 * (w*w - 1) / alpha);
    a22 = -((1 + 2*w*delta + w*w) / alpha);

    B0 = G2;
    B1 = 2*G2;
    B2 = G2;
    A1 = a21;
    A2 = a22;

    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

    /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}

/**
 * Set User LP
 *
 * @param      int8            boost
 * @param      eUserLpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserLp(cDSPDrv1761 *me, uint16 freq, eUserLpSlope slope, bool en)
{
    double delta2 = cos(3*PI/4);
    double delta3 = cos(4*PI/6);
    double delta4_1 = cos(5*PI/8);
    double delta4_2 = cos(7*PI/8);
    double delta = 0;
    uint8 finalData[EQ_CTRL_RAM_BYTE_NUM];
    int32 bypassData[5];

    bypassData[0] = 0x00800000;
    bypassData[1] = 0x00000000;
    bypassData[2] = 0x00000000;
    bypassData[3] = 0x00000000;
    bypassData[4] = 0x00000000;

    memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);

    if(en)
    {
        finalData[3] = 0x01;
        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
    }
    else
    {
        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
        return;
    }

    /* check slope */
    switch(slope)
    {
        case USER_LP_SLOPE_6DB:
        {
            DspDrv1761_CalculateFirstOrder(me, freq, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData, 0x00, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        }
        case USER_LP_SLOPE_12DB:
        {
            delta = delta2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        }
        case USER_LP_SLOPE_18DB:
        {
            delta = delta3;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_CalculateFirstOrder(me,freq,finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        }
        case USER_LP_SLOPE_24DB:
        {
            delta = delta4_1;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            delta = delta4_2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
            DspDrv1761_SafeLoadData(me, 5, finalData, LP_CTRL_ADDRESS+5);
            break;
        }
        default:
        {
            ASSERT(0);
            break;
        }
    }
}

/**
 * Set User HP
 *
 * @param      int8            boost
 * @param      eUserHpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserHp(cDSPDrv1761 *me, uint16 freq, eUserHpSlope slope, bool en)
{
    tDspFiltRawParam     rawData;
    uint8                finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8                currIdx;
    uint32               regAddress = 0x11;//HP_CTRL_ADDRESS; fix it!
    uint8                i = 0;

    rawData.freq         = freq;
    rawData.boost        = USER_HP_BOOST;
    rawData.gain         = USER_HP_GAIN;
    rawData.q            = USER_HP_QFACTOR;
    rawData.en           = en;
    rawData.dspFiltType  = FILTER_TYPE_FIRST_ORDER_HIGH_PASS;


    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_HP_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_HP_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        case USER_HP_SLOPE_18DB:
            currIdx = CTR_ADDR_GROUP_3;
            break;

        case USER_HP_SLOPE_24DB:
            currIdx = CTR_ADDR_GROUP_4;
            break;

        default:
            ASSERT(0);
            break;
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    
    for(i = 0; i < NUM_OF_FILTER_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }
        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}

#ifdef SVS_PB3000

/**
 * Set Tuning
 *
 * @param      eTuningRange           range
 * @return     void
 */
static void DspDrv1761_SetTuning(cDSPDrv1761 *me, eTuningRange range)
{

const uint8 tuning_bypass_eq[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
};

const uint8 standard_tuning_eq1[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x00,0x05,0x83,
0x00,0x00,0x0B,0x06,
0x00,0x00,0x05,0x83,
0x00,0xFB,0x37,0x11,
0xFF,0x84,0xB2,0xE4,
};

const uint8 standard_tuning_eq2[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x7F,0xA4,0x77,
0xFF,0x03,0x7D,0x3A,
0x00,0x7C,0xE1,0x6D,
0x00,0xFC,0x82,0xC6,
0xFF,0x83,0x7A,0x1C,
};

const uint8 standard_tuning_eq3[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x7F,0xE1,0xC6,
0xFF,0x00,0x3C,0x74,
0x00,0x7F,0xE1,0xC6,
0x00,0xFF,0xC3,0x7B,
0xFF,0x80,0x3C,0x62,
};

const uint8 standard_tuning_eq4[EQ_CTRL_RAM_BYTE_NUM] = {
0x00,0x7F,0xE1,0xC6,
0xFF,0x00,0x3C,0x74,
0x00,0x7F,0xE1,0xC6,
0x00,0xFF,0xC3,0x7B,
0xFF,0x80,0x3C,0x62,
};

const uint8 sealed_tuning_eq1[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x00,0x07,0xD7,
0x00,0x00,0x0F,0xAD,
0x00,0x00,0x07,0xD7,
0x00,0xF8,0x14,0xCD,
0xFF,0x87,0xCB,0xD8,
};
const uint8 sealed_tuning_eq2[EQ_CTRL_RAM_BYTE_NUM] =
{
0x00,0x80,0x1A,0x68,
0xFF,0x00,0x80,0x20,
0x00,0x7F,0x66,0x2E,
0x00,0xFF,0x80,0x0E,
0xFF,0x80,0x7F,0x97,
};

    uint8 finalData[EQ_CTRL_RAM_BYTE_NUM];

    switch(range)
    {
        /* Standard */
        case TUNING_RANGE_STANDARD:
            memcpy(finalData, standard_tuning_eq1, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS));
            memcpy(finalData, standard_tuning_eq2, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+5));
            memcpy(finalData, standard_tuning_eq3, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+10));
            memcpy(finalData, standard_tuning_eq4, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+15));
            break;

        /* Extended */
        case TUNING_RANGE_EXTENDED:
            /* no this option on SVS PB3000*/
            break;

        /* Sealed */
        case TUNING_RANGE_SEALED:
            memcpy(finalData, sealed_tuning_eq1, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS));
            memcpy(finalData, sealed_tuning_eq2, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+5));
            memcpy(finalData, tuning_bypass_eq, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+10));
            memcpy(finalData, tuning_bypass_eq, EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, (TUNNING_ADDRESS+15));
            break;

        default:
            ASSERT(0);
            break;
    }
}

#endif
/**
 * Set PEQ
 *
 * @param      eDspSettId       dsp setting ID
 * @param      uint8            the setting position in ctrIdEQIdMap
 * @param      enable           Enable or disable the settings
 */
static void DspDrv1761_SetPeq(cDSPDrv1761 *me, eAudioSettId dspSettId, tDspFiltRawParam rawData)
{
    uint8   i = 0;
    uint8   finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8   currIdx;
    uint32  regAddress = PEQ_CTRL_ADDRESS;

    DspDrv1761_CalFiltParam(rawData, finalData);

    switch(dspSettId)
    {
        case DSP_EQ_CTRL_PEQ1:
        {
            currIdx = ADDR_OFFSET_0;
            break;
        }
        case DSP_EQ_CTRL_PEQ2:
        {
            currIdx = ADDR_OFFSET_1;
            break;
        }
        case DSP_EQ_CTRL_PEQ3:
        {
            currIdx = ADDR_OFFSET_2;
            break;
        }
        default:
        {
            ASSERT(0);
            break;
        }
    }

    ASSERT(currIdx < EQ_CTRL_NUM);
    
    while(i < PARAMETRIC_EQ_MAX)
    {
      if(i == currIdx)
      {
          /* Set the right parametric EQ */
          DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
      }

      regAddress += EQ_CTRL_RAM_SLOT_NUM;
      i++;
    }
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */

/*
 * Below are the public functions which are not used in SVS but have to
 * be declared to supress compiling errors
 */

BOOL DSPDrv1761_IsAuxin(cDSPDrv1761 *me)
{
    return FALSE;
}


/**
 * Read signal level for sig detection
 *
 * @param      N/A
 * @return     float float version
 */

void DSPDrv1761_GetSigLevel(cDSPDrv1761 *me, float *fSigLev)
{

}

BOOL DSPDrv1761_HasMusicStream(cDSPDrv1761 *me)
{
#define ADAU1761_GET_STREAM_STATUS_LEN  (4)

/*
    threshold (750)     ->  1.3mV RCA 100Hz single input
              (3800)    ->  5mV
*/
#define ADAU1761_STREAM_DETECT_TRESHOLD (3800)

    bool status = FALSE;
    uint8 data[ADAU1761_GET_STREAM_STATUS_LEN] = {0};
    uint32 readValue;

    DspDrv1761_I2cRead(me, ADAU1761_GET_STREAM_STATUS_ADDR, sizeof(data), data);
    readValue = (data[2] << 8) | data[3];
    //TP_PRINTF("readValue=%d\r\n", readValue);
    if(readValue > ADAU1761_STREAM_DETECT_TRESHOLD)
    {
        status = TRUE;
    }

    return status;
}

void DSPDrv1761_SetInputChannel(cDSPDrv1761 *me, eAudioChannel inputChannel)
{
}


/**
 * Read DSP Version
 *
 * @param      N/A
 * @return     float float version
 */
void DSPDrv1761_GetDspVer(cDSPDrv1761 *me, float *fVerRet)
{
//    ASSERT(me && me->isCreated);
//    uint8   data[DSP_VER_REGISTER_LEN] = {0};
//    DspDrv1761_I2cRead(me, DSP_VER_REGISTER, sizeof(data), data);
//    float ver= DSPDrv1761_DataToFloat(me, UINT32_BYTE_INV(data), 5, 23); //format 5.23
//    *fVerRet = ver;    
}


/**
 * Enable/Disalbe DSP I2C access
 */
void DSPDrv1761_I2cEnable(cDSPDrv1761 *me, bool i2cEnable)
{
    me->i2cEnable= i2cEnable;
}
/**
 * Bypass the EQ
 *
 * @param      isBypass, TRUE: bypass EQ, FALSE:use EQ
 * @return     void
 */
void DSPDrv1761_EQBypass(cDSPDrv1761 *me, BOOL isBypass)
{
    uint8 bypassEq[] ={0x00, 0x00, 0x00, 0x01};
    uint8 usingEq[]  ={0x00, 0x00, 0x00, 0x00};

    if(isBypass)
    {
        DSPDrv1761_Writer_Register(me, EQ_BYPASS_ADDR, sizeof(bypassEq), bypassEq);
    }
    else
    {
        DSPDrv1761_Writer_Register(me, EQ_BYPASS_ADDR, sizeof(usingEq), usingEq);
    }
}

/**
 * Run/stop the internal DSP.
 *
 * @param      bool               TRUE - run, FALSE - stop
 * @return     bool               TRUE - writes successfully, FALSE - fails
 */
bool DSPDrv1761_RunDSP(cDSPDrv1761 *me, BOOL enable)
{
    uint8 clock_control_reg[3] = {0x40, 0x00, 0x07};              /* direct MCLK, INFREQ = 1024*fs */

    uint8 converter_ctrl0_reg[3] = {0x40, 0x17, 0x19};                    /* fs/6 = 8kHz, DAC = 64x, ADC = 64x */
    uint8 dsp_sampling_rate_setting[3] = {0x40, 0xeb, 0x06};          /* fs/6 = 8kHz */
    uint8 record_power_management[3] = {0x40, 0x09, 0x0e};
    uint8 dac_control0_reg[3] = {0x40, 0x2a, 0x00};           /* DAC off */
    uint8 playback_power_management[3] = {0x40, 0x29, 0x5C};
    uint8 playback_pop_suppression_reg[3] = {0x40, 0x28, 0x10 /*0x08*/};
    uint8 clock_enable_1_reg[3] = {0x40, 0xFA, 0x01};           /* disable digital clock generator 1 */

    uint8 on_clock_control_reg[3] = {0x40, 0x00, 0x09};
    uint8 on_converter_ctrl0_reg[3] = {0x40, 0x17, 0x00};
    uint8 on_dsp_sampling_rate_setting[3] = {0x40, 0xeb, 0x01};
    uint8 on_record_power_management[3] = {0x40, 0x09, 0x00};
    uint8 on_dac_control0_reg[3] = {0x40, 0x2a, 0x03};
    uint8 on_playback_power_management[3] = {0x40, 0x29, 0x03};
    uint8 on_playback_pop_suppression_reg[3] = {0x40, 0x28, 0x00};
    uint8 on_clock_enable_1_reg[3] = {0x40, 0xFA, 0x01};

    /* Do not decrease the dsp sampling for a power saving, it need a higher input signal to wake DSP
    *  during standby mode
    */
    if (!enable)
    {
        //DspDrv1761_I2cWrite(me, 3, converter_ctrl0_reg);
        //DspDrv1761_I2cWrite(me, 3, dsp_sampling_rate_setting);
        //DspDrv1761_I2cWrite(me, 3, record_power_management);
        DspDrv1761_I2cWrite(me, 3, dac_control0_reg);
        DspDrv1761_I2cWrite(me, 3, playback_power_management);
        DspDrv1761_I2cWrite(me, 3, playback_pop_suppression_reg);
        DspDrv1761_I2cWrite(me, 3, clock_enable_1_reg);
        //DspDrv1761_I2cWrite(me, 3, clock_control_reg);

#ifdef INCREASE_SN_RATIO_BY_PGA
        /* reset PGA gain when goto standby */
        /* set PGA gain = 0dB */
        DSPDrv1761_SetPGAGain(me, FALSE);
#endif
    }
    else
    {
        //DspDrv1761_I2cWrite(me, 3, on_clock_control_reg);
        //DspDrv1761_I2cWrite(me, 3, on_converter_ctrl0_reg);
        //DspDrv1761_I2cWrite(me, 3, on_dsp_sampling_rate_setting);
        //DspDrv1761_I2cWrite(me, 3, on_record_power_management);
        DspDrv1761_I2cWrite(me, 3, on_dac_control0_reg);
        DspDrv1761_I2cWrite(me, 3, on_playback_power_management);
        DspDrv1761_I2cWrite(me, 3, on_playback_pop_suppression_reg);
        DspDrv1761_I2cWrite(me, 3, on_clock_enable_1_reg);

#ifdef INCREASE_SN_RATIO_BY_PGA
        DSPDrv1761_SetVol(me, prev_volume);
#endif
    }
    return TRUE;
}




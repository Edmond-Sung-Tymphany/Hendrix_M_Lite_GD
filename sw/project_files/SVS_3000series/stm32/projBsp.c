/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Public project Bsp interfaces
                  -------------------------

                  SW Module Document




@file        projBsp.h
@brief       This file implements the public project bsp interfaces which declared
             at projBsp.h
@author      Bob.Xu
@date        2014-07-14
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-12     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include <stdarg.h> //va_list
#include "stm32f0xx.h"
#include "trace.h"
#include "bsp.h"
#include "projBsp.h"
#include "attachedDevices.h"
#include "IoExpanderDrv.h"
#include "object_ids.h"
#include "signals.h"
#include "controller.h"
#include "usb_dcd.h"
#include "usb_core.h"

#ifdef LPM_ENABLED
__IO uint32_t  L1_remote_wakeup =0;
__IO uint32_t BESL = 0;
#endif

#ifdef HAS_PROJ_PRINTF
int ProjBsp_Printf(bool toAse, const char *file, const int line, const char *fmt, ...)
{
    /* AseNgSrv_SendLog() also print and enter this function again, it cause infinite recursive call.
     * Thus we use "critical_section" to avoid repeated enter here
     */
    static bool critical_section= 0;
    if( critical_section ) {
        return 0;
    }

    critical_section= 1;
    ASSERT(file);
    ASSERT(fmt);

    static char buf[256];
    va_list argus;
    va_start( argus, fmt );
    vsnprintf (buf, sizeof(buf), fmt, argus );
    va_end( argus );

    //Print to UART
#ifndef NDEBUG   
    //printf(buf);
    char *p_ch= buf;
    static char pre_ch= '\n';
    uint32 time= getSysTime(); //time will overflow after 49.x days
    while(*p_ch!='\0')
    {
        if(pre_ch=='\n')
        {
            //Note the time do not include MCU sleep period (OFF mode), because on MCU do not execute time interrupt on sleep
            printf("[%dd,%02d:%02d:%02d.%03d] ", time/1000/60/60/24, (time/1000/60/60)%24, (time/1000/60)%60, (time/1000)%60, time%1000);
        }
        putchar(*p_ch);
        pre_ch= *p_ch;
        p_ch++;
    }
#endif

    critical_section= 0;
    return 0;
}
#endif

/* On exception handler, interrupt is disabled, we can not use BSP_BlockingDelayMs()
 * But this delay is not accurary
 */
void BSP_ExpBlockingDelayMs(uint32 ms)
{
#if defined(INTERNAL_HIGH_SPEED_CLOCK)
    uint32 us= 1000 * ms; //8MHz CPU
#elif defined(EXTERNAL_HIGH_SPEED_CLOCK)
    uint32 us= 6000 * ms; //48MHz CPU
#elif defined(EXTERNAL_AND_INTERNAL_HIGH_SPEED_CLOCK)
    uint32 us= 1000 * ms; //8MHz CPU
#else
    error wrong clock setting
#endif

    while(us--)
    {
        asm("nop");
        asm("nop");
    }
}


void ProjBsp_CyclePrintError(char* errString)
{
    /* To be implemented */
    //ProjBsp_PrintError(); refer to polkAllplayer
    while((*errString)!='\0')
    {
        while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
        USART_SendData(USART1, (*errString));
        errString++;
    }
}

void ProjBsp_JumpToBootloader(void)
{
    // fill in your project api. 
}


#ifdef PROJECT_SPEC_ASSERT_HANDLER
void ProjBsp_AssertHandler(char const * const file, int line)
{
#ifndef NDEBUG
    tIoeLedDevice *pIoeLedConfig = (tIoeLedDevice*) getDevicebyIdAndType(LED_DEV_ID, IO_EXPANDER_DEV_TYPE, NULL);      
    cIoExpanderDrv ioeDrv= {0};
    
    //turn off all LED
    IoExpanderDrv_Ctor_aw9110b(&ioeDrv, pIoeLedConfig);
    const tIoExpanderLedMap *ledMap= pIoeLedConfig->pIoExpanderLedMap;
    int i;
    for(i=0 ; i<pIoeLedConfig->ledNum ; i++)
    {		
        IoExpanderDrv_SetBrightness_aw9110b(&ioeDrv, ledMap[i].port, ledMap[i].pin, 0);
    }
    
    //Blink All LED
    IoExpanderDrv_AutoBlink_aw9110b(&ioeDrv, IOE_AUTO_PATT_ERROR);
#endif    
}
#endif

void ProjBsp_SysClkUpdate()
{
#ifdef EXTERNAL_HIGH_SPEED_CLOCK
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
  
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
   
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
    StartUpCounter++;  
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
  {
    HSEStatus = (uint32_t)0x01;
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
  }  

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
      
    /* PCLK = HCLK/4 */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;

    /* PLL configuration = HSE(12MHz) * 4 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));

    /* config sysclk = 32M & PCLK=8M
	 * it let I2C2 clock = 8M, the same as I2C1, thus I2C1/I2C2 share the same clock setting
	 */
#if DEBUG_ON_EVK
	RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL4);
	RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV1_DIV1);
#else
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL8);
    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV1_DIV3);
#endif
	/* config sysclk = 48M
	 * it cause I2C2 clock = 12M, when choose this seting, I2C2 timing must be updated.
	 */
    //RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL4);

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
    {
    }
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
#else

    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;

    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;

    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;

#ifdef USB_CLOCK_SOURCE_CRS
    /* Enable HSI48 */
    RCC->CR2 |= (uint32_t)RCC_CR2_HSI48ON;
    /* Wait till HSI48RDY is set */
    while((RCC->CR2 & RCC_CR2_HSI48RDY) == RESET)
    {
    }
#else

    /* PLL up to 48KHz as USB CLK, but use HSI as the SYSCLK*/
    RCC->CFGR &= (uint32_t)(~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSI | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL6);
    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV1_DIV1);

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }
#endif

    /* Select PLLCLK as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSI;

    /* use MCO clock to generate the MCLK for DSP*/
    /* Enable HSE */
    RCC->CR |= (uint32_t)RCC_CR_HSEON;
    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_HSERDY) == 0)
    {
    }
    MCO_init();

#endif
}


/**************************************************/
/***************  interrupt funcs *********************/
/**************************************************/
/**
  * @brief  This function handles External line 0 interrupt request
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
    TP_PRINTF("EXTI0_1_IRQHandler\r\n");
}

void EXTI2_3_IRQHandler(void)
{
    TP_PRINTF("EXTI2_3_IRQHandler\r\n");
}

void EXTI4_15_IRQHandler(void)
{
    TP_PRINTF("EXTI4_15_IRQHandler\r\n");
}


void SetEnableWakeupSources()
{

}

void SetDisableWakeupSources()
{

}

/**************************************************/
/************ un-unsed interrupt funcs ****************/
/* User need to remove or fill in the specific function          */
/* if the interrupt is used                                                */
/**************************************************/

//TODO: the following IRQ is copy from STM32F1, should different with STM32F0
void WWDG_IRQHandler(void)
{
    ASSERT(0);
}

void PVD_IRQHandler(void)
{
    ASSERT(0);
}

void TAMPER_IRQHandler(void)
{
    ASSERT(0);
}

void FLASH_IRQHandler(void)
{
    ASSERT(0);
}

void RCC_IRQHandler(void)
{
    ASSERT(0);
}

void EXTI1_IRQHandler(void)
{
    ASSERT(0);
}

void EXTI3_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel1_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel2_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel3_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel4_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel5_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel6_IRQHandler(void)
{
    ASSERT(0);
}

void DMA1_Channel7_IRQHandler(void)
{
    ASSERT(0);
}

void ADC1_2_IRQHandler(void)
{
    ASSERT(0);
}

void CAN1_TX_IRQHandler(void)
{
    ASSERT(0);
}

void CAN1_RX0_IRQHandler(void)
{
    ASSERT(0);
}

void CAN1_RX1_IRQHandler(void)
{
    ASSERT(0);
}

void CAN1_SCE_IRQHandler(void)
{
    ASSERT(0);
}

void TIM1_BRK_IRQHandler(void)
{
    ASSERT(0);
}

void TIM1_UP_IRQHandler(void)
{
    ASSERT(0);
}

void TIM1_TRG_COM_IRQHandler(void)
{
    ASSERT(0);
}

void TIM1_CC_IRQHandler(void)
{
    ASSERT(0);
}

void TIM2_IRQHandler(void)
{
    ASSERT(0);
}

void TIM3_IRQHandler(void)
{
    ASSERT(0);
}

void TIM4_IRQHandler(void)
{
    ASSERT(0);
}

void I2C1_EV_IRQHandler(void)
{
    ASSERT(0);
}

void I2C2_ER_IRQHandler(void)
{
    ASSERT(0);
}

void SPI1_IRQHandler(void)
{
    ASSERT(0);
}

void SPI2_IRQHandler(void)
{
    ASSERT(0);
}

void USART3_IRQHandler(void)
{
    ASSERT(0);
}

void EXTI15_10_IRQHandler(void)
{
    ASSERT(0);
}

void RTCAlarm_IRQHandler(void)
{
    ASSERT(0);
}

void OTG_FS_WKUP_IRQHandler(void)
{
    ASSERT(0);
}

void TIM5_IRQHandler(void)
{
    ASSERT(0);
}


void SPI3_IRQHandler(void)
{
    ASSERT(0);
}


void UART4_IRQHandler(void)
{
    ASSERT(0);
}


void UART5_IRQHandler(void)
{
    ASSERT(0);
}


void TIM6_IRQHandler(void)
{
    ASSERT(0);
}


void TIM7_IRQHandler(void)
{
    ASSERT(0);
}


void DMA2_Channel1_IRQHandler(void)
{
    ASSERT(0);
}


void DMA2_Channel2_IRQHandler(void)
{
    ASSERT(0);
}


void DMA2_Channel3_IRQHandler(void)
{
    ASSERT(0);
}


void DMA2_Channel4_IRQHandler(void)
{
    ASSERT(0);
}


void DMA2_Channel5_IRQHandler(void)
{
    ASSERT(0);
}


void ETH_IRQHandler(void)
{
    ASSERT(0);
}

void ETH_WKUP_IRQHandler(void)
{
    ASSERT(0);
}


void CAN2_TX_IRQHandler(void)
{
    ASSERT(0);
}


void CAN2_RX0_IRQHandler(void)
{
    ASSERT(0);
}


void CAN2_RX1_IRQHandler(void)
{
    ASSERT(0);
}


void CAN2_SCE_IRQHandler(void)
{
    ASSERT(0);
}


void OTG_FS_IRQHandler(void)
{
    ASSERT(0);
}

void RTC_IRQHandler()
{
    RTC_TimeTypeDef zeroTime = {0};

    if (RTC_GetITStatus(RTC_IT_ALRA) != RESET)
    {
        RTC_ClearITPendingBit(RTC_IT_ALRA);

        RTC_TimeStructInit(&zeroTime);
        RTC_SetTime(RTC_Format_BIN, &zeroTime);

        QEvt* pEvt = Q_NEW(QEvt, TIMER_FEED_WD_SIG);
        SendToServer(MAIN_APP_ID, (QEvt*)pEvt);
    }
    if(EXTI_GetITStatus(EXTI_Line17) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line17);
    }
}

/* When input 20seconds, RTC accurary execute every 16seconds
 * Is it a STM32 bug?
 */
void RTC_SetUpWakeUpAlarm(uint8 seconds)
{
    RTC_TimeTypeDef  alarmTime = {0};
    RTC_AlarmTypeDef alarm     = {0};
    RTC_TimeTypeDef  zeroTime  = {0};

    RTC_TimeStructInit(&alarmTime);
    RTC_AlarmStructInit(&alarm);
    RTC_TimeStructInit(&zeroTime);

    alarmTime.RTC_Seconds = seconds;
    RTC_SetTime(RTC_Format_BIN, &zeroTime);

    alarm.RTC_AlarmTime = alarmTime;
    alarm.RTC_AlarmMask = RTC_AlarmMask_DateWeekDay | RTC_AlarmMask_Hours | RTC_AlarmMask_Minutes;

    RTC_SetAlarm(RTC_Format_BIN, RTC_Alarm_A, &alarm);

    RTC_OutputConfig(RTC_Output_Disable, RTC_OutputPolarity_Low);
    RTC_ITConfig(RTC_IT_ALRA, ENABLE);
    RTC_AlarmCmd(RTC_Alarm_A, ENABLE);
    RTC_ClearFlag(RTC_FLAG_ALRAF);
}

void RTC_Initialize()
{
    RTC_InitTypeDef rtc = {0};
    EXTI_InitTypeDef exti = {0};
    NVIC_InitTypeDef NVIC_InitStructure = {0};

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);

    PWR_BackupAccessCmd(ENABLE);

    RCC_BackupResetCmd(ENABLE);
    RCC_BackupResetCmd(DISABLE);

    RCC_LSICmd(ENABLE);
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
    RCC_RTCCLKCmd(ENABLE);

    RTC_StructInit(&rtc);

    /*
        ck_spre = RTCCLK/((PREDIV_A+1) * (PREDIV_B+1))
        40kHz/(99+1)*(399+1) = 1
    */
    rtc.RTC_AsynchPrediv = 0x63;
    rtc.RTC_SynchPrediv  = 0x18F;

    RTC_Init(&rtc);

    EXTI_ClearITPendingBit(EXTI_Line17);

    EXTI_StructInit(&exti);
    exti.EXTI_Line = EXTI_Line17;
    exti.EXTI_Mode = EXTI_Mode_Interrupt;
    exti.EXTI_Trigger = EXTI_Trigger_Rising;
    exti.EXTI_LineCmd = ENABLE;
    EXTI_Init(&exti);

    NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

/**
  * @brief ISTR events interrupt service routine
  * @param  None
  * @retval None
  */
void USB_IRQHandler(void)
{
    __IO uint16_t wIstr = _GetISTR() & DCD_GetIMR();

    if (wIstr & ISTR_CTR)
    {
        /* servicing of the endpoint correct transfer interrupt
         * clear of the CTR flag into the sub
        */
        DCD_Ctr();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_RESET)
    {
        _SetISTR((uint16_t)CLR_RESET);
        DCD_Reset();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_DOVR)
    {
        _SetISTR((uint16_t)CLR_DOVR);
        DCD_DmaOverUnderRun();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_ERR)
    {
        _SetISTR((uint16_t)CLR_ERR);
        DCD_ErrorsHandler();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_WKUP)
    {
        _SetISTR((uint16_t)CLR_WKUP);
        DCD_Resume();

    #ifdef LPM_ENABLED    
        /* clear L1 remote wakeup flag */
        L1_remote_wakeup = 0;
    #endif
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_SUSP)
    {
        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
        _SetISTR((uint16_t)CLR_SUSP);

        /* process library core layer suspend routine*/
        DCD_Suspend();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_SOF)
    {
        _SetISTR((uint16_t)CLR_SOF);
        DCD_StartOfFrame();
    }
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
    if (wIstr & ISTR_ESOF)
    {
        /* clear ESOF flag in ISTR */
        _SetISTR((uint16_t)CLR_ESOF);
        DCD_EndOfFrame();
    }

#ifdef LPM_ENABLED  
    if (wIstr & ISTR_L1REQ)
    {
        /* clear L1REQ flag in ISTR */
        _SetISTR((uint16_t)CLR_L1REQ);

        /* read BESL field which coressponds to HIRD parameter in LPM spec*/
        /* In your application depending on BESL value, you can choose the right 
        low power mode during L1 state, allowing wakeup time within the request time from host.
        */
        BESL = (_GetLPMCSR() & LPMCSR_BESL) >> 4 ;

        /* read REMWAKE bit which corresponding to bRemoteWake bit in LPM request*/
        /* if this bit is set then L1 remote wakeup is possible */
        L1_remote_wakeup = (_GetLPMCSR() & LPMCSR_REMWAKE) >> 3;

        DCD_LpmRequest();
    }
#endif
} /* USB_Istr */



/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AseTkSrv.h"
#include "ADCDrv.h"
#include "I2CDrv.h"
#include "GPIODrv.h"
#include "DspDrv1451.h"
#include "AmpDrvTas5760.h"
#include "AudioDrv.config"
#include "pcm1862Drv.h"
#include "timer.h"


/***********************************************
 * Type
 ***********************************************/
typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},

};

typedef struct
{
    eAudioJackId    audioJackInId;
    eSettingId      jackSetId;
    bool            (*isJackInFunc)(void);
    eSettingId      musicDetSetId;
    bool            (*isMusicOnFunc)(void);
    bool            isJackStaOnChange;
}tMusicDection;

static tMusicDection musicDetection[] =
{
    {AUXIN_JACK,     SETID_IS_AUXIN_PLUG_IN,    &AudioDrv_IsAuxinJackPluggedIn, SETID_AUXIN_MUSIC_DET,    &AudioDrv_IsAuxinHasMusicOn,  FALSE},
    {SPDIF1_IN_JACK, SETID_IS_SPDIF_IN_PLUG_IN, &AudioDrv_IsOptJackPluggedIn,   SETID_SPDIF_IN_MUSIC_DET, &AudioDrv_IsOptHasMusicOn,    FALSE},
    /* For source from ASE-TK */
    //{JACK_IN_INVALID,SETID_ASETK_CONNECTED,     &AudioDrv_IsAsetkPluggedIn,     SETID_ASETK_MUSIC_DET,    &AudioDrv_IsAsetkHasMusicOn,  INVALID_VALUE},
};

/***********************************************
 * Global Variable
 ***********************************************/
static cI2CDrv      dspI2cObj;
static cDSPDrv1451 DspADAU1451Drv;

static cI2CDrv      ampWooferI2cObj;
static cAudioAmpDrv audioAmpWooferDrv;

static cI2CDrv      ampMidI2cObj;
static cAudioAmpDrv audioAmpMidDrv;

static cI2CDrv          adcPcm1862i2cObj;
static cAdcDrv_pcm1862  adcPcm1862;

/*static */cGpioDrv gpioAudio;

static bool audioOverheat= FALSE;

cADCDrv adcAudio;

static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static int32 jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;

static uint32 ampTempCheckTimer = AUDIO_AMP_TEMP_CHECK_TIME;
static uint32 ampErrorCheckTimer = AUDIO_AMP_ERROR_CHECK_TIME;


static uint16 volFadeTimerId= 0;

static tVolFadeParam volFadeParam= {0};

static eAudioChannel currentAudioChannel = AUDIO_CHANNEL_INVALID;

/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds (after ASE-TK MCLK is ready),
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);
    audioOverheat = FALSE;

    //Initialize Audio GPIO pins
    gpioAudio.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(gpioAudio.gpioConfig);
    GpioDrv_Ctor(&gpioAudio, gpioAudio.gpioConfig);

    //Initialize Audio ADC pins
    adcAudio.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(adcAudio.ADCConfig);
    ADCDrv_Ctor(&adcAudio, adcAudio.ADCConfig);
    
    //Initialize DSP
    dspI2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cObj.pConfig);
    DSPDrv1451_Ctor(&DspADAU1451Drv, &dspI2cObj);

    //Shutdown all amplifier
    AMP_SHUTDOWN(gpioAudio); //pull low SDZ
            
    //Enable power for DSP/AMP/NTC
    SYSPWR_ENABLE(gpioAudio);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    AudioAmpDrv_Xtor(&audioAmpWooferDrv);
    AudioAmpDrv_Xtor(&audioAmpMidDrv);
    AdcDrv_pcm1862_Xtor(&adcPcm1862);
    DSPDrv1451_Xtor(&DspADAU1451Drv);
    
    //Shutdown all amplifier
    AMP_SHUTDOWN(gpioAudio); //pull low SDZ
    //Disable power for DSP/AMP/NTC
    SYSPWR_DISABLE(gpioAudio);

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {        
        if(me->nextDelayTime == 0)
        {
            //Enable power for ADC/DSP/AMP/NTC
            SYSPWR_ENABLE(gpioAudio);
        }

        me->nextDelayTime = DSPDrv1451_Init(&DspADAU1451Drv);
        if(me->nextDelayTime == 0) 
        {
            //Read DSP Version
            float fVer= DSPDrv1451_GetDspVer(&DspADAU1451Drv);
            char dspVersion[DSP_VERSION_LENGTH]= {0};
            snprintf(dspVersion, sizeof(dspVersion), "%0.1f", fVer);
            Setting_Set(SETID_DSP_VER, dspVersion);

            //Initialize ADC: PCM1862
            adcPcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(AUDIO_ADC_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(adcPcm1862i2cObj.pConfig);
            AdcDrv_pcm1862_Ctor(&adcPcm1862, &adcPcm1862i2cObj);
            AdcDrv_pcm1862_Init(&adcPcm1862);
            AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_INPUT1); //select input from differential
            AdcDrv_pcm1862_SetPGA(&adcPcm1862, PCM1862_PGA_9dB);
            AdcDrv_pcm1862_enableAGC(&adcPcm1862, /*enable:*/FALSE); //AGC feature have problem on MOFA, should disable it
            AdcDrv_pcm1862_enableMute(&adcPcm1862, TRUE); //mute by default

            //Initialize Woofer Amplifier
            TP_PRINTF("Init Woofer Amplifier\r\n");
            ampWooferI2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_WOOFER_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampWooferI2cObj.pConfig);
            AudioAmpDrv_Ctor(&audioAmpWooferDrv, &ampWooferI2cObj);

            //Initialize Mid Amplifier
            TP_PRINTF("Init Mid Amplifier\r\n");
            ampMidI2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(AMP_MIDDLE_1_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(ampMidI2cObj.pConfig);
            AudioAmpDrv_Ctor(&audioAmpMidDrv, &ampMidI2cObj);
            
            /* 1. Set amplifer to PBTL mode, means two output to one speaker
             * 2. Datasheet said, PBTL select right channel when REG[6].bit1==1, left chanel when REG[6].bit1==0.
             *    But accurary result is inverse.
             * 2. Vpk should < amplifier PVDD(15~24v), or analog output will clip on PVDD
             */
            //TODO: move this customization to attachedDevices.c
            AudioAmpDrv_setPbtlMode(&audioAmpWooferDrv, FALSE);
            AudioAmpDrv_setPwmRate(&audioAmpWooferDrv, ADC_PWM_RATE_12LRCK);
            AudioAmpDrv_setAnalogGain(&audioAmpWooferDrv, ANALOG_GAIN_22_6_DBV);
            AudioAmpDrv_setPbtlMode(&audioAmpMidDrv, FALSE);
            AudioAmpDrv_setAnalogGain(&audioAmpMidDrv, ANALOG_GAIN_22_6_DBV);
            AudioAmpDrv_setPwmRate(&audioAmpMidDrv, ADC_PWM_RATE_12LRCK);

            /* It is important to note that control port register changes should only occur when the device is placed into
             *  shutdown. This can be accomplished either by pulling the SPK_SD pin "LOW" or clearing the SPK_SD bit in the
             *  control port.
             */
            
            /* Pull SDZ to high after I2C programming */
            AMP_WAKEUP(gpioAudio);
            
            //AudioAmpDrv_printError(&audioAmpWoofer1Drv);
            AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/TRUE);

            /* Set default settings */
            jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            bool defaultValue = FALSE;
            Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultValue);
            Setting_Set(SETID_IS_SPDIF_IN_PLUG_IN, &defaultValue);
            Setting_Set(SETID_AUXIN_MUSIC_DET, &defaultValue);
            Setting_Set(SETID_SPDIF_IN_MUSIC_DET, &defaultValue);
            Setting_Set(SETID_ASETK_MUSIC_DET, &defaultValue);

            memset(&volFadeParam, 0, sizeof(volFadeParam));
            volFadeParam.isFadingInProg = FALSE;
            uint8 defaultVol = DEFAULT_VOLUME;
            Setting_Set(SETID_VOLUME, &defaultVol);

            uint8 defaultLevel = LINE_IN_SENSITIVITY_DISABLE;
            Setting_Set(SETID_LINEIN_SENSITIVITY_LEVEL, &defaultLevel);
            DSPDrv1451_SetLineInSensitivity(&DspADAU1451Drv, defaultLevel);

            AseFepSetPositionSoundModeReq soundMode = {0};
            Setting_Set(SETID_POSITION_SOUND_MODE, &soundMode);

            //Finish
            me->drvIsReady = TRUE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    currentAudioChannel = audioChannel;
    DSPDrv1451_SetInputChannel(&DspADAU1451Drv, audioChannel);

    //Fix Me: currently below code is just for test purpose.
    DSPDrv1451_SetLineInMultiRoomChannel(&DspADAU1451Drv, audioChannel);
}

void AudioDrv_SetLineInMultiRoomChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetLineInMultiRoomChannel(&DspADAU1451Drv, audioChannel);
}

//debug
void AudioDrv_dumpAmpReg(void)
{
    AudioAmpDrv_dumpReg(&audioAmpWooferDrv, "ampWoofer");
    AudioAmpDrv_dumpReg(&audioAmpMidDrv, "ampMid");
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *audioDrvObj)
{
    AudioDrv_AmpSafetyMonitor();
    AudioDrv_CheckJackInStatus();
    /* Update music status only if audio jack is NOT on changing. */
    if (musicDetection[0].isJackStaOnChange == FALSE && musicDetection[1].isJackStaOnChange == FALSE)
    {
        AudioDrv_CheckMusicStreamStatus();
    }
}

extern AseFepSetAudioInputReq_AudioInput gAseAudioInput;

void AudioDrv_CheckJackInStatus(void)
{
    uint8 i = 0;
    if ((jackDetTimer > 0) && ((jackDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0))
    {
        jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
        for( i = 0; i < ArraySize(musicDetection); i++)
        {
            bool isJackIn = (musicDetection[i].isJackInFunc)();
            bool preJackStatus = *(bool*)Setting_Get(musicDetection[i].jackSetId);
            if ((!musicDetection[i].isJackStaOnChange) && (isJackIn != preJackStatus))
            {
                AseFepSetAudioInputReq_AudioInput aseAudioInput = *(AseFepSetAudioInputReq_AudioInput*)Setting_Get(SETID_ASE_AUDIO_INPUT);
                if (musicDetection[i].audioJackInId == AUXIN_JACK &&
                    aseAudioInput == AseFepSetAudioInputReq_AudioInput_LINE) // if the current source is auxin .
                {
                    AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, TRUE);
                }
                musicDetection[i].isJackStaOnChange  = TRUE;
                DSPDrv1451_MuteLineInToAsetk(&DspADAU1451Drv, TRUE); // mute the I2S out from DSP to ASE-TK
                AdcDrv_pcm1862_enableMute(&adcPcm1862, TRUE); // mute the output of PCM1862
                jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_DEBOUNCE_TIME;
                break;
            }
            else if (musicDetection[i].isJackStaOnChange)
            {
                musicDetection[i].isJackStaOnChange = FALSE;

                if (isJackIn != preJackStatus)
                {
                    Setting_Set(musicDetection[i].jackSetId, &isJackIn);
                    TP_PRINTF("Jack Detect channel %d is %d\r\n", musicDetection[i].audioJackInId, isJackIn);
                    AudioJackinStateEvt* pAudioStateEvt = Q_NEW(AudioJackinStateEvt, AUDIO_STATE_SIG);
                    pAudioStateEvt->jackId = musicDetection[i].audioJackInId;
                    pAudioStateEvt->IsJackIn = isJackIn;
                    QF_PUBLISH(&pAudioStateEvt->super, me);
                }

                if (isJackIn)
                {
                    DSPDrv1451_MuteLineInToAsetk(&DspADAU1451Drv, FALSE); // Unmute the I2S out from DSP to ASE-TK
                    /* To avoid pop noise, only unmute the output of PCM1862 if the auxin jack plugged. */
                    if (musicDetection[i].audioJackInId == AUXIN_JACK)
                    {
                        AdcDrv_pcm1862_enableMute(&adcPcm1862, FALSE);
                    }

                    AseFepSetAudioInputReq_AudioInput aseAudioInput = *(AseFepSetAudioInputReq_AudioInput*)Setting_Get(SETID_ASE_AUDIO_INPUT);
                    if (musicDetection[i].audioJackInId == AUXIN_JACK &&
                        aseAudioInput == AseFepSetAudioInputReq_AudioInput_LINE) // if the current source is auxin .
                    {
                        AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, FALSE);
                    }
                }
                musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME; // reset the music detect timer.
            }
        }
    }
}

/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    uint8 i = 0;
    if ((musicDetTimer > 0) && ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0))
    {
        for( i = 0; i < ArraySize(musicDetection); i++)
        {
            bool isMusicOn = (musicDetection[i].isMusicOnFunc)();
            bool preStatus = *(bool*)Setting_Get(musicDetection[i].musicDetSetId);
            /* Note: we assumed if the jack is not plug-in, the music status is off. */
            bool jackStatus = *((bool*)Setting_Get(musicDetection[i].jackSetId));
            if(jackStatus && isMusicOn)
            {
                isMusicOn = TRUE;
            }
            else
            {
                isMusicOn = FALSE;
            }

            if (isMusicOn != preStatus)
            {
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;                
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->jackId = musicDetection[i].audioJackInId;
                pAudioMusicStateEvt->hasMusicStream = isMusicOn;
                QF_PUBLISH(&pAudioMusicStateEvt->super, NULL);

                Setting_Set(musicDetection[i].musicDetSetId, &isMusicOn);
                TP_PRINTF("Music Detect channel %d is %d\r\n", musicDetection[i].audioJackInId, isMusicOn);
            }
        }
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
    }
}

static void AudioDrv_SetFadeVolume(cAudioDrv *me, uint32 target_volume, uint32 fade_duration)
{
    if (volFadeParam.isFadingInProg == TRUE)
    {
        TP_PRINTF("    Volume fade: Stop previous fade volume and start new one\r\n");
        bool ret= Timer_StopTimer(volFadeTimerId);
        ASSERT(ret); //FALSE means Fade volume timer is not running
    }

    /* The start volume should always be equal to current volume. */
    uint8 start_volume = *(uint8*)Setting_Get(SETID_VOLUME);
    uint32 fadeRange = TYM_DIFF(target_volume, start_volume);
    /* fade_duration should not be less than ADUIO_MIN_FADE_STEP_TIME */
    if(fade_duration < ADUIO_MIN_FADE_STEP_TIME)
    {
        fade_duration= ADUIO_MIN_FADE_STEP_TIME;
    }
    
    if(((fadeRange <= (MAX_VOLUME - MIN_VOLUME)) && fadeRange > 0)
        && (target_volume >= MIN_VOLUME && target_volume <= MAX_VOLUME)
        && (start_volume >= MIN_VOLUME && start_volume <= MAX_VOLUME))
    {
        volFadeParam.fadeType     = (target_volume > start_volume)? TRUE : FALSE;
        volFadeParam.fadeStep     = ADUIO_MIN_FADE_STEP;
        volFadeParam.fadeStepTime = (fade_duration * volFadeParam.fadeStep)/fadeRange;
        volFadeParam.targetVol    = target_volume;
        volFadeParam.isFadingInProg = TRUE;
        if(ADUIO_MIN_FADE_STEP_TIME > volFadeParam.fadeStepTime)
        {
            volFadeParam.fadeStepTime = ADUIO_MIN_FADE_STEP_TIME;
            volFadeParam.fadeStep = (volFadeParam.fadeStepTime * fadeRange)/fade_duration;
            ASSERT(volFadeParam.fadeStep>0);
        }
        Timer_StartTimer((uint32)volFadeParam.fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, &volFadeParam);
    }
    else
    {
        TP_PRINTF("The volume fade parameters are invalid. \r\n");
        AseTkSrv_ReplyVolumeFade(start_volume); //reply current volume
    }
    

}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady)) {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch (audioSettId)
    {
        case DSP_VOLUME_SETT_ID:
            //TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_VOLUME_SETT_ID\r\n", audioSettId);
            if(!volFadeParam.isFadingInProg)
            {
                uint8 volume= (uint8)param;
                Setting_Set(SETID_VOLUME, &volume);
                AudioDrv_DspVolSetId_Handler();
            }
            break;

        case DSP_PASSTHROUGH_SETT_ID:
            DSPDrv1451_SetPassthrough(&DspADAU1451Drv, enabled);
            break;
        case SYSTEM_GAIN_SETT_ID:
            // CHANGE THE INPUT GAIN FOR ADC OR DSP
            break;
        case AMP_SLEEP_MODE_ID:
        {
            if(!audioOverheat)
            {
                char * pHwVer = (char *)Setting_Get(SETID_HW_VER);
                if (PowerDrv_IsHwSupported(pHwVer) == FALSE)
                {
                    TP_PRINTF("\r\n Note: as this HW is supported by current firmware, the AMP for woofer will always be muted to protect driver. \r\n\r\n");
                    AudioAmpDrv_setShutdown(&audioAmpWooferDrv, TRUE);
                }
                else
                {
                    AudioAmpDrv_setShutdown(&audioAmpWooferDrv, enabled);
                }
                AudioAmpDrv_setShutdown(&audioAmpMidDrv, enabled);
            }
            break;
        }
        case AUDIO_OVERHEAT_MODE_ID:
        {
            AudioDrv_SetOverheat(me, enabled);
            break;
        }
#ifdef HAS_DSP_TUNING_MODE
        case DSP_TUNNING_SETT_ID:
        {
            /* In DSP tuning mode, always power on and unmute amplifier */
            if (enabled)
            {
                AudioAmpDrv_setShutdown(&audioAmpMidDrv, FALSE);
                AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, FALSE);
                AudioDrv_SetChannel(AUDIO_CHANNEL_I2S_2); // auxin
            }
            /* DSP and AMP I2C bus should be disable when tuning DSP. */
            DSPDrv1451_I2cEnable(&DspADAU1451Drv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpWooferDrv, !enabled);
            AudioAmpDrv_I2cEnable(&audioAmpMidDrv, !enabled);
            break;
        }
#endif
        case AUDIO_VOL_FADE_SETT_ID:
        {
            uint32 target_volume= param;
            uint32 fade_duration= param2;
            AudioDrv_SetFadeVolume(me, target_volume, fade_duration);
            break;
        }
        case AUDIO_LINEIN_MULTI_ROOM_CHANNEL_SETT_ID:
        {
            eAudioChannel audioChannel = (eAudioChannel)param;
            AudioDrv_SetLineInMultiRoomChannel(audioChannel);
            break;
        }
        case AUDIO_LINEIN_SENSITIVITY_SETT_ID:
        {
            eLineinSensitivity lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
            switch ((AseFepSetLineInSensitivity_LineInSensitivity)param)
            {
                case AseFepSetLineInSensitivity_LineInSensitivity_HIGH:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_HIGH;
                    break;
                case AseFepSetLineInSensitivity_LineInSensitivity_MEDIUM:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_MEDIUM;
                    break;
                case AseFepSetLineInSensitivity_LineInSensitivity_LOW:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_LOW;
                    break;
                case AseFepSetLineInSensitivity_LineInSensitivity_DISABLED:
                    lineInSensitivityLvl = LINE_IN_SENSITIVITY_DISABLE;
                    break;
                default:
                    break;
            }
            uint8 level = (uint8)lineInSensitivityLvl;
            Setting_Set(SETID_LINEIN_SENSITIVITY_LEVEL, &level);
            DSPDrv1451_SetLineInSensitivity(&DspADAU1451Drv, lineInSensitivityLvl);
            break;
        }
        case AUDIO_RESET_LINEIN_JACK_AND_MUSIC_STA_SETT_ID:
        {
            uint8 i = 0;
            bool defaultValue = FALSE;
            for( i = 0; i < ArraySize(musicDetection); i++)
            {
                Setting_Set(musicDetection[i].jackSetId, &defaultValue);
                Setting_Set(musicDetection[i].musicDetSetId, &defaultValue);
            }
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            break;
        }
        case AUDIO_POS_SOUND_MODE_SETT_ID:
        {
            FepAsePositionSoundModeResp_Error ret = FepAsePositionSoundModeResp_Error_NO_ERROR;
            AseFepSetPositionSoundModeReq soundMode = *(AseFepSetPositionSoundModeReq *)Setting_Get(SETID_POSITION_SOUND_MODE);
            if (soundMode.mode.has_position)
            {
                //TODO: Need DSP support.
            }
            if (soundMode.mode.has_orientation)
            {
                //TODO: Need DSP support.
            }

            FepAsePositionSoundModeResp soundModeResp = {0};
            if (ret == FepAsePositionSoundModeResp_Error_NO_ERROR)
            {
                soundModeResp.has_error = FALSE; // no error
            }
            else
            {
                soundModeResp.has_error = TRUE; // error
            }
            soundModeResp.error = ret;
            soundModeResp.has_mode = soundMode.has_mode;
            soundModeResp.mode = soundMode.mode;
            AseTkSrv_ReplySetPositionSoundMode(soundModeResp);
            break;
        }
        default:
             break;
    }
}

static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
    /* get current volume value */
    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);

    //TP_PRINTF("AudioDrv_VolFadeTimerCallBack: fadeType=%d, step=%d, vol:(curr=%d,tgt=%d) \r\n", 
    //           pVolFadeParam->fadeType, pVolFadeParam->fadeStep, volLevel, pVolFadeParam->targetVol);
    
    ASSERT(pVolFadeParam->isFadingInProg==TRUE);

    /* For issue FS-202, sometimes AudioDrv_VolFadeTimerCallBack() repeated execute and set the same volume.
     * The only possible condition is fadeStep==0, but there is no reason for it.
     * Before find root cause, we add workaround here.
     */
    if(pVolFadeParam->fadeStep==0)
    {
        ASSERT(0);
        TP_PRINTF("\r\n\r\n\r\n*** ERROR: AudioDrv_VolFadeTimerCallBack fadeStep==0 ***\r\n\r\n\r\n\r\n");
        return;
    }
    
    /* change volume*/
    if(pVolFadeParam->fadeType)
    {
        /* volume fade up*/
        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = MAX_VOLUME;
        }
        else
        {
            volLevel += pVolFadeParam->fadeStep;
        }
    }
    else
    {
        /* volume fade down*/
        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
        {
            volLevel = MIN_VOLUME;
        }
        else
        {
            volLevel -= pVolFadeParam->fadeStep;
        }
    }
    Setting_Set(SETID_VOLUME, &volLevel);
    AudioDrv_DspVolSetId_Handler();

    if((volLevel != pVolFadeParam->targetVol)
        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
    {
        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
    }
    else
    {
        /* Reply Ase-tk when volume fade completed. */
        AseTkSrv_ReplyVolumeFade(volLevel);
        pVolFadeParam->isFadingInProg = FALSE;
        TP_PRINTF("    Volume fade: finish, vol=%d\r\n", volLevel);
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    ASSERT(muteType < AUDIO_MUTE_TYPE_MAX);
    switch (muteType)
    {
        case AUDIO_AMP_SOFT_MUTE:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_AMP_SOFT_MUTE, muteEnable=%d\n\r", muteEnable);
            char * pHwVer = (char *)Setting_Get(SETID_HW_VER);
            if (PowerDrv_IsHwSupported(pHwVer) == FALSE)
            {
                TP_PRINTF("\r\n Note: as this HW is supported by current firmware, the AMP for woofer will always be muted to protect driver. \r\n\r\n");
                AudioAmpDrv_setSoftMute(&audioAmpWooferDrv, TRUE);
            }
            else
            {
                AudioAmpDrv_setSoftMute(&audioAmpWooferDrv, muteEnable);
            }
            AudioAmpDrv_setSoftMute(&audioAmpMidDrv, muteEnable);
            break;
        }
        case AUDIO_AMP_SOFT_MUTE_MID:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_AMP_SOFT_MUTE_MID, muteEnable=%d\n\r", muteEnable);
            AudioAmpDrv_setSoftMuteLeftChannel(&audioAmpMidDrv, muteEnable);
            break;
        }
        case AUDIO_AMP_SOFT_MUTE_TW1:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_AMP_SOFT_MUTE_TW1, muteEnable=%d\n\r", muteEnable);
            AudioAmpDrv_setSoftMuteRightChannel(&audioAmpMidDrv, muteEnable);
            break;
        }
        case AUDIO_AMP_SOFT_MUTE_TW2:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_AMP_SOFT_MUTE_TW2, muteEnable=%d\n\r", muteEnable);
            AudioAmpDrv_setSoftMuteLeftChannel(&audioAmpWooferDrv, muteEnable);
            break;
        }
        case AUDIO_AMP_SOFT_MUTE_WF:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_AMP_SOFT_MUTE_WF, muteEnable=%d\n\r", muteEnable);
            char * pHwVer = (char *)Setting_Get(SETID_HW_VER);
            if (PowerDrv_IsHwSupported(pHwVer) == FALSE)
            {
                TP_PRINTF("\r\n Note: as this HW is supported by current firmware, the AMP for woofer will always be muted to protect driver. \r\n\r\n");
                AudioAmpDrv_setSoftMuteRightChannel(&audioAmpWooferDrv, TRUE);
            }
            else
            {
                AudioAmpDrv_setSoftMuteRightChannel(&audioAmpWooferDrv, muteEnable);
            }
            break;
        }
        case AUDIO_DSP_LINEOUT_MUTE:
        {
            TP_PRINTF("AudioDrv_Mute: muteType=AUDIO_DSP_LINEOUT_MUTE, muteEnable=%d\n\r", muteEnable);
            DSPDrv1451_MuteLineInToAsetk(&DspADAU1451Drv, muteEnable);
            break;
        }
        default:
            //Support only soft mute
            //ASSERT(0);
            break;
    }
}

static uint16 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint8 degreeC;

    for (degreeC = 0; degreeC < TEMPERATURE_POSITIONS_NUM; degreeC++)
    {
        if (ntcValue > audioNtcTempTable[degreeC])
        {
            break;
        }
    }
    return degreeC;
}

static void AudioDrv_SetOverheat(cAudioDrv *me, bool overheat)
{  
    /* audioOverheat occurs: Shutdown ampliifer for over-heat
     * recover from audioOverheat: do nothing, but allow MainApp to wakeup amplifier
     */
    TP_PRINTF("AudioDrv_SetOverheat: overheat=%d\r\n", overheat);
    audioOverheat= overheat;
    if(overheat) 
    {
        AMP_SHUTDOWN(gpioAudio);
    }
    else
    {
        AMP_WAKEUP(gpioAudio);
    }
}

/**
 * Function to monitor the amp status
 */
void AudioDrv_AmpSafetyMonitor()
{
    AMP_TempMonitor();
    AudioDrv_AmpHealthMonitor();
}

/**
 * Function to update amplifier temperature.
 */
static void AMP_TempMonitor()
{
    int16 rawResult = 0;
    int16 temperature = 0;
    int16 wfNTC = 0;
    int16 twNTC = 0;
    int16 amp1NTC = 0;
    int16 amp2NTC = 0;

    if (ampTempCheckTimer > 0)
    {
        if ((ampTempCheckTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            /* update Amplifier 1 temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, ADC_AMP1_NTC);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_AMP1_TEMP, &temperature);

            /* update Amplifier 2  temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, ADC_AMP2_NTC);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_AMP2_TEMP, &temperature);

            /* update woofer temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, ADC_WF_NTC);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_WF_TEMP, &temperature);

            /* update Mid temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, ADC_TW_NTC);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_MID_TEMP, &temperature);

            /* Scan for new values */
            ADCDrv_StartScanning(&adcAudio);
            ampTempCheckTimer = AUDIO_AMP_TEMP_CHECK_TIME;
        }
    }

    //Print every 5sec (AUDIO_PRINT_PREIOD_IN_MS)
    static int32 timeoutTick= 0;
    timeoutTick--;
    if(timeoutTick<=0)
    {
        timeoutTick= AUDIO_PRINT_PREIOD_IN_MS / AUDIO_SRV_TIMEOUT_IN_MS;

        temperature =*(int16*)Setting_GetEx(SETID_AMP1_TEMP, &temperature);
        TP_PRINTF("Amp 1 temp:%d \r\n", temperature);

        temperature =*(int16*)Setting_GetEx(SETID_AMP2_TEMP, &temperature);
        TP_PRINTF("Amp 2 temp:%d \r\n", temperature);

        //temperature =*(int16*)Setting_GetEx(SETID_WF_TEMP, &temperature);
        //TP_PRINTF("Woofer temp:%d \r\n", temperature);

        //temperature =*(int16*)Setting_GetEx(SETID_MID_TEMP, &temperature);
        //TP_PRINTF("Mid temp:%d \r\n", temperature);
     }
}

/**
 * Function to update amplifier error status.
 */
static void AudioDrv_AmpHealthMonitor(cAudioDrv *me)
{
    bool amp_health = (uint32)GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AMP_FAULTZ);
    bool ampWoofer_error = FALSE;
    bool ampMid_error = FALSE;
    if (ampErrorCheckTimer > 0)
    {
        if ((ampErrorCheckTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            if (!amp_health) /* if amp error happen */
            {
                /* update Amplifier error status */
                AudioAmpDrv_getErrorStatus(&audioAmpWooferDrv,  &ampWoofer_error);
                AudioAmpDrv_getErrorStatus(&audioAmpMidDrv, &ampMid_error);
                TP_PRINTF("\r\n*** AMP_HEALTH: WF:0x%x, Mid:0x%x ***\r\n", ampWoofer_error, ampMid_error);
            }

            /* byte[1]: woofer amplifier reason 
             * byte[0]: tweeter amplifier reason 
             */
            uint32 ampErrorReason= (ampWoofer_error<<8) | ampMid_error;
            Setting_Set(SETID_AMP_ERROR_REASON, &ampErrorReason);
            Setting_Set(SETID_AMP_HEALTH, &amp_health);

            ampErrorCheckTimer = AUDIO_AMP_ERROR_CHECK_TIME;
        }
    }
}

static void AudioDrv_DspVolSetId_Handler(void)
{
    uint8 volumeLevel = MIN_VOLUME;

    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);
    if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
    {
        DSPDrv1451_SetVol(&DspADAU1451Drv, volumeLevel);
    }
    else
    {
        ASSERT(0);
    }    
}

static bool AudioDrv_IsAsetkPluggedIn(void)
{
    return *((bool*)Setting_Get(SETID_ASETK_CONNECTED));
}
/*
* Not plug:     DET1 = HIGH, DET2 = HIGH
* Auxin plug:   DET1 = LOW, DET2 = LOW
* Optical plug: DET1 = LOW, DET2 = HIGH
*/
static bool AudioDrv_IsAuxinJackPluggedIn(void)
{
    bool ret;
    int8 det1 = GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AUDIO_JACK_DET1);
    int8 det2 = GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AUDIO_JACK_DET2);
    ret = ((!det1) && (!det2)); 
    return ret;
}

static bool AudioDrv_IsOptJackPluggedIn(void)
{
    bool ret;
    int8 det1 = GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AUDIO_JACK_DET1);
    int8 det2 = GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AUDIO_JACK_DET2);
    ret = ((!det1) && (det2)); 
    return ret;
}

static bool AudioDrv_IsAsetkHasMusicOn(void)
{
    return DSPDrv1451_HasMusicStream(&DspADAU1451Drv);;
}

static bool AudioDrv_IsAuxinHasMusicOn(void)
{
    return DSPDrv1451_AuxinHasMusicStream(&DspADAU1451Drv);;
}

static bool AudioDrv_IsOptHasMusicOn(void)
{
    return DSPDrv1451_SpdifInHasMusicStream(&DspADAU1451Drv);;
}


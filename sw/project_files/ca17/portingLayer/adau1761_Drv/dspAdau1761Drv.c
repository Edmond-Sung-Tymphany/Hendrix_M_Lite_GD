/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  dsp 1761 driver
                  -------------------------

                  SW Module Document




@file        dsp_adau1761_driver.c
@brief       This file implements the drivers for adau1761
@author      Jerry Guo,Edmond Sung, Bob.Xu
@date        2014-08-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-17     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :

Change History:
VERSION    : 2    DRAFT      2014-09-28     Daniel.Duan, Bob.Xu
DESCRIPTION: Refactor audio sever, to add BT tone support
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include <stdio.h>
#include <math.h>
#include "trace.h"
#include "cplus.h"
#include "commonTypes.h"
#include "I2CDrv.h"
#include "SettingSrv.h"
#include "DspDrv1761.h"
#include "timer.h"
#include "./dspAdau1761Drv_priv.h"
#include "./ADAU1761_IC_1.h"
#include "./ADAU1761_IC_1_PARAM.h"
#include "./ADAU1761_IC_1_REG.h"
#include "DspDrv.Conf"
#include "adau1761_config.h"
#include "GPIODrv.h"
#include "attachedDevices.h"

#ifndef NULL
#define NULL                             (0)
#endif


#define DspDrv1761_DEBUG_ENABLE
#ifndef DspDrv1761_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif



void DSPDrv1761_WriteDcValue32_0(cDSPDrv1761 *me, uint16 reg_addr, int32 data);
void DSPDrv1761_WriteValue5_23(cDSPDrv1761 *me, uint16 reg_addr, float fValue);
float DSPDrv1761_ReadValue5_23(cDSPDrv1761 *me, uint16 reg_addr);


static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out);
static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out);
static float DSPDrv1761_DataToFloat(cDSPDrv1761 *me, uint32 data, uint8 fmt_num, uint8 fmt_frac);

static int16 *pSettData;
static cDSPDrv1761 * pDspObj;
static BOOL          isPhaseInited = FALSE;
static uint16 phaseTimer = INVALIDE_TIMER;
static cGpioDrv gpioDsp;

/* 
 * Issue: ASEII-586, CAXVII-26 
 *
 * On CA17 EVT HW, DSP is sometimes unstable (no sound or crazy sound). The reason is
 * MCU can not pull down VCC3V3 thus DSP can not full reset
 *
 * On CA17 DVT HW (with buffer IC to split ASE MCLK/I2S pins), it is resolved with timing
 *    {&DspDrv1761_PowerOnSeq0,  100}, //turn off VCC, disable I2S
 *    {&DspDrv1761_PowerOnSeq1,  100}, //turn on VCC, enable I2S
 *    {&DspDrv1761_PowerOnSeq2,  1},   //dummy
 *
 * But DSP is always "no sound" after ASE/FEP software upgrade. Thus apply new timing, 
 * the fail rate (after software upgrade) is <=1%. For this 1% fail, when detect DSP unstable, 
 * CA17 will flash 3sec RED led then reboot
 *    {&DspDrv1761_PowerOnSeq0,  300},  //turn on VCC, disable I2S
 *    {&DspDrv1761_PowerOnSeq1,  2000}, //turn off VCC. Voltage drop down very slow, must have 2sec here
 *    {&DspDrv1761_PowerOnSeq2,  300},  //turn on VCC, enable I2S
 *
 * To simulate issue, we can set timing:
 *    {&DspDrv1761_PowerOnSeq0,  1},  //turn on VCC, disable I2S
 *    {&DspDrv1761_PowerOnSeq1,  1},  //turn off VCC. Voltage drop down very slow, must have 2sec here
 *    {&DspDrv1761_PowerOnSeq2,  1},  //turn on VCC, enable I2S
 *
 */
static tDspInitSection DspInitSection[]=
{
    {&DspDrv1761_PowerOnSeq0,  300},  //turn on VCC, disable I2S
    {&DspDrv1761_PowerOnSeq1,  2000}, //turn off VCC. Voltage drop down very slow, must have 2sec here
    {&DspDrv1761_PowerOnSeq2,  300},  //turn on VCC, enable I2S
    {&DspDrv1761_InitSection0, 50},
    {&DspDrv1761_InitSection1, 100},
    {&DspDrv1761_InitSection2, 50},
};


static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
   /* DSP setting ID  index of setting db*/
   {DSP_VOLUME_SETT_ID,  DB_INDEX_OF_VOL},
};


void DSPDrv1761_Ctor(cDSPDrv1761 * me, cI2CDrv *pI2cObj)
{
    me->i2cObj        = pI2cObj;
    me->pInitTable    = DspInitSection;
    me->sectionSize   = ArraySize(DspInitSection);
    me->initPhase     = 0;
    me->max_vol       = MAX_VOLUME;
    me->default_vol   = DEFAULT_VOLUME;
    me->isCreated     = TRUE;
    
    eHwVer hwVerIndex= (eHwVer)( *(uint32 *)Setting_Get(SETID_HW_VER_INDEX) );
    if( hwVerIndex>=HW_TYPE_EVT2 ) //old sample: ES, EVT
    {
        me->deviceAddr= DSP_I2C_ADDR_ES_EVT;
    }
    else //new sample: DVT, MP
    {
        me->deviceAddr= DSP_I2C_ADDR_DVT_MP;
    }
    
#ifdef HAS_MENU
    pSettData         = (int16*)Setting_Get(SETID_MENU_DATA);
#endif
    pDspObj           = me;
    me->i2cEnable     = TRUE;
}


void DSPDrv1761_Xtor(cDSPDrv1761 * me)
{
    DSP_VCC_OFF(gpioDsp);
    DSP_I2S_DISABLE(gpioDsp);

    I2CDrv_Xtor(me->i2cObj);
    
    me->pInitTable    = NULL;
    me->sectionSize   = 0;
    me->initPhase     = 0;
    me->isCreated     = FALSE;
    me->i2cEnable     = FALSE;
}


uint16 DSPDrv1761_Init(cDSPDrv1761 * me)
{
    uint16 delaytime;
    ASSERT(me);
    me->pInitTable[me->initPhase].initSectionFunc(me);
    delaytime = me->pInitTable[me->initPhase].delaytime;
    me->initPhase++;
    if (me->initPhase == me->sectionSize)
    {
        me->initPhase = 0;
        return 0;
    }
    return (delaytime);
}

/**
 * Mutes the DSP DAC output
 *
 * @param      void
 * @return     void
 */
void DSPDrv1761_Mute(cDSPDrv1761 *me, eAudioMuteType muteType, BOOL muteEnable)
{
    uint8 mixer_lr = 0;//mixer LR_RIGHT
    uint8 mixer_ll = 0;//mixer LR_LEFT
    uint8  temp[3] = {0};
    ASSERT(me->deviceAddr);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_LEFT_ADDR,  MIXER_REG_LENGTH, (uint8*)&mixer_ll);
    DspDrv1761_I2cRead(me, PLAYBACK_LR_RIGHT_ADDR, MIXER_REG_LENGTH, (uint8*)&mixer_lr);
    switch(muteEnable)
    {
    case TRUE:
      {
        mixer_ll = (mixer_ll & 0xFD); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
        mixer_lr = (mixer_lr & 0xF7); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
      }
      break;
    case FALSE:
      {
        mixer_ll = (mixer_ll | 0x02); //Disable Mixer
        temp[0] = (PLAYBACK_LR_LEFT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_LEFT_ADDR & 0x00ff;
        temp[2] = mixer_ll;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
        mixer_lr = (mixer_lr | 0x08); //Disable Mixer;
        temp[0] = (PLAYBACK_LR_RIGHT_ADDR & 0xff00) >> 8;
        temp[1] = PLAYBACK_LR_RIGHT_ADDR & 0x00ff;
        temp[2] = mixer_lr;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
      }
      break;
    }
}

/**
 * Set volume
 *
 * @param      uint8        target volume
 * @return     void
 */
static void DSPDrv1761_SetVol(cDSPDrv1761 *me, uint8 vol)
{
    //printf("vol= %d\r\n", vol);	
    uint8 vol_iic[ADAU1761_UPDATE_VOLUME_LEN] = {0,0,0,0,0,0}; /* write DSP register */
    uint32 reg_addr= ADAU1761_VOLUME_CONTROL_ADDR;

    if(vol > MAX_VOLUME)
    {
        vol = MAX_VOLUME;
        ASSERT(0);
    }
    else if(vol < MIN_VOLUME)
    {
        vol = MIN_VOLUME;
        ASSERT(0);
    }

    vol_iic[0] = reg_addr >> 8;
    vol_iic[1] = reg_addr & 0x00FF;
    vol_iic[2] = 0;
    vol_iic[3] = 0;
    vol_iic[4] = 0;
    vol_iic[5] = vol;

    DspDrv1761_I2cWrite(me, ADAU1761_UPDATE_VOLUME_LEN, (uint8*)vol_iic);
}






/**
* Audio related setting intrance
* @param[in]    me             dsp object
* @param[in]    dspSettId      dsp setting ID
* @param[in]    enable         disable or enable the settings
*/
//void DSPDrv1761_SetAudio(cDSPDrv1761 *me, eAudioSettId dspSettId, BOOL enable)
//{
//    uint8 i;
//    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
//    {
//        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
//        {
//            break;
//        }
//    }
//    ASSERT(dspSettId < DSP_SETT_ID_MAX);
//    switch(dspSettId)
//    {
//      case DSP_VOLUME_SETT_ID:
//        {
//          if(enable)
//          {
//            /* Convert it to positive */
//            uint8 volume = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION+MAX_VOLUME;
//            DSPDrv1761_SetVol(me,volume);
//          }
//          else
//          {
//            DSPDrv1761_SetVol(me,0);
//          }
//        }
//        break;
//      case DSP_EQ_CTRL_RGC:
//        {
//          uint16        freq;
//          eUserRGCSlope slope;
//          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
//          slope = (eUserRGCSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
//          DspDrv1761_SetRGC(me, freq, slope, enable);
//        }
//        break;
//      case DSP_EQ_CTRL_USER_LP:
//        {
//          uint16         freq;
//          eUserLpSlope  slope;
//          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
//          slope = (eUserLpSlope)((pSettData[(ctrIdEQIdMap[i].dbIndex)+1])/VALUE_MAGNIFICATION);
//          DspDrv1761_SetUserLp(me, freq, slope, enable);
//        }
//        break;
//      case DSP_EQ_CTRL_USER_HP:
//        {
//          uint16         freq;
//          eUserHpSlope  slope;
//          freq  = (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION;
//          slope = (eUserHpSlope)((pSettData[ctrIdEQIdMap[i].dbIndex+1])/VALUE_MAGNIFICATION);
//          DspDrv1761_SetUserHp(me, freq, slope, enable);
//        }
//        break;
//      case DSP_EQ_CTRL_PEQ1:
//      case DSP_EQ_CTRL_PEQ2:
//      case DSP_EQ_CTRL_PEQ3:
//        DspDrv1761_SetPeq(me, dspSettId, i, enable);
//        break;
//      case DSP_PHASE_SETT_ID:
//        DspDrv1761_SetPhase(me, (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION);
//        break;
//      case DSP_POLARITY_SETT_ID:
//        DspDrv1761_SetPolarity(me, (ePolarityType)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
//        break;
//      case DSP_TUNNING_SETT_ID:
//        DspDrv1761_SetTuning(me, (eTuningRange)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
//        break;
//      default:break;
//    }
//}
void DSPDrv1761_SetAudio(cDSPDrv1761 *me, eAudioSettId dspSettId, BOOL enable)
{
    uint8 i;
    for(i = 0; i < ArraySize(ctrIdEQIdMap); i++)
    {
        if(dspSettId == ctrIdEQIdMap[i].dspSettid)
        {
            break;
        }
    }
    switch(dspSettId)
    {
      case DSP_VOLUME_SETT_ID:
        {
            uint8 volumeLevel =  *(uint8*)Setting_Get(SETID_VOLUME);
            DSPDrv1761_SetVol(me,volumeLevel);
        }
        break;
      case DSP_EQ_CTRL_RGC:
        {
        }
        break;
      case DSP_EQ_CTRL_USER_LP:
        {
        }
        break;
      case DSP_EQ_CTRL_USER_HP:
        {
        }
        break;
      case DSP_EQ_CTRL_PEQ1:
      case DSP_EQ_CTRL_PEQ2:
      case DSP_EQ_CTRL_PEQ3:
//        DspDrv1761_SetPeq(me, dspSettId, i, enable);
        break;
      case DSP_PHASE_SETT_ID:
//        DspDrv1761_SetPhase(me, (pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION);
        break;
      case DSP_POLARITY_SETT_ID:
//        DspDrv1761_SetPolarity(me, (ePolarityType)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
        break;
      case DSP_TUNNING_SETT_ID:
//        DspDrv1761_SetTuning(me, (eTuningRange)((pSettData[ctrIdEQIdMap[i].dbIndex])/VALUE_MAGNIFICATION));
        break;
      default:break;
    }
}

void DspDrv1761_SetLimiter(cDSPDrv1761 *me, int16 limiterLevel)
{
//   uint8 *coefficientArray = NULL;
//   switch(limiterLevel)
//   {
//     case LIMITER_LEVEL_MINUS_20_DB:
//       coefficientArray = limiter_minus_20;
//       break;
//     case LIMITER_LEVEL_MINUS_22_DB:
//       coefficientArray = limiter_minus_22;
//       break;
//     case LIMITER_LEVEL_MINUS_24_DB:
//       coefficientArray = limiter_minus_24;
//       break;
//     case LIMITER_LEVEL_MINUS_26_DB:
//       coefficientArray = limiter_minus_26;
//       break;
//     case LIMITER_LEVEL_MINUS_28_DB:
//       coefficientArray = limiter_minus_28;
//       break;
//     case LIMITER_LEVEL_MINUS_30_DB:
//       coefficientArray = limiter_minus_30;
//       break;
//     default:
//       {
//          ASSERT(0);
//          break;
//       }
//   }
//   SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, LIMITER_COEFFICIENT_CTRL_ADDRESS, LIMITER_COEFFICIENT_DATA_SIZE, coefficientArray);
}
/************************************************************
**************private functions******************************
*************************************************************/
static void DspDrv1761_I2cRead(cDSPDrv1761 *me, uint32 regAddr, uint16 bytes, const uint8 *data)
{
    if(!me->i2cEnable) {
        return;
    }
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = regAddr,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };
    I2CDrv_MasterRead(me->i2cObj, &i2cMsg);
}

/**
 * Write data to DSP by I2C.
 *
 * @param      uint8           device I2C address
 *
 * @param      uint8           data byte number
 *
 * @param      const uint8*    pointer to data array
 *
 * @return     void
 */
static void DspDrv1761_I2cWrite(cDSPDrv1761 *me, uint8 bytes, const uint8 *data)
{
    if(!me->i2cEnable) {
        return;
    }
    tI2CMsg i2cMsg =
    {
        .devAddr = me->deviceAddr,
        .regAddr = NULL,
        .length  = bytes,
        .pMsg    = (uint8*)data
    };

//    I2CDrv_MasterWrite(me->i2cObj, &i2cMsg);
    bool ret= I2CDrv_MasterWrite(me->i2cObj, &i2cMsg);
    ASSERT(ret==TP_SUCCESS);

}

//static void SIGMA_WRITE_REGISTER_BLOCK(uint8 device_add, uint16 reg_add, uint16 bytes, const uint8* data)
//{
//    ASSERT(bytes <= MAX_TX_DATA); /* Note: the size should not more than ADAU1451_REGISTER_LEN. */
//    uint8 buffer[MAX_TX_DATA];
//    tI2CMsg i2cMsg=
//    {
//        .devAddr = device_add,
//        .regAddr = NULL,
//        .length = bytes+2
//    };
//    buffer[0]=((reg_add&0xff00)>>8);
//    buffer[1]=(reg_add&0x00ff);
//    memcpy(&buffer[2], data, bytes);
//    i2cMsg.pMsg = &buffer[0];
//    I2CDrv_MasterWrite(pDspObj->i2cObj, &i2cMsg);
//}

static void DSPDrv1761_Writer_Register(cDSPDrv1761* me, uint32 regAddr, uint16 size, const uint8 *pData)
{
    uint8 buffer[2+ADAU1761_MAX_TX_BYTES];
    ASSERT(size<=ADAU1761_MAX_TX_BYTES); /* Note: the size should not more than ADAU1451_REGISTER_LEN. */

    buffer[0]=(regAddr>>8);
    buffer[1]=(regAddr&0xff);
    memcpy(&buffer[2], pData, size);
    DspDrv1761_I2cWrite(me, (2+size), (uint8*)buffer);
}

/**
 * Safeload process
 *
 * @param      uint8                data length in word(4 bytes)
 * @param      uint8*               data array
 * @param      uint16               target address
 * @return     void
 */
static void DspDrv1761_SafeLoadData(cDSPDrv1761 *me, uint8 num, const uint8 *array, uint16 addr)
{
    uint8  temp[6] = {0};
    uint16 curr_ptr;
    uint8  currIdx, curr_cnt;
    ASSERT(me->deviceAddr);
    ASSERT((num <= SAFE_LOAD_DATA_SIZE_MAX) && (num > 0));
    /* step1: set modulo size */
    curr_ptr = SAFE_LOAD_MODULO_SIZE_ADD;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    curr_ptr++;
    currIdx = 0;
    /* step2: write safeload data */
    while(currIdx < num * 4)
    {
        temp[0] = (curr_ptr & 0xff00) >> 8;
        temp[1] = curr_ptr & 0x00ff;
        for(curr_cnt = 0; curr_cnt < 4; curr_cnt++)
        {
            temp[curr_cnt + 2] = array[currIdx];
            currIdx++;
        }
        curr_ptr++;
        DspDrv1761_I2cWrite(me, sizeof(temp), temp);
    }

    curr_ptr = SAFE_LOAD_ADD_FOR_TARGET_ADD;

    /* step3: write target addr */
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[2] = 0;
    temp[3] = 0;
    temp[4] = (((addr - 1)& 0xff00) >> 8);
    temp[5] = (addr - 1) & 0x00ff;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);

    /* step4: trigger safeload */
    curr_ptr++;
    temp[0] = (curr_ptr & 0xff00) >> 8;
    temp[1] = curr_ptr & 0x00ff;
    temp[5] = num;
    DspDrv1761_I2cWrite(me, sizeof(temp), temp);
}

static void DspDrv1761_SetPolarity(cDSPDrv1761 *me, ePolarityType polarityType)
{
    uint8    temp[4] = {0};
    uint8    polarityChannel[4] = {0};
    /* get addr */

    temp[0] = 0x00;
    temp[1] = 0x80;
    temp[2] = 0x00;
    temp[3] = 0x00;
    if(polarityType == POLARITY_NEGATIVE)
    {
        temp[0] = 0xFF;
    }
//    DspDrv1761_I2cRead(me, POLARITY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&polarityChannel);
    if(polarityChannel[3] == POLARITY_CHANNEL_0)
    {
        polarityChannel[3] = POLARITY_CHANNEL_1;
//        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_1_ADDRESS);
    }
    else if(polarityChannel[3] == POLARITY_CHANNEL_1)
    {
        polarityChannel[3] = POLARITY_CHANNEL_0;
//        DspDrv1761_SafeLoadData(me, 1, temp, POLARITY_CHANNEL_0_ADDRESS);
    }
//    DspDrv1761_SafeLoadData(me, 1, polarityChannel, POLARITY_CHANNEL_CTRL_ADDRESS);
}


static void DspDrv1761_SetPhaseCB(void * pCbPara)
{
    uint8    delayChannel[4] = {0};

//    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(isPhaseInited)
    {
        if(delayChannel[3] == DELAY_CHANNEL_0)
        {
            delayChannel[3] = DELAY_CHANNEL_1;
        }
        else if(delayChannel[3] == DELAY_CHANNEL_1)
        {
            delayChannel[3] = DELAY_CHANNEL_0;
        }
    }
    isPhaseInited = TRUE;
//    DspDrv1761_SafeLoadData(pDspObj, 1, delayChannel, DELAY_CHANNEL_CTRL_ADDRESS);
    phaseTimer = INVALIDE_TIMER;
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */
static void DspDrv1761_SetPhase(cDSPDrv1761 *me, uint8 phaseShift)
{
    uint8    delayChannel[4] = {0};
    uint8    temp[4] = {0};
    uint16   tmp = 0;
    tmp = phaseShift * MAX_DELAY_SAMPLES;
    temp[0] = 0x00;
    temp[1] = 0x00;
    temp[2] = ((tmp/180)& 0xff00) >> 8;
    temp[3] = (tmp/180)& 0x00ff;
    if(phaseShift == 0)
    {
        temp[3] = NO_PHASE_SHIFT;
    }
    if(phaseTimer != INVALIDE_TIMER)
    {
        Timer_StopTimer(phaseTimer);
    }
//    DspDrv1761_I2cRead(pDspObj, DELAY_CHANNEL_CTRL_ADDRESS, 4, (uint8*)&delayChannel);
    if(delayChannel[3] == DELAY_CHANNEL_0)
    {
//        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_1_ADDRESS);
    }
    else if(delayChannel[3] == DELAY_CHANNEL_1)
    {
//        DspDrv1761_SafeLoadData(me, 1, temp, DELAY_CHANNEL_0_ADDRESS);
    }
    Timer_StartTimer(600,&phaseTimer, DspDrv1761_SetPhaseCB, NULL);
}


static void DspDrv1761_PowerOnSeq0(void *p)
{
    //Initialize DSP GPIO pins
    gpioDsp.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(DSP_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(gpioDsp.gpioConfig);
    GpioDrv_Ctor(&gpioDsp, gpioDsp.gpioConfig);

    //turn off VCC, disable I2S
    DSP_VCC_ON(gpioDsp);
    DSP_I2S_DISABLE(gpioDsp);
}

static void DspDrv1761_PowerOnSeq1(void *p)
{
    DSP_VCC_OFF(gpioDsp);
}

static void DspDrv1761_PowerOnSeq2(void *p)
{
    DSP_VCC_ON(gpioDsp);
    DSP_I2S_ENABLE(gpioDsp);
}

static void DspDrv1761_InitSection0(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection0\r\n");
    cDSPDrv1761 * me = (cDSPDrv1761*)p;
    const tDevice * pDevice = NULL;
    pDevice = getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(pDevice);
    I2CDrv_Ctor(me->i2cObj,(tI2CDevice*)pDevice);
    me->i2cObj->registeredUser++;
}

static void DspDrv1761_InitSection1(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection1\r\n");
    cDSPDrv1761* me = (cDSPDrv1761*)p;
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R0_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R1_DSP_RUN_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLKCTRLREGISTER_IC_1_ADDR, REG_CLKCTRLREGISTER_IC_1_BYTE, R2_CLKCTRLREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLLCRLREGISTER_IC_1_ADDR, REG_PLLCRLREGISTER_IC_1_BYTE, R3_PLLCRLREGISTER_IC_1_Default );
}

static void DspDrv1761_InitSection2(void *p)
{
    //TP_PRINTF("DspDrv1761_InitSection2\r\n");
    cDSPDrv1761* me = (cDSPDrv1761*)p;
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_CONTROL_0_IC_1_ADDR , R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_SIZE, R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ALC_CONTROL_0_IC_1_ADDR , R6_ALC_CONTROL_REGISTERS_IC_1_SIZE, R6_ALC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_MICCTRLREGISTER_IC_1_ADDR, REG_MICCTRLREGISTER_IC_1_BYTE, R7_MICCTRLREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_RECORD_PWR_MANAGEMENT_IC_1_ADDR , R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ADC_CONTROL_0_IC_1_ADDR , R9_ADC_CONTROL_REGISTERS_IC_1_SIZE, R9_ADC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLAYBACK_MIXER_LEFT_CONTROL_0_IC_1_ADDR , R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CONVERTER_CTRL_0_IC_1_ADDR , R11_CONVERTER_CONTROL_REGISTERS_IC_1_SIZE, R11_CONVERTER_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DAC_CONTROL_0_IC_1_ADDR , R12_DAC_CONTROL_REGISTERS_IC_1_SIZE, R12_DAC_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_PAD_CONTROL_0_IC_1_ADDR , R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_COMM_PORT_PAD_CTRL_0_IC_1_ADDR , R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_JACKREGISTER_IC_1_ADDR, REG_JACKREGISTER_IC_1_BYTE, R15_JACKREGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_ENABLE_REGISTER_IC_1_ADDR, REG_DSP_ENABLE_REGISTER_IC_1_BYTE, R21_DSP_ENABLE_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CRC_IDEAL_1_IC_1_ADDR , R22_CRC_REGISTERS_IC_1_SIZE, R22_CRC_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_GPIO_0_CONTROL_IC_1_ADDR , R23_GPIO_REGISTERS_IC_1_SIZE, R23_GPIO_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_NON_MODULO_RAM_1_IC_1_ADDR , R24_NON_MODULO_REGISTERS_IC_1_SIZE, R24_NON_MODULO_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_WATCHDOG_ENABLE_IC_1_ADDR , R25_WATCHDOG_REGISTERS_IC_1_SIZE, R25_WATCHDOG_REGISTERS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R26_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_INPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_INPUTS_IC_1_BYTE, R27_ROUTING_MATRIX_INPUTS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_OUTPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_OUTPUTS_IC_1_BYTE, R28_ROUTING_MATRIX_OUTPUTS_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_ADDR, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_BYTE, R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_SLEW_MODES_IC_1_ADDR, REG_DSP_SLEW_MODES_IC_1_BYTE, R30_DSP_SLEW_MODES_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_BYTE, R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLOCK_ENABLE_REG_0_IC_1_ADDR , R32_CLOCK_ENABLE_REGISTERS_IC_1_SIZE, R32_CLOCK_ENABLE_REGISTERS_IC_1_Default );
	uint16 i;
    for(i = 0; i * 5 < PROGRAM_SIZE_IC_1; i++)
    {
       SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1+i, 5, &Program_Data_IC_1[i*5] ); /* 40 bit dsp prgram ram, 64*4 = 256 bytes */
    }
    for(i = 0; i * 4 < PARAM_SIZE_IC_1; i++)
    {
        SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PARAM_ADDR_IC_1+i, 4, &Param_Data_IC_1[i*4] ); /* 32 bit dsp prgram ram */
    }
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R35_SAMPLE_RATE_SETTING_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R36_DSP_RUN_REGISTER_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R37_DEJITTER_REGISTER_CONTROL_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R38_DEJITTER_REGISTER_CONTROL_IC_1_Default );
}


/**
 * Format input int32 data array into array of uint8, according to the designated number of int32
 *
 * @param      int32*          start address of the input int32 array
 *
 * @param      uint8*          output data array pointer
 *
 * @param      uint8           number of input int32 data
 *
 * @return     void
 */
static void DspDrv1761_FormatFiltData(int32* in, uint8* out, uint8 num)
{
    uint32        temp;
    uint8          cnt;
    int32*        ptr0;
    uint8*        ptr1;

    ptr0 = in;
    ptr1 = out;

    for(cnt = 0; cnt < num; cnt++)
    {
        temp  = (uint32)(*ptr0);
        *ptr1 = (uint8)((temp >> 24) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 16) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)((temp >> 8) & 0xFF);
        ptr1++;
        *ptr1 = (uint8)(temp & 0xFF);
        ptr1++;
        ptr0++;
    }
}

/**
 * This function is used to convert filter Parameter (Q factor, center freq, etc) into 5 DSP parameters
 *
 * @param   tDspFiltRawParam                 the filter parameter raw input
 * @param   uint8*                           pointer to the output data
 * @return  void
 */
static void DspDrv1761_CalFiltParam(tDspFiltRawParam in, uint8* out)
{
    /* calculate common param for all filter */
    double w0 = 2.0*PI*in.freq/DSP_SAMPLING_FREQ;
    double A = pow(10.0, in.boost/40.0);
    double gainLinear = pow(10.0, in.gain/20.0);
    double a0, a1, a2, b0, b1, b2, S, alpha;
    int32  temp[EQ_CTRL_RAM_SLOT_NUM];

    S = in.q;
    if(in.en == FALSE)
    {
        temp[0] = 0x00800000;
        temp[1] = 0x00000000;
        temp[2] = 0x00000000;
        temp[3] = 0x00000000;
        temp[4] = 0x00000000;
        /* change the data from int32 to uint8 */
        DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
        return;
    }
    else if(in.q == 0)
    {
        S = 0.05;
    }

    switch(in.dspFiltType)
    {
#ifdef HAS_PEAKING_FILTER
        case FILTER_TYPE_PEAKING:
        {
            alpha = sin(w0) / (2.0 * S);

            a0 = 1.0 + alpha / A;
            a1 = -2.0 * cos(w0);
            a2 = 1.0 - alpha / A;
            b0 = (1.0 + alpha * A) * gainLinear;
            b1 = - ( 2.0 * cos(w0)) * gainLinear;
            b2 = ( 1.0 - A * alpha) * gainLinear;

            /*  speical behavior when speical inputs
             *  (inspired by Sigma Studio outputs)
             * */
            if(in.boost == 0.00)
            {
                b1=0;
                b2=0;
                a1=0;
                a2=0;
            }
            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_LOW_SHELF_FILTER
        case FILTER_TYPE_TONE_LOW_SHELF:
        {
            alpha = (sin(w0)/ 2 ) * sqrt( ( A + 1/A ) * ( 1 / S - 1) + 2);
            a0 = (A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 =  -2*( (A-1) + (A+1)*cos(w0) );
            a2 = (A+1) + (A-1)*cos(w0) - 2*sqrt(A)*alpha;
            b0 =  A*( (A+1) - (A-1)*cos(w0) + 2*sqrt(A)*alpha ) * gainLinear;
            b1 = 2*A*( (A-1) - (A+1)*cos(w0) ) * gainLinear;
            b2 =  A*( (A+1) - (A-1)*cos(w0) - 2*sqrt(A)*alpha ) * gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_TONE_HIGH_SHELF_FILTER
        case FILTER_TYPE_TONE_HIGH_SHELF:
        {
            alpha = (sin(w0)/2)*sqrt((A+1/A)*(1/S-1)+2);
            a0 = (A+1)-(A-1)*cos(w0)+2*sqrt(A)*alpha;
            a1 = 2*((A-1)-(A+1)*cos(w0));
            a2 = (A+1)-(A-1)*cos(w0)-2*sqrt(A)*alpha;
            b0 = A*((A+1)+(A-1)*cos(w0)+2*sqrt(A)*alpha)*gainLinear;
            b1 = -2*A*((A-1)+(A+1)*cos(w0))*gainLinear;
            b2 = A*((A+1)+(A-1)*cos(w0)-2*sqrt(A)*alpha)*gainLinear;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_LOW_PASS_FILTER
        case FILTER_TYPE_GENERAL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = (1-cos(w0))*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_GENERAL_HIGH_PASS_FILTER
        case FILTER_TYPE_GENERAL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0*S);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_LOW_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_LOW_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BUTTWORTH_HIGH_PASS_FILTER
        case FILTER_TYPE_BUTTWORTH_HIGH_PASS:
        {
            alpha = sin(w0)/sqrt(2.0);
            a0 = 1.0+alpha;
            a1 = -2.0*cos(w0);
            a2 = 1.0-alpha;
            b0 = (1.0+cos(w0))*gainLinear/2.0;
            b1 = -(1.0+cos(w0))*gainLinear;
            b2 = (1.0+cos(w0))*gainLinear/2.0;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_LOW_PASS_FILTER
        case FILTER_TYPE_BESSEL_LOW_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1-cos(w0))*gainLinear/2;
            b1 = 1-cos(w0)*gainLinear;
            b2 = (1-cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_BESSEL_HIGH_PASS_FILTER
        case FILTER_TYPE_BESSEL_HIGH_PASS:
        {
            alpha = sin(w0)/(2.0/sqrt(3.0));
            a0 = 1.0+alpha;
            a1 = -2*cos(w0);
            a2 = 1-alpha;
            b0 = (1+cos(w0))*gainLinear/2;
            b1 = -1*(1+cos(w0))*gainLinear;
            b2 = (1+cos(w0))*gainLinear/2;

            /* normalization */
            a1 /= a0;
            a2 /= a0;
            b0 /= a0;
            b1 /= a0;
            b2 /= a0;

            /* inverton on a1, a2 */
            a1 = -a1;
            a2 = -a2;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_LOW_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_LOW_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * (1.0 - a1);
            b1 = 0;
            b2 = 0;
        }
        break;
#endif
#ifdef HAS_FIRST_ORDER_HIGH_PASS_FILTER
        case FILTER_TYPE_FIRST_ORDER_HIGH_PASS:
        {
            a0 = 1.0;
            a1 = pow(2.7, (0-w0));
            a2 = 0;
            b0 = gainLinear * a1;
            b1 = 0 - b0;
            b2 = 0;
        }
        break;
#endif
        default:
        {
            /* wrong data in */
            ASSERT(0);
        }
        break;
    }

    /* check data */
    ASSERT((a1 > -16.0) && (a1 < 15.99));
    ASSERT((a2 > -16.0) && (a2 < 15.99));
    ASSERT((b0 > -16.0) && (b0 < 15.99));
    ASSERT((b1 > -16.0) && (b1 < 15.99));
    ASSERT((b2 > -16.0) && (b2 < 15.99));

    /* feed into output structure */
    temp[0] = (int32)(b0*(1L << 23));
    temp[1] = (int32)(b1*(1L << 23));
    temp[2] = (int32)(b2*(1L << 23));
    temp[3] = (int32)(a1*(1L << 23));
    temp[4] = (int32)(a2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}


void DspDrv1761_SetI2Smode(cDSPDrv1761 *me, BOOL isMaster)
{
    ASSERT(me && me->isCreated);
    
    //read
    uint8   data_read[1] = {0};
    DspDrv1761_I2cRead(me, ADAU1761_I2S_CONTROL_ADDR, sizeof(data_read), data_read);    
    if(isMaster)
    {
        TYM_SET_BIT(data_read[0], 0x1);
    }
    else
    {
        TYM_CLR_BIT(data_read[0], 0x1);
    }
    
    //write
    uint8 data_write[3] = {0};
    uint32 reg_addr= ADAU1761_I2S_CONTROL_ADDR;
    data_write[0] = reg_addr >> 8;
    data_write[1] = reg_addr & 0x00FF;
    data_write[2] = data_read[0];
    DspDrv1761_I2cWrite(me, sizeof(data_write), (uint8*)data_write);
}


/**
 * Set BGC
 *
 * @param      int8            boost
 * @param      bool            enable or disable
 * @return     void
 */
static void DspDrv1761_SetRGC(cDSPDrv1761 *me, uint16 freq, eUserRGCSlope slope, bool en)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8             currIdx;
    uint32            regAddress = 0x10;//RGC_CTRL_ADDRESS; TODO: fix it!

    rawData.freq        = freq;
    rawData.boost       = RGC_BOOST;
    rawData.gain        = RGC_GAIN;
    rawData.q           = RGC_QFACTOR;
    rawData.en          = en;
    rawData.dspFiltType = FILTER_TYPE_BUTTWORTH_HIGH_PASS;

    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);
        /* check slope */
    switch(slope)
    {
        case USER_RGC_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_RGC_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        default:
            ASSERT(0);
            break;
    }

    uint8 i = 0;
    for(i = 0; i < NUM_OF_RGC_SET_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me,EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }
        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}


static void DspDrv1761_CalculateFirstOrder(cDSPDrv1761 *me,uint16 freq, uint8* out)
{
    double w,G1,a11,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];

    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    G1 = w/(w+1);
    a11 = (w-1)/(w+1);

    B0 = G1;
    B1 = G1;
    B2 = 0;
    A1 = -a11;
    A2 = 0;

    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}


static void DspDrv1761_CalculateSecondOrder(cDSPDrv1761 *me,uint16 freq, double delta, uint8* out)
{
    double w,G2,a21,a22,alpha,B0,B1,B2,A1,A2;
    int32 temp[EQ_CTRL_RAM_SLOT_NUM];

    w = tan(PI*freq/DSP_SAMPLING_FREQ);
    alpha = (1 - 2*w*delta + w*w);
    G2 = w*w / alpha;
    a21 = -(2 * (w*w - 1) / alpha);
    a22 = -((1 + 2*w*delta + w*w) / alpha);

    B0 = G2;
    B1 = 2*G2;
    B2 = G2;
    A1 = a21;
    A2 = a22;

    /* feed into output structure */
    temp[0] = (int32)(B0*(1L << 23));
    temp[1] = (int32)(B1*(1L << 23));
    temp[2] = (int32)(A1*(1L << 23));
    temp[3] = (int32)(B2*(1L << 23));
    temp[4] = (int32)(A2*(1L << 23));

     /* change the data from int32 to uint8 */
    DspDrv1761_FormatFiltData(temp, out, EQ_CTRL_RAM_SLOT_NUM);
}

/**
 * Set User LP
 *
 * @param      int8            boost
 * @param      eUserLpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserLp(cDSPDrv1761 *me, uint16 freq, eUserLpSlope slope, bool en)
{
    double delta2 = cos(3*PI/4);
    double delta3 = cos(4*PI/6);
    double delta4_1 = cos(5*PI/8);
    double delta4_2 = cos(7*PI/8);
    double delta = 0;
    uint8 finalData[EQ_CTRL_RAM_BYTE_NUM];
    int32 bypassData[5];
    bypassData[0] = 0x00800000;
    bypassData[1] = 0x00000000;
    bypassData[2] = 0x00000000;
    bypassData[3] = 0x00000000;
    bypassData[4] = 0x00000000;
    memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
    if(en)
    {
        finalData[3] = 0x01;
//        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
    }
    else
    {
//        DspDrv1761_SafeLoadData(me, 1, finalData, LP_SWITCH_ADDRESS);
        return;
    }
    /* check slope */
    switch(slope)
    {
        case USER_LP_SLOPE_6DB:

            DspDrv1761_CalculateFirstOrder(me,freq,finalData);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_12DB:
            delta = delta2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_FormatFiltData(bypassData, finalData, EQ_CTRL_RAM_SLOT_NUM);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_18DB:
            delta = delta3;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            DspDrv1761_CalculateFirstOrder(me,freq,finalData);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS+5);
            break;
        case USER_LP_SLOPE_24DB:
            delta = delta4_1;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
//            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, LP_CTRL_ADDRESS);
            memset(finalData,0x00,EQ_CTRL_RAM_BYTE_NUM);
            delta = delta4_2;
            DspDrv1761_CalculateSecondOrder(me, freq, delta, finalData);
//            DspDrv1761_SafeLoadData(me, 5, finalData, LP_CTRL_ADDRESS+5);
            break;
        default:
            ASSERT(0);
            break;
    }
}

/**
 * Set User HP
 *
 * @param      int8            boost
 * @param      eUserHpSlope    slope
 * @param      bool            en
 * @return     void
 */
static void DspDrv1761_SetUserHp(cDSPDrv1761 *me, uint16 freq, eUserHpSlope slope, bool en)
{
    tDspFiltRawParam     rawData;
    uint8                finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8                currIdx;
    uint32               regAddress = 0x11;//HP_CTRL_ADDRESS; fix it!

    rawData.freq         = freq;
    rawData.boost        = USER_HP_BOOST;
    rawData.gain         = USER_HP_GAIN;
    rawData.q            = USER_HP_QFACTOR;
    rawData.en           = en;
    rawData.dspFiltType  = FILTER_TYPE_FIRST_ORDER_HIGH_PASS;


    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);

    /* check slope */
    switch(slope)
    {
        case USER_HP_SLOPE_6DB:
            currIdx = CTR_ADDR_GROUP_1;
            break;

        case USER_HP_SLOPE_12DB:
            currIdx = CTR_ADDR_GROUP_2;
            break;

        case USER_HP_SLOPE_18DB:
            currIdx = CTR_ADDR_GROUP_3;
            break;

        case USER_HP_SLOPE_24DB:
            currIdx = CTR_ADDR_GROUP_4;
            break;

        default:
            ASSERT(0);
            break;
    }
    ASSERT(currIdx < EQ_CTRL_NUM);
    uint8 i = 0;
    for(i = 0; i < NUM_OF_FILTER_ADD; i++)
    {
        if(i < currIdx)
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
        }
        else
        {
            DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, eqBypassData, regAddress);
        }
        regAddress += EQ_CTRL_RAM_SLOT_NUM;
    }
}

/**
 * Set Tuning
 *
 * @param      eTuningRange           range
 * @return     void
 */
static void DspDrv1761_SetTuning(cDSPDrv1761 *me, eTuningRange range)
{
    tDspFiltRawParam  rawData;
    uint8             finalData[EQ_CTRL_RAM_BYTE_NUM];

    rawData.freq      = TUNING_FREQ;
    rawData.gain      = TUNING_GAIN;
    rawData.q         = TUNING_QFACTOR;
    rawData.dspFiltType = FILTER_TYPE_BUTTWORTH_HIGH_PASS;

    /* check range */
    switch(range)
    {
        case TUNING_RANGE_20HZ:
            rawData.boost = TUNING_BOOST0;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_16HZ:
            rawData.boost = TUNING_BOOST1;
            rawData.en    = TRUE;
            break;

        case TUNING_RANGE_SEALED:
            rawData.en    = FALSE;
            break;

        default:
            ASSERT(0);
            break;
    }

    /* cal out the EQ data */
    DspDrv1761_CalFiltParam(rawData, finalData);
//    DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, TUNNING_ADDRESS);
}

/**
 * Set PEQ
 *
 * @param      eDspSettId       dsp setting ID
 * @param      uint8            the setting position in ctrIdEQIdMap
 * @param      enable           Enable or disable the settings
 */
static void DspDrv1761_SetPeq(cDSPDrv1761 *me, eAudioSettId dspSettId,uint8 settIndex, BOOL enable)
{
    tDspFiltRawParam rawData;
    uint8            finalData[EQ_CTRL_RAM_BYTE_NUM];
    uint8            currIdx;
    uint32           regAddress = 0x12;//PEQ_CTRL_ADDRESS; fix it!

    rawData.gain  = PARAM_EQ_GAIN;
    rawData.freq = (pSettData[ctrIdEQIdMap[settIndex].dbIndex])/VALUE_MAGNIFICATION;
    rawData.boost = ((double)(pSettData[ctrIdEQIdMap[settIndex].dbIndex+1]))/VALUE_MAGNIFICATION;;
    rawData.q = (pSettData[ctrIdEQIdMap[settIndex].dbIndex+2])/VALUE_MAGNIFICATION;;
    rawData.en = enable;
    rawData.dspFiltType = FILTER_TYPE_PEAKING;

    DspDrv1761_CalFiltParam(rawData, finalData);

    switch(dspSettId)
    {
        case DSP_EQ_CTRL_PEQ1:
          {
            currIdx = ADDR_OFFSET_0;
          }
            break;
        case DSP_EQ_CTRL_PEQ2:
          {
            currIdx = ADDR_OFFSET_1;
          }
            break;

        case DSP_EQ_CTRL_PEQ3:
          {
            currIdx = ADDR_OFFSET_2;
          }
            break;

        default:
            ASSERT(0);
            break;
    }
    ASSERT(currIdx < EQ_CTRL_NUM);
    uint8 i = 0;
    while(i < PARAMETRIC_EQ_MAX)
    {
      if(i == currIdx)
      {
          /* Set the right parametric EQ */
          DspDrv1761_SafeLoadData(me, EQ_CTRL_RAM_SLOT_NUM, finalData, regAddress);
      }
      regAddress += EQ_CTRL_RAM_SLOT_NUM;
      i++;
    }
}


/**
 * Set delay
 *
 * @param      uint8       phase shift 0-180
 * @return     void
 */

/*
 * Below are the public functions which are not used in SVS but have to
 * be declared to supress compiling errors
 */

BOOL DSPDrv1761_IsAuxin(cDSPDrv1761 *me)
{
    return FALSE;
}


/**
 * Read signal level for sig detection
 *
 * @param      N/A
 * @return     float float version
 */

void DSPDrv1761_GetSigLevel(cDSPDrv1761 *me, float *fSigLev)
{
    int8 result = -1;
    ASSERT(me && me->isCreated);

    uint8   data[DSP_VER_REGISTER_LEN] = {0};
    DspDrv1761_I2cRead(me, ADAU1761_AUXIN_SIG_DETECT_ADDR, sizeof(data), data);
    float res = 0.0;
    
    /* RMS table of ADAU1761 can only store 5.23 float (around -16.0~16.0), it can not report 
     * correct dB (-90~+6). Thus we let RMS table divide by 10, the resul tis -9.0~+6.0).
     */
    *fSigLev = (10.0*DSPDrv1761_DataToFloat(me, UINT32_BYTE_INV(data), 5,23 )); //format 5.23
}


void DSPDrv1761_SetInputChannel(cDSPDrv1761 *me, eAudioChannel inputChannel)
{
//    DSPDrv1761_Mute(me, AUDIO_AMP_SOFT_MUTE, TRUE);
    TP_PRINTF("DSP: input=%d (%s)\r\n", inputChannel, ((inputChannel==AUDIO_CHANNEL_I2S_1)?"ASE":"AuxIn-Local"));
    const uint8 * ctrData = NULL;
    switch (inputChannel)
    {
        case AUDIO_CHANNEL_I2S_1: //9, ASE
        {
            ctrData = ADAU1451_DIGITAL_INPUT_1_SELECT;
            break;
        }
        case AUDIO_CHANNEL_I2S_2: //10, AUX-IN
        {
            ctrData = ADAU1451_DIGITAL_INPUT_2_SELECT;
            break;
        }
        default:
        {
            ASSERT(0);
            break;
        }
    }

    if(ctrData)
    {
        DspDrv1761_I2cWrite(me, SOURCE_SELECT_REGISTER_LEN, (uint8*)ctrData);
    }

}


void DSPDrv1761_SetAuxinMute(cDSPDrv1761 *me, bool auxin_mute)
{
    TP_PRINTF("DSP: auxin-mute=%d\r\n", auxin_mute);
    const uint8 * ctrData = NULL;
    if( auxin_mute )
    {
        ctrData = ADAU1451_DIGITAL_LINEIN_MUTE_SELECT;
    }
    else
    {
        ctrData = ADAU1451_DIGITAL_LINEIN_UNMUTE_SELECT;
    }
    
    DspDrv1761_I2cWrite(me, SOURCE_LINEIN_MUTE_CONTROL_REGISTER_LEN, (uint8*)ctrData);    
}


void DSPDrv1761_SetToneTouchEnable(cDSPDrv1761 *me, bool enable)
{
    const uint8 * ctrData = NULL;
    if( enable )
    {
        ctrData = TONE_TOUCH_ENABLE_SELECT;
    }
    else
    {
        ctrData = TONE_TOUCH_BYPASS_SELECT;
    }
    
    DspDrv1761_I2cWrite(me, TONE_TOUCH_ENABLE_CONTROL_REGISTER_LEN, (uint8*)ctrData);    
}

/**
 * Set Speaker Position
 * @param  -    position
 */
void DSPDrv1761_SetSpeakerPosition(cDSPDrv1761 *me, eSpeakerPosition position)
{
    TP_PRINTF("DSPDrv1761_SetSpeakerPosition: position=%d\r\n", position);
    const uint8 * ctrData = NULL;
    switch (position)
    {
        case SPEAKER_POSITION_FREE:
        {
            ctrData = ADAU1451_SPEAKER_POSITION_FREE;
            break;
        }
        case SPEAKER_POSITION_WALL:
        {
            ctrData = ADAU1451_SPEAKER_POSITION_WALL;
            break;
        }
        case SPEAKER_POSITION_CORNER:
        {
            ctrData = ADAU1451_SPEAKER_POSITION_CORNER;
            break;
        }
        default:
        {
            ASSERT(0);
            break;
        }
    }

    if(ctrData)
    {
        DspDrv1761_I2cWrite(me, SPEAKER_POSITION_SWITCH_REGISTER_LEN, (uint8*)ctrData);
    }
}



/**
 * Convert DSP float raw data to float number
 *
 * @param      data: float data with DSP format
 *             fmt_num: Numeric nubmer of DSP format
 *             fmt_frac: Fraction nubmer of DSP format
 *
 * @note       not support negative value
 *            
 * @return     starnard float number
 *
 * @Example,
 * Numerical Format: (fmt_num).(fmt_frac)
 */
static float DSPDrv1761_DataToFloat(cDSPDrv1761 *me, uint32 data, uint8 fmt_num, uint8 fmt_frac)
{
    ASSERT((fmt_num+fmt_frac) <= 32);
    uint8 sign_bit= fmt_num + fmt_frac - 1;
    uint32 sign_value= UINT32_GET_BIT(data, sign_bit);
    ASSERT(sign_bit > fmt_frac);
    uint32 value_uint= UINT32_GET_BIT_RANGE(data, sign_bit-1, fmt_frac);
    float value_float= 0.0;
    if(sign_value==0)
    {   //positive number
        value_float= (float)value_uint;
    }
    else
    {   //negative number
        uint32 value_max= 2<<(fmt_num-2);  //2^fmt_num
        value_float= -(float)(value_max-value_uint);
    }

    float f= 1;
    for(int32 i=fmt_frac-1 ; i>=0 ; i--)
    {
        f/= 2;
        if(UINT32_GET_BIT_RANGE(data, i, i)) {
            value_float+= f;
            //TP_PRINTF("value_float=%f\r\n", value_float);
        }
    }

    return value_float;
}


/**
 * Read DSP Version
 *
 * @param      N/A
 * @return     float float version
 */
void DSPDrv1761_GetDspVer(cDSPDrv1761 *me, float *fVerRet)
{
    ASSERT(me && me->isCreated);
    uint8   data[DSP_VER_REGISTER_LEN] = {0};
    DspDrv1761_I2cRead(me, DSP_VER_REGISTER, sizeof(data), data);
    float ver= DSPDrv1761_DataToFloat(me, UINT32_BYTE_INV(data), 5, 23); //format 5.23
    *fVerRet = ver;    
}


/**
 * Enable/Disalbe DSP I2C access
 */
void DSPDrv1761_I2cEnable(cDSPDrv1761 *me, bool i2cEnable)
{
    me->i2cEnable= i2cEnable;
}

/**
 * Convert standard float number to DSP float raw data 5.23
 *
 * @param      float_val: float value
 *
 * @return     starnard float number
 * 
 * @note       do not support negative float 
 * 
 * @example
 *   float=0.000000   => 0x00000000
 *   float=0.500000   => 0x00400000
 *   float=0.250000   => 0x00200000
 *   float=0.015625   => 0x00020000
 *   float=15.984375  => 0x07FE0000
 *   float=15.9999998807907 => 0x07FFFFFF  (max)
 *   float=-0.500000  => 0xFFC00000
 *   float=-0.250000  => 0xFFE00000
 *   float=-0.015625  => 0xFFFE0000
 *   float=-15.984375 => 0xF8020000
 *   float=-16.0      => 0xF8000000  (min)
 *
 * @ref
 *   https://wiki.analog.com/resources/tools-software/sigmastudio/usingsigmastudio/systemimplementation
 *
 */
/*static */uint32 DSPDrv1761_FloatTo5_23Data(cDSPDrv1761 *me, float float_val)
{
  int32 param223, param227;
  uint32 res= 0;
  uint8* pRes= (uint8*)&res;
  
  if( float_val>=16.0 || float_val<-16.0)
  {
      //ASSERT(0);
      TP_PRINTF("\r\n*** DSPDrv1761_FloatTo5_23Data: invalid floating nubmer %f\r\n\r\n", float_val );
      return 0;
  }
  
  param223 = float_val * (1L << 23);  //multiply decimal number by 2^23
  //printf("param223= %08x (transfer from double: %f)\r\n", param223, float_val * (1L << 23));
  
  param227 = param223 ;
  param227+= (1L << 27);       //convert to positive binary      
  pRes[0] = (uint8)param227;         //get byte 0 (LSBs) of parameter value
  pRes[1] = (uint8)(param227>>8);    //get byte 1 of parameter value
  pRes[2] = (uint8)(param227>>16);   //get byte 2 of parameter value
  pRes[3] = (uint8)(param227>>24);   //get byte 3 (MSBs) of parameter value  
  //printf("pRes 1= %02x %02x %02x %02x\r\n", pRes[3], pRes[2], pRes[1], pRes[0]);
  
  pRes[3] = pRes[3] ^ 0x08;     //invert sign bit to get correct sign  
  //printf("pRes 2= %02x %02x %02x %02x\r\n", pRes[3], pRes[2], pRes[1], pRes[0]);
  
  if(pRes[3] & 0x08)
    pRes[3] |= 0xF0;  
  //printf("pRes 3= %02x %02x %02x %02x\r\n", pRes[3], pRes[2], pRes[1], pRes[0]); 
  //printf("%f => %08x\r\n", float_val, res);
  
  return res;
}


/**
 * Write to DC value with 32.0 format
 * @param  -    passEnable
 */
void DSPDrv1761_WriteDcValue32_0(cDSPDrv1761 *me, uint16 reg_addr, int32 data)
{
    //TP_PRINTF("DSPDrv1761_WriteDcValue32_0: reg=%d, data=%d\r\n", reg_addr, data);   
       
    uint8 data_iic[DC_REGISTER_LEN] = {0}; /* write DSP register */
    data_iic[0] = reg_addr >> 8;
    data_iic[1] = reg_addr & 0x00FF;
    data_iic[2] = UINT32_GET_BIT_RANGE(data, 31, 24);
    data_iic[3] = UINT32_GET_BIT_RANGE(data, 23, 16);
    data_iic[4] = UINT32_GET_BIT_RANGE(data, 15,  8);
    data_iic[5] = UINT32_GET_BIT_RANGE(data,  7,  0);
    DSPDrv1761_I2cWrite(me, DC_REGISTER_LEN, (uint8*)data_iic);
}


/**
 * Write to DC value with 8.24 format
 * @param  -    passEnable
 */
void DSPDrv1761_WriteValue5_23(cDSPDrv1761 *me, uint16 reg_addr, float fValue)
{
    uint32 data= DSPDrv1761_FloatTo5_23Data(me, fValue);
    //TP_PRINTF("DSPDrv1761_WriteValue5_23: reg=%d, dValue=%f => data=%d\r\n", reg_addr, fValue, data);
       
    uint8 data_iic[DC_REGISTER_LEN] = {0}; /* write DSP register */
    data_iic[0] = reg_addr >> 8;
    data_iic[1] = reg_addr & 0x00FF;
    data_iic[2] = UINT32_GET_BIT_RANGE(data, 31, 24);
    data_iic[3] = UINT32_GET_BIT_RANGE(data, 23, 16);
    data_iic[4] = UINT32_GET_BIT_RANGE(data, 15,  8);
    data_iic[5] = UINT32_GET_BIT_RANGE(data,  7,  0);
    DspDrv1761_I2cWrite(me, DC_REGISTER_LEN, (uint8*)data_iic);
}


float DSPDrv1761_ReadValue5_23(cDSPDrv1761 *me, uint16 reg_addr)
{
    uint8   data[DC_REGISTER_LEN] = {0};
    float   fValue= 0.0;

    ASSERT(me->isCreated);
    DspDrv1761_I2cRead(me, reg_addr, sizeof(data), data);
    fValue= DSPDrv1761_DataToFloat(me, UINT32_BYTE_INV(data), 5, 23); //format 5.23
    //TP_PRINTF("\r\n\r\nvolInput= %02X %02X %02X %02X = %f\r\n", volData[0], volData[1], volData[2], volData[3], fVol);
    
    return fValue;
}


bool DSPDrv1761_IsPllLock(cDSPDrv1761 *me)
{
    uint8 data[6] = {0}; 
    ASSERT(me->isCreated);
    DspDrv1761_I2cRead(me, PLLCTRLREGISTER_ADDR, sizeof(data), data);
    bool pll_lock= data[5] & 0x3;
    bool pll_ena= data[5] & 0x1;
    TP_PRINTF("\r\nDSP PLL=%02x %02x %02x %02x %02x %02x  => pll=(lock:%d, ena:%d)\r\n", data[0], data[1], data[2], data[3], data[4], data[5], pll_lock, pll_ena);
    
    return pll_lock;
}

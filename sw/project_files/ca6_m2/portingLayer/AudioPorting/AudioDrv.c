/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service BnO Playbox Specific
@author      Edmond Sung
@date        2015-10-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "AseTkSrv.h"
#include "ADCDrv.h"
#include "I2CDrv.h"
#include "GPIODrv.h"
#include "DspDrv1451.h"
#include "AmpDrvTas5760.h"
#include "AudioDrv.config"
#include "pcm1862Drv.h"
#include "timer.h"

typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},

};

#define TEMPERATURE_POSITIONS_NUM (81)

static const uint16 ntcTemperatureTable[TEMPERATURE_POSITIONS_NUM] =
{
    3848,    3836,    3823,    3810,    3796,    3782,    3767,    3752,    3736,    3720,
    3703,    3685,    3667,    3649,    3629,    3610,    3589,    3568,    3546,    3524,
    3501,    3478,    3453,    3429,    3403,    3377,    3351,    3324,    3296,    3268,
    3239,    3209,    3179,    3149,    3118,    3086,    3054,    3021,    2988,    2955,
    2921,    2887,    2852,    2817,    2782,    2746,    2710,    2674,    2637,    2601,
    2564,    2527,    2490,    2453,    2415,    2378,    2341,    2303,    2266,    2229,
    2191,    2154,    2117,    2081,    2044,    2007,    1971,    1935,    1900,    1864,
    1829,    1794,    1760,    1725,    1692,    1658,    1625,    1592,    1560,    1528,
    1497
};

typedef struct
{
    eAudioJackId    audioJackInId;
    eSettingId      jackSetId;
    bool            (*isJackInFunc)(void);
    eSettingId      musicDetSetId;
    bool            (*isMusicOnFunc)(void);
    int32           muteDebounceCnt;
}tMusicDection;

static tMusicDection musicDetection[] =
{
    {AUXIN_JACK,     SETID_IS_AUXIN_PLUG_IN,    &AudioDrv_IsAuxinJackPluggedIn, SETID_AUXIN_MUSIC_DET,    &AudioDrv_IsAuxinHasMusicOn,  INVALID_VALUE},
    /* For source from ASE-TK */
    //{JACK_IN_INVALID,SETID_ASETK_CONNECTED,     &AudioDrv_IsAsetkPluggedIn,     SETID_ASETK_MUSIC_DET,    &AudioDrv_IsAsetkHasMusicOn,  INVALID_VALUE},
};

static cI2CDrv      dspI2cObj;
static cDSPDrv1451 DspADAU1451Drv;

static cI2CDrv      ampWooferI2cObj;
static cAudioAmpDrv audioAmpWooferDrv;

static cI2CDrv      ampMidI2cObj;
static cAudioAmpDrv audioAmpMidDrv;

static cI2CDrv          adcPcm1862i2cObj;
static cAdcDrv_pcm1862  adcPcm1862;

/*static */cGpioDrv gpioAudio;

cADCDrv adcAudio;

static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static int32 jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;

static uint32 ampTempCheckTimer = AUDIO_AMP_TEMP_CHECK_TIME;
static uint32 ampErrorCheckTimer = AUDIO_AMP_ERROR_CHECK_TIME;

static uint16 volFadeTimerId;
static tVolFadeParam* pVolFadeParam;

/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    /* When bootup, AudioSrv call AudioDrv_Ctor() very soon, wait few seconds (after ASE-TK MCLK is ready),
     * then execute AudioDrv_Init() to initialize DSP.
     */
    ASSERT(me);

    //Initialize Audio GPIO pins
    gpioAudio.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_DEV_ID, GPIO_DEV_TYPE, NULL);
    ASSERT(gpioAudio.gpioConfig);
    GpioDrv_Ctor(&gpioAudio, gpioAudio.gpioConfig);

    //Initialize Audio ADC pins
    adcAudio.ADCConfig= (tADCDevice*)getDevicebyIdAndType(AUDIO_DEV_ID, ADC_DEV_TYPE, NULL);
    ASSERT(adcAudio.ADCConfig);
    ADCDrv_Ctor(&adcAudio, adcAudio.ADCConfig);
    
    //Initialize DSP
    dspI2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    ASSERT(dspI2cObj.pConfig);
    DSPDrv1451_Ctor(&DspADAU1451Drv, &dspI2cObj);

    //Shutdown all amplifier
    AMP_SHUTDOWN(gpioAudio); //pull low SDZ
            
    //Enable power for DSP/AMP/NTC
    SYSPWR_ENABLE(gpioAudio);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    AdcDrv_pcm1862_Xtor(&adcPcm1862);
    DSPDrv1451_Xtor(&DspADAU1451Drv);
    
    //Shutdown all amplifier
    AMP_SHUTDOWN(gpioAudio); //pull low SDZ
    //Disable power for DSP/AMP/NTC
    SYSPWR_DISABLE(gpioAudio);

    me->drvIsReady = FALSE;
}


/**
 * @Function to Init the low layer Audio related driver
 * @return This function return TRUE when audioDrv initialization is finished.
 */
BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {        
        if(me->nextDelayTime == 0)
        {
            //Enable power for ADC/DSP/AMP/NTC
            SYSPWR_ENABLE(gpioAudio);
        }

        me->nextDelayTime = DSPDrv1451_Init(&DspADAU1451Drv);
        if(me->nextDelayTime == 0) 
        {
            //Read DSP Version
            float fVer= DSPDrv1451_GetDspVer(&DspADAU1451Drv);
            char dspVersion[DSP_VERSION_LENGTH]= {0};
            snprintf(dspVersion, sizeof(dspVersion), "%0.1f", fVer);
            Setting_Set(SETID_DSP_VER, dspVersion);

            //Initialize ADC: PCM1862
            adcPcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyIdAndType(AUDIO_ADC_DEV_ID, I2C_DEV_TYPE, NULL);
            ASSERT(adcPcm1862i2cObj.pConfig);
            AdcDrv_pcm1862_Ctor(&adcPcm1862, &adcPcm1862i2cObj);
            AdcDrv_pcm1862_Init(&adcPcm1862);
            AdcDrv_pcm1862_SetInput(&adcPcm1862, PCM1862_ANALOG_INPUT1); //select input from differential
            AdcDrv_pcm1862_SetPGA(&adcPcm1862, PCM1862_PGA_9dB);
            AdcDrv_pcm1862_enableAGC(&adcPcm1862, /*enable:*/FALSE); //AGC feature have problem on MOFA, should disable it
         
            /* 1. Set amplifer to PBTL mode, means two output to one speaker
             * 2. Datasheet said, PBTL select right channel when REG[6].bit1==1, left chanel when REG[6].bit1==0.
             *    But accurary result is inverse.
             * 2. Vpk should < amplifier PVDD(15~24v), or analog output will clip on PVDD
             */
            //TODO: move this customization to attachedDevices.c

            /* It is important to note that control port register changes should only occur when the device is placed into
             *  shutdown. This can be accomplished either by pulling the SPK_SD pin "LOW" or clearing the SPK_SD bit in the
             *  control port.
             */
            
            /* Pull SDZ to high after I2C programming */
            AMP_WAKEUP(gpioAudio);
            AMP_UNMUTE(gpioAudio);

            
            //AudioAmpDrv_printError(&audioAmpWoofer1Drv);
            AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/TRUE);

            /* Set default settings */
            jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            bool defaultValue = FALSE;
            Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultValue);
            Setting_Set(SETID_IS_SPDIF_IN_PLUG_IN, &defaultValue);
            Setting_Set(SETID_AUXIN_MUSIC_DET, &defaultValue);
            Setting_Set(SETID_SPDIF_IN_MUSIC_DET, &defaultValue);
            Setting_Set(SETID_ASETK_MUSIC_DET, &defaultValue);
            tVolFadeParam volFadeParam = {0};
            Setting_Set(SETID_VOLUME_FADE_PARAM, &volFadeParam);
            uint8 defaultVol = DEFAULT_VOLUME;
            Setting_Set(SETID_VOLUME, &defaultVol);

            uint8 defaultLevel = LINE_IN_SENSITIVITY_DISABLE;
            Setting_Set(SETID_LINEIN_SENSITIVITY_LEVEL, &defaultLevel);
            DSPDrv1451_SetLineInSensitivity(&DspADAU1451Drv, defaultLevel);

            AseFepSetPositionSoundModeReq soundMode = {0};
            Setting_Set(SETID_POSITION_SOUND_MODE, &soundMode);

            //Finish
            me->drvIsReady = TRUE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetInputChannel(&DspADAU1451Drv, audioChannel);

    //Fix Me: currently below code is just for test purpose.
    DSPDrv1451_SetLineInMultiRoomChannel(&DspADAU1451Drv, audioChannel);
}

void AudioDrv_SetLineInMultiRoomChannel(eAudioChannel audioChannel)
{
    DSPDrv1451_SetLineInMultiRoomChannel(&DspADAU1451Drv, audioChannel);
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *audioDrvObj)
{
    AudioDrv_AmpSafetyMonitor();
    AudioDrv_CheckJackInStatus();
    AudioDrv_CheckMusicStreamStatus();
}

void AudioDrv_CheckJackInStatus(void)
{
    uint8 i = 0;
    if ((jackDetTimer > 0) && ((jackDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0))
    {
        for( i = 0; i < ArraySize(musicDetection); i++)
        {
            bool isJackIn = (musicDetection[i].isJackInFunc)();
            bool preJackStatus = *(bool*)Setting_Get(musicDetection[i].jackSetId);
            if (isJackIn != preJackStatus)
            {
                Setting_Set(musicDetection[i].jackSetId, &isJackIn);
                TP_PRINTF("Jack Detect channel %d is %d\r\n", musicDetection[i].audioJackInId, isJackIn);
                AudioJackinStateEvt* pAudioStateEvt = Q_NEW(AudioJackinStateEvt, AUDIO_STATE_SIG);
                pAudioStateEvt->jackId = musicDetection[i].audioJackInId;
                pAudioStateEvt->IsJackIn = isJackIn;
                QF_PUBLISH(&pAudioStateEvt->super, me);

                /* Note: As the first music detect after analog jack plugged in is wrong(always on), so
                  * if the analog jack is just plugged in, then reset the music detection timer to 4 seconds. */
                if(isJackIn && musicDetection[i].audioJackInId == AUXIN_JACK)
                {
                    musicDetTimer = AUDIO_ACTIVE_FIRST_DET_AFTER_PLUGGED_TIME;
                }

                /* To avoid pop noise, mute the multi room channel(from DSP to ASE-TK) once jack status was changed. */
                DSPDrv1451_MuteLineInToAsetk(&DspADAU1451Drv, TRUE);
            }
        }
        jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
    }
}

/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    uint8 i = 0;
    if ((musicDetTimer > 0) && ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0))
    {
        for( i = 0; i < ArraySize(musicDetection); i++)
        {
            bool isMusicOn = (musicDetection[i].isMusicOnFunc)();
            bool preStatus = *(bool*)Setting_Get(musicDetection[i].musicDetSetId);
            /* Note: we assumed if the jack is not plug-in, the music status is off. */
            bool jackStatus = *((bool*)Setting_Get(musicDetection[i].jackSetId));
            if(jackStatus && isMusicOn)
            {
                isMusicOn = TRUE;
                musicDetection[i].muteDebounceCnt = AUDIO_ACTIVE_MUTE_DEBOUNCE_TIME;
            }
            else if (jackStatus && (musicDetection[i].muteDebounceCnt > 0))
            {
                /* Only if this source have been no audio 15 seconds, then we think the source is in a real mute. */
                if ((musicDetection[i].muteDebounceCnt -= AUDIO_ACTIVE_MUSIC_DETECT_TIME) <= 0)
                {
                    isMusicOn = FALSE;
                    musicDetection[i].muteDebounceCnt = INVALID_VALUE;
                }
                else
                {
                    isMusicOn = TRUE;
                }
            }
            else
            {
                isMusicOn = FALSE;
                musicDetection[i].muteDebounceCnt = INVALID_VALUE;
            }

            if (isMusicOn != preStatus)
            {
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;                
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->jackId = musicDetection[i].audioJackInId;
                pAudioMusicStateEvt->hasMusicStream = isMusicOn;
                QF_PUBLISH(&pAudioMusicStateEvt->super, NULL);

                Setting_Set(musicDetection[i].musicDetSetId, &isMusicOn);
                TP_PRINTF("Music Detect channel %d is %d\r\n", musicDetection[i].audioJackInId, isMusicOn);
            }
        }
        musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
    }
}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param)
{
    ASSERT(audioSettId < AUDIO_SETT_ID_MAX);

    /* When bootup, DSP do not initialize, do not access DSP on this moment */
    if(!(me->drvIsReady)) {
        TP_PRINTF("AudioDrv_SetAudio: driver is not ready\r\n");
        return;
    }

    switch (audioSettId)
    {
        case DSP_VOLUME_SETT_ID:
            //TP_PRINTF("AudioDrv_SetAudio: id=(%d)DSP_VOLUME_SETT_ID\r\n", audioSettId);
            pVolFadeParam = (tVolFadeParam*)Setting_Get(SETID_VOLUME_FADE_PARAM);
            if(!pVolFadeParam->isFadingInProg)
            {
                uint8 volume= (uint8)param;
                Setting_Set(SETID_VOLUME, &volume);
                AudioDrv_DspVolSetId_Handler();
            }
            break;

        case DSP_PASSTHROUGH_SETT_ID:
        {
            DSPDrv1451_SetPassthrough(&DspADAU1451Drv, enabled);
            break;
        }
        case DSP_TUNNING_SETT_ID:
        {
            static bool disabled = FALSE;
            if (!disabled)
            {
                DSPDrv1451_Xtor_ex(&DspADAU1451Drv);
                /* DSP and AMP I2C bus should be disable when tuning DSP. */
                DSPDrv1451_I2cEnable(&DspADAU1451Drv, !enabled);
                disabled = TRUE;
            }

            break;
        }
        default:
             break;
    }
}

static void AudioDrv_VolFadeTimerCallBack(void *pCbPara)
{
    
    tVolFadeParam* pVolFadeParam = (tVolFadeParam*)pCbPara;
    /* get current volume value */
    uint8 volLevel = *(uint8*)Setting_Get(SETID_VOLUME);
    /* change volume*/
    if(pVolFadeParam->fadeType)
    {
        /* volume fade up*/
        if(pVolFadeParam->targetVol < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(MAX_VOLUME < (volLevel + pVolFadeParam->fadeStep))
        {
            volLevel = MAX_VOLUME;
        }
        else
        {
            volLevel += pVolFadeParam->fadeStep;
        }
    }
    else
    {
        /* volume fade down*/
        if(pVolFadeParam->targetVol > (volLevel - pVolFadeParam->fadeStep))
        {
            volLevel = pVolFadeParam->targetVol;
        }
        else if(pVolFadeParam->fadeStep > (volLevel - MIN_VOLUME))
        {
            volLevel = MIN_VOLUME;
        }
        else
        {
            volLevel -= pVolFadeParam->fadeStep;
        }
    }
    Setting_Set(SETID_VOLUME, &volLevel);
    AudioDrv_DspVolSetId_Handler();

    if((volLevel != pVolFadeParam->targetVol)
        && (volLevel < MAX_VOLUME) && (volLevel > MIN_VOLUME))
    {
        Timer_StartTimer(pVolFadeParam->fadeStepTime, &volFadeTimerId, AudioDrv_VolFadeTimerCallBack, pVolFadeParam);
    }
    else
    {
        /* Reply Ase-tk when volume fade completed. */
        AseTkSrv_ReplyVolumeFade(volLevel);
        pVolFadeParam->isFadingInProg = FALSE;
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    switch (muteType)
    {
        case AUDIO_AMP_MUTE:
        {
            if (muteEnable)
            {
                AMP_MUTE(gpioAudio);
            }
            else
            {
                AMP_UNMUTE(gpioAudio);
            }
            break;
        }
        default:
            break;
    }
}

static uint8 AudioDrv_ConvertNtcToTemperature(uint16 ntcValue)
{
    uint8 ii;

    for (ii = 0; ii < TEMPERATURE_POSITIONS_NUM; ii++)
    {
        if (ntcValue > ntcTemperatureTable[ii])
        {
            break;
        }
    }
    return ii;
}

/**
 * Function to monitor the amp status
 */
void AudioDrv_AmpSafetyMonitor()
{
    AMP_TempMonitor();
    AudioDrv_AmpHealthMonitor();
}

/**
 * Function to update amplifier temperature.
 */
static void AMP_TempMonitor()
{
    int16   rawResult = 0;
    uint8  temperature = 0;
    int16 wfNTC = 0;
    int16 twNTC = 0;
    int16 amp1NTC = 0;
    int16 amp2NTC = 0;

    if (ampTempCheckTimer > 0)
    {
        if ((ampTempCheckTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            /* update Amplifier 1 temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, adcAudio.ADCConfig->pAdcPinIoAttr[0].adcPin);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_AMP1_TEMP, &temperature);
            //TP_PRINTF("Amplifier 1 temperature:%d \r\n", temperature);

            /* update Amplifier 2  temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, adcAudio.ADCConfig->pAdcPinIoAttr[1].adcPin);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_AMP2_TEMP, &temperature);
            //TP_PRINTF("Amplifier 2 temperature:%d \r\n", temperature);

            /* update woofer temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, adcAudio.ADCConfig->pAdcPinIoAttr[2].adcPin);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_WF_TEMP, &temperature);
            //TP_PRINTF("Woofer temperature:%d \r\n", temperature);

            /* update Mid temperature */
            rawResult = (int16)ADCDrv_GetData(&adcAudio, adcAudio.ADCConfig->pAdcPinIoAttr[3].adcPin);
            temperature = AudioDrv_ConvertNtcToTemperature(rawResult);
            Setting_Set(SETID_MID_TEMP, &temperature);
            //TP_PRINTF("Mid temperature:%d \r\n", temperature);


            /* Scan for new values */
            ADCDrv_StartScanning(&adcAudio);
            ampTempCheckTimer = AUDIO_AMP_TEMP_CHECK_TIME;
        }
    }
}

/**
 * Function to update amplifier error status.
 */
static void AudioDrv_AmpHealthMonitor(cAudioDrv *me)
{
    bool ampWoofer_error = FALSE;
    bool ampMid_error = FALSE;
    if (ampErrorCheckTimer > 0)
    {
        if ((ampErrorCheckTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            /* update Amplifier error status */
            if(ampWoofer_error || ampMid_error)
            {
                TP_PRINTF("\r\n*** AMP_HEALTH: WF:0x%x, Mid:0x%x ***\r\n", ampWoofer_error, ampMid_error);
            }
            ampErrorCheckTimer = AUDIO_AMP_ERROR_CHECK_TIME;
        }
    }
}

static void AudioDrv_DspVolSetId_Handler(void)
{
    uint8 volumeLevel = MIN_VOLUME;

    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);
    if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
    {
        DSPDrv1451_SetVol(&DspADAU1451Drv, volumeLevel);
    }
    else
    {
        ASSERT(0);
    }    
}

static bool AudioDrv_IsAsetkPluggedIn(void)
{
    return *((bool*)Setting_Get(SETID_ASETK_CONNECTED));
}
/*
* Not plug:     DET1 = HIGH, DET2 = HIGH
* Auxin plug:   DET1 = LOW, DET2 = LOW
* Optical plug: DET1 = LOW, DET2 = HIGH
*/
static bool AudioDrv_IsAuxinJackPluggedIn(void)
{
    bool ret;
    int8 det = GpioDrv_ReadBit(&gpioAudio, GPIO_IN_AUDIO_JACK_DET);
    ret = (!det); 
    return ret;
}

static bool AudioDrv_IsAsetkHasMusicOn(void)
{
    return DSPDrv1451_HasMusicStream(&DspADAU1451Drv);;
}

static bool AudioDrv_IsAuxinHasMusicOn(void)
{
    return DSPDrv1451_AuxinHasMusicStream(&DspADAU1451Drv);;
}

static bool AudioDrv_IsOptHasMusicOn(void)
{
    return DSPDrv1451_SpdifInHasMusicStream(&DspADAU1451Drv);;
}


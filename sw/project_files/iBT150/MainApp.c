/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Main Application
                  -------------------------

                  SW Module Document




@file        MainApp.c
@brief       Main application for iBT150
@author      Christopher Alexander
@date        2014-04-24
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-04-24     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

/*to do list*/
/* need to remove the extern with getDeviceId function after the GPIO struct is changed*/

#include "./MainApp_priv.h"
#include "trace.h"

#ifndef MAINAPP_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif

#define AC_PLUG_IN_BATT_LED_INDICATE_DELAY_MS 1500
#define EMERGENCY_MODE_ENTER_DELAY_MS 1000
#define BT_FORWARD_TIMEOUT_MS 750
#define BT_BACKWARD_TIMEOUT_MS 750
#define READY_TO_ENTER_EMERGENCY_TIMEOUT_MS 4000

typedef struct
{
    uint8 spCount; /*Short press count*/
    int32 calTimer; /*Calculate time*/
}tTrackDirection;

static tTrackDirection trackDirection;

#define EXT_BATT_EJECT_INTERVAL_MS 150
#define EXT_BATT_EJECT_INTERVAL_DELAY_MS 3000
#define EXT_BATT_INSERT_INTERVAL_MS 500
#define EXT_BATT_INSERT_INTERVAL_DELAY_MS 1000
typedef struct
{
    bool isDocking;
    bool isEjecting;
    int8 ledCount;
    int8 currCount;
    int32 calTimer;
}tExtBatteryDockInfo;

static tExtBatteryDockInfo extBatteryDockInfo;

#define CAST_ME cMainApp * MainApp = (cMainApp *) me;


enum MainAppPriSignals /* main appp private signals */
{
    MAINAPP_TIMEOUT_SIG = MAX_SIG,
};

typedef enum
{
    SYS_STATE_NORMAL,
    SYS_STATE_STANDBY,
    SYS_STATE_SLEEP,
}eMainAppSysState;

eMainAppSysState sysState;

/* Private functions / variables. */

/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[5];

static bool        isExtBatteryEjecting;
static bool        isExtBattEjectInSleep = FALSE;
static bool        isExtBattDockInSleep = FALSE;
static bool        isBatteryLedInitialized = FALSE;
static bool        isEmergencyMode = FALSE;
static bool        isEmergencyModeInSleep = FALSE;
static bool        isReachVolumeLimit = FALSE;
static bool        isAcConnectedInSleep = FALSE;
static bool        isPowerOnByNFC = FALSE;
static bool        isTimerSignalExpected = FALSE;
static uint8       preVolumeLevel;
static int32       gCalTimer;
static uint32      gEmergencyTimer;

#ifdef HAS_BT_DELEGATE
static cBluetoothDlg bluetoothDlg;
#endif

#ifdef HAS_POWER_DELEGATE
static cPowerDlg powerDlg;
static bool isPowerDlgCreated = FALSE;
#endif

/* the time (ms) per timeout signal */
#define MAIN_APP_TIMEOUT_IN_MS  20

static bool isPowerDownReq = FALSE;
static bool isMusicDetected = FALSE;
static bool isSystemIdle;
/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MainApp);
    QS_OBJ_DICTIONARY(MainApp_PreActive);

    /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), MAINAPP_TIMEOUT_SIG,
                            MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);

    /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif
#ifdef HAS_BLUETOOTH
    QActive_subscribe((QActive*) me, BT_STATE_SIG);
#endif
    QActive_subscribe((QActive*) me, POWER_WAKE_UP_SIG);
    QActive_subscribe((QActive*) me, AUDIO_MUSIC_DETECT_STATE_SIG);
}

void MainApp_ShutDown(cPersistantObj *me)
{
#ifdef HAS_POWER_DELEGATE
    //need to watch the power state all the time
    PowerDlg_Xtor(&powerDlg);
    isPowerDlgCreated = FALSE;
#endif
    Application_Xtor((cApplication*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const * const e)
{
    /* initial the default value for first power up or factory reset*/
    MainApp_InitialVariablesForFactoryReset(me);
#ifdef HAS_POWER_DELEGATE
    //need to watch the power state all the time
    PowerDlg_Ctor(&powerDlg, (QActive*)me);
    isPowerDlgCreated = TRUE;
#endif
#ifdef HAS_BT_DELEGATE
    BluetoothDlg_Ctor(&bluetoothDlg, (QActive*)me);
#endif
    return Q_TRAN(&MainApp_PoweringUp);
}

/* power up the power before preActive*/
static QState MainApp_PoweringUp(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            return Q_TRAN(MainApp_PreActive);
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* PreActive state */
static QState MainApp_PreActive(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            MainApp_StartBtDlg();
            MainApp_SwitchMode(MainApp, NORMAL_MODE);
            isTimerSignalExpected = FALSE;
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            MainApp_InitialVariablesForPowerUp(MainApp);
            /* add delay for power up, can directly change the timer armx below after LED is move out*/
            gCalTimer = POWERUP_DELAY_MS_FOR_BT_Q;
            /*Set power on releated LED to 100% intensity*/
            LedSrv_SetPatt((QActive*)me, POWER_ON_LEDS, SOLID_ON_PATT);
            MainApp_UpdateBatteryIndication(MainApp);           
            isTimerSignalExpected = TRUE;
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            /*Sometimes will get the timeout signal before enable timer here, which
              is coming from the timer in DeActive state
            TODO: find a way to flush the time out signal when leaving the state*/
            if(!isTimerSignalExpected)
            {
                TP_PRINTF("unexpeceted timeout signal!\r\n");
                return Q_HANDLED();
            }
            gCalTimer -= MAIN_APP_TIMEOUT_IN_MS;
            if(gCalTimer==(POWERUP_DELAY_MS_FOR_BT_Q - NFC_POWER_ON_PAIR_TIME_MS))
            {
                if(isPowerOnByNFC==TRUE)
                {
                    isPowerOnByNFC = FALSE;
                    BluetoothSrv_SendBtCmd((QActive*)me, BT_ENTER_PAIRING_CMD);
                }
                else
                {
                    BluetoothSrv_SendBtCmd((QActive*)me, BT_CONNECT_CMD);
                }
            }
            if(gCalTimer<=0)
            {   /* the delay is to avoid power down while powering up (playing powering tune)*/
                /* Restore volume level after power on tone is finished (need to finetune if change tone) */
                MainApp->vol = preVolumeLevel;
                AudioSrv_SetVolume(MainApp->vol);
                return Q_TRAN(MainApp_Active);
            }
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            isTimerSignalExpected = FALSE;
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            gCalTimer = IDLE_AUTO_POWER_OFF_TIMEOUT_MS;    // 5min;
            // for test team testing
            DebugSettSrv_PrintStr("BT Autolink started\r\n");
            MainApp_PublishSystemStatus(MainApp, SYSTEM_ACTIVE_STA);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            MainApp_ParseKeyEvent(MainApp,e);
            return Q_HANDLED();
        }
        case POWER_OFF_IND_SIG:
        {
            return Q_TRAN(MainApp_PoweringDown);
        }
        case AUDIO_MUSIC_DETECT_STATE_SIG:
        {
            AudioMusicDetectStateEvt* evt = (AudioMusicDetectStateEvt*)e;
            isMusicDetected = evt->hasMusicStream;
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            if(isPowerDownReq || MainApp_IsBatteryLowPowerOff(MainApp))
            { /* power down */
                isPowerDownReq = FALSE;
                return Q_TRAN(MainApp_PoweringDown);
            }
            if(isEmergencyMode)
            {
                gEmergencyTimer -= MAIN_APP_TIMEOUT_IN_MS;
                if(gEmergencyTimer >= READY_TO_ENTER_EMERGENCY_TIMEOUT_MS)
                {
                    return Q_TRAN(MainApp_PoweringDown);
                }
            }
            else
            {
                gEmergencyTimer = 0;
            }
            if(MainApp_IsSystemIdle(MainApp))
            {
                gCalTimer -= MAIN_APP_TIMEOUT_IN_MS;
                if(gCalTimer <=0)
                {
                    return Q_TRAN(MainApp_PoweringDown);
                }
            }
            else
            {
                gCalTimer = IDLE_AUTO_POWER_OFF_TIMEOUT_MS;
            }
            /*Play, Pause, Forward, Backward Detection*/
            MainApp_PlayPause(MainApp);
            MainApp_UpdateBatteryIndication(MainApp);
#ifndef LOW_POWER_DRC_QUICK_TEST
            MainApp_UpdateAudioPowerDrcRange(MainApp);
#endif
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case BT_RESP_SIG:
        {
            return Q_HANDLED();
        }
        case POWER_EMERGENCY_MODE_REQ_SIG:
        {
            return Q_HANDLED();
        }
#ifdef EXTERNAL_BATTERY
        case EJECT_EXT_BATTERY_RESP_SIG:
        {
            return Q_HANDLED();
        }
#endif
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* DeActive state  -- power off */
static QState MainApp_DeActive(QActive * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* powering down state, which is turning off the system power and have some delay*/
static QState MainApp_PoweringDown(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            /* play the BT power off Q*/
            if(MainApp_IsBtIdle() && MainApp_IsAuxInIdle() && FALSE==isEmergencyMode)
            {
                AudioSrv_SendAudioSrvToneCmd((QActive*)me, BT_TONE_POWER_OFF_CMD);
                isSystemIdle = TRUE;
            }
            else
            {
                isSystemIdle = FALSE;
            }
            MainApp_StopBtDlg();
            MainApp_PublishSystemStatus(MainApp, SYSTEM_SLEEP_STA);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            if(FALSE==isSystemIdle)
            {
                isSystemIdle = TRUE;
                if((MainApp_IsPowerInBatteryMode())&& (MainApp_IsReadyForSleep()))
                {
                    MainApp_SwitchMode(MainApp, POWERING_DOWN_MODE);
                }
                else
                {
                    return Q_TRAN(MainApp_Standby);
                }
            }
            return Q_HANDLED();
        }
        case AUDIO_SWITCH_CHANNEL_RESP_SIG:
        {
            if((MainApp_IsPowerInBatteryMode())&& (MainApp_IsReadyForSleep()))
            {
                MainApp_SwitchMode(MainApp, POWERING_DOWN_MODE);
            }
            else
            {
                return Q_TRAN(MainApp_Standby);
            }
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            return Q_TRAN(MainApp_Standby);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&MainApp_DeActive);
}

/* standby state, which does NOT turn off system power*/
static QState MainApp_Standby(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TP_PRINTF("entry standby state\r\n");
            sysState = SYS_STATE_STANDBY;
            isBatteryLedInitialized = FALSE;
            MainApp_SwitchMode(MainApp, STANDBY_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            gEmergencyTimer = 0;
            MainApp_RequestMuteAudio(MainApp, TRUE);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, 500);
            if(isEmergencyModeInSleep)
            {
                MainApp_EmergencyModeParse(MainApp, TRUE);
                isEmergencyModeInSleep = FALSE;
            }
            else if(isExtBattEjectInSleep || isExtBattDockInSleep)
            { /* Before process LED indication for ejecting external battery, display LED & reset parameters in advance. */
                tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
                extBatteryDockInfo.calTimer = 0;
                extBatteryDockInfo.currCount = 0;
                extBatteryDockInfo.ledCount = MainApp_GetBatteryLedCount(battInfo.extBattState);
                if(isExtBattEjectInSleep)
                {
                    if( EJECT_BATT_STA==battInfo.extBattState)
                    {
                        TP_PRINTF(">>> Standby: Eject Quit, no battery!!\r\n");
                        isExtBattEjectInSleep = FALSE;
                        extBatteryDockInfo.isEjecting = FALSE;
                        isExtBatteryEjecting = FALSE;
                    }
                    else
                    {
                        MainApp_ShowBatteryIndication(MainApp, EXT_BATTERY_TYPE, battInfo.extBattState, FALSE);
                    }
                }
            }
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if(((evt->keyEvent == KEY_EVT_SHORT_PRESS)&&(evt->keyId == POWER_KEY))||
               ((evt->keyEvent == KEY_EVT_DOWN)&&(evt->keyId == NFC_TAG_KEY)))
            {
                if(evt->keyId == POWER_KEY)
                {
                    if(isEmergencyMode)
                    {
                        gEmergencyTimer = EMERGENCY_MODE_TIMEOUT_MS;
                        return Q_HANDLED();
                    }
                }
                else if(evt->keyId == NFC_TAG_KEY)
                {
                    isPowerOnByNFC = TRUE;
                }
                return Q_TRAN(MainApp_PreActive);
            }
            MainApp_ParseKeyEvent(MainApp,e);
            return Q_HANDLED();
        }
#ifdef EXTERNAL_BATTERY
        case EJECT_EXT_BATTERY_RESP_SIG:
        {
            return Q_HANDLED();
        }
#endif
        case MAINAPP_TIMEOUT_SIG:
        {
            if(isEmergencyMode)
            {
                if(MainApp_EmergencyModeQuit(MainApp))
                {
                    return Q_TRAN(MainApp_PreActive);
                }
                MainApp_UpdateBatteryIndication(MainApp);
                PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
                return Q_HANDLED();
            }
            else if(((FALSE==isExtBattDockInSleep) && (FALSE==isExtBattEjectInSleep) && MainApp_IsPowerInBatteryMode())
               || MainApp_IsBatteryLowPowerOff(MainApp))
            {
                /* show UI here to indicate AC is out*/
                if(MainApp_IsReadyForSleep())
                { /* when AC pin vol go down and ready for interrupt */
                    return Q_TRAN(MainApp_Sleep);
                }
            }
            LedSrv_SetPatt((QActive*)me, POWER_OFF_LEDS, OFF_PATT);
            MainApp_UpdateBatteryIndication(MainApp);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }

        case Q_EXIT_SIG:
        {
            MainApp_RequestMuteAudio(MainApp,FALSE);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&MainApp_DeActive);
}

/* deep sleep state, which MCU will be in sleep and can only wake up by interrupt*/
static QState MainApp_Sleep(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TP_PRINTF("entry sleep state\r\n");
            sysState = SYS_STATE_SLEEP;
            isBatteryLedInitialized = FALSE;
            isAcConnectedInSleep = FALSE;
            extBatteryDockInfo.isDocking = FALSE;
            extBatteryDockInfo.isEjecting = FALSE;
            isExtBattEjectInSleep = FALSE;
            isExtBattDockInSleep = FALSE;
            isExtBatteryEjecting = FALSE;
            isEmergencyModeInSleep = FALSE;
            MainApp_SwitchMode(MainApp, SLEEP_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            SwitchModeRespEvt* resp = (SwitchModeRespEvt*)e;
            if(resp->modeId == SLEEP_MODE)
            {
                TP_PRINTF("switch to sleep mode\r\n");
                QEvt* evt = Q_NEW(QEvt, POWER_MCU_SLEEP_SIG);
                SendToServer(POWER_SRV_ID, evt);
            }
            else if (resp->modeId == POWERING_UP_MODE)
            {
                return Q_TRAN(MainApp_Standby);
            }
            return Q_HANDLED();
        }
        case POWER_WAKE_UP_SIG:
        {
            if(((PowerSrvWakeUpEvent*)e)->powerSrvWakeUpType == AC_PLUG_IN_WAKE_UP_TYPE)
            {/* Get the Interrupt signal, start timer to delay check the power state*/
                isAcConnectedInSleep = TRUE;
            }
#ifdef EXTERNAL_BATTERY
            else if(((PowerSrvWakeUpEvent*)e)->powerSrvWakeUpType == EXT_BATTERY_IN_WAKE_UP_TYPE)
            {
                TP_PRINTF(">>> Sleep: Ext Batt ADC Detected\r\n");
                isAcConnectedInSleep = FALSE;
            }
#endif
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, 1000);
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if(((evt->keyEvent == KEY_EVT_SHORT_PRESS)&&(evt->keyId == POWER_KEY))||
               ((evt->keyEvent == KEY_EVT_DOWN)&&(evt->keyId == NFC_TAG_KEY)))
            {
                if(evt->keyId == NFC_TAG_KEY)
                {
                    isPowerOnByNFC = TRUE;
                }
                return Q_TRAN(MainApp_PoweringUp);
            }
#ifdef EXTERNAL_BATTERY
            if((evt->keyEvent == KEY_EVT_SHORT_PRESS)&&(evt->keyId == EJECT_KEY))
            {
                TP_PRINTF(">>> Sleep: Eject Key Pressed!!\r\n");
                isExtBattEjectInSleep = TRUE;
                MainApp_ParseKeyEvent(MainApp,e);
                MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            }
#endif
            if((evt->keyEvent == KEY_EVT_HOLD)&&(evt->keyId == POWER_KEY))
            {
                isEmergencyModeInSleep = TRUE;
                MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            }
            return Q_HANDLED();
        }
#ifdef EXTERNAL_BATTERY
        case EJECT_EXT_BATTERY_RESP_SIG:
        {
            return Q_HANDLED();
        }
#endif
        case MAINAPP_TIMEOUT_SIG:
        {
            if(isAcConnectedInSleep)
            {
                isAcConnectedInSleep = FALSE;
                if(MainApp_IsPowerInBatteryMode())
                {   /* if it's still in Battery state, Get the MCU back to sleep */
                    QEvt* evt = Q_NEW(QEvt, POWER_MCU_SLEEP_SIG);
                    SendToServer(POWER_SRV_ID, evt);
                }
                else
                {   /* if it's DC in or USB in, wake up system and go to standby mode*/
                    TP_PRINTF(">>> Sleep: AC Connected!!\r\n");
                    MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
                }
            }
            else
            {
                if(MainApp_IsExtBatteryExisted())
                {   /* If external battery is reloaded, switch to standby mode for LED indication processing */
                    TP_PRINTF(">>> Sleep: External Battery Detected!!\r\n");
                    isExtBattDockInSleep = TRUE;
                    MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
                }
                else
                {   /* if it's still in Battery state, Get the MCU back to sleep */
                    QEvt* evt = Q_NEW(QEvt, POWER_MCU_SLEEP_SIG);
                    SendToServer(POWER_SRV_ID, evt);
                }
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&MainApp_DeActive);
}



/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/

static void MainApp_SwitchMode(cMainApp* me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

/* initial variable for factory reset */
static void MainApp_InitialVariablesForFactoryReset(cMainApp * const me)
{
    me->vol = DEFAULT_VOLUME;
    Setting_Set(SETID_VOLUME, &me->vol);
    uint8 maxVol = MAX_VOLUME;
    Setting_Set(SETID_MAX_VOLUME, &maxVol);
}

/* initial variable for power up system */
static void MainApp_InitialVariablesForPowerUp(cMainApp * const me)
{
    /* power variable */
    isExtBatteryEjecting = FALSE;
    isPowerDownReq = FALSE;
    isMusicDetected= FALSE;
    isBatteryLedInitialized = FALSE;
    isExtBattEjectInSleep = FALSE;
    isExtBattDockInSleep = FALSE;
    isAcConnectedInSleep = FALSE;
    sysState = SYS_STATE_NORMAL;

    /* Set default volume level for power on tone */
    preVolumeLevel = *(uint8*)Setting_Get(SETID_VOLUME);
    if(isEmergencyMode)
    {
        isEmergencyMode = FALSE;
        AudioSrv_SetVolume(0);
    }
    AudioSrv_SetVolume(preVolumeLevel);
}

static void MainApp_VolumeDown(cMainApp * const me, uint8 step)
{
    if(SYS_STATE_NORMAL != sysState)
    { /* If power off, don't process volume key */
        return;
    }
    me->vol = *(uint8*)Setting_Get(SETID_VOLUME);
    if(me->vol >= step)
    {
        me->vol-=step;
    }
    else
    {
        me->vol = 0;
    }
    AudioSrv_SetVolume(me->vol);
    if(0 == me->vol)
    { /* play vol limit cue, BT dlg will restore and set the vol after cue is done*/      
        LedSrv_SetPatt((QActive*)me, 1<<LED_VOL_DOWN, VOL_LIMIT_REACH_PATT);
        isReachVolumeLimit = TRUE;
    }
    else
    {
        isReachVolumeLimit = FALSE;
    }
}

static void MainApp_VolumeUp(cMainApp * const me, uint8 step)
{
    if(SYS_STATE_NORMAL != sysState)
    { /* If power off, don't process volume key */
        return;
    }
    me->vol = *(uint8*)Setting_Get(SETID_VOLUME);
    uint8 maxVol = *(uint8*)Setting_Get(SETID_MAX_VOLUME);
    if((step + me->vol)<= maxVol)
    {
        me->vol+=step;
    }
    else
    {
        me->vol = maxVol;
    }
	AudioSrv_SetVolume(me->vol);
    if(maxVol == me->vol)
    { /* send volume min tone command to BT, comment it for now*/      
        LedSrv_SetPatt((QActive*)me, 1<<LED_VOL_UP, VOL_LIMIT_REACH_PATT);
        isReachVolumeLimit = TRUE;
    }
    else
    {
        isReachVolumeLimit = FALSE;
    }
}

static void MainApp_RequestMuteAudio(cMainApp * const me, bool isMuteOn)
{
    AudioMuteReqEvt* muteReqEvt = Q_NEW(AudioMuteReqEvt, AUDIO_MUTE_SIG);
    muteReqEvt->mute = isMuteOn;
    muteReqEvt->sender = (QActive*)me;
    SendToServer(AUDIO_SRV_ID,(QEvt*)muteReqEvt);
}

static void MainApp_EjectExtBattery(cMainApp * const me)
{
    (void)me;
#ifdef HAS_POWER_CONTROL
#ifdef EXTERNAL_BATTERY
    PowerSrvEjectBatReqEvt* ejectBatteryReq = Q_NEW(PowerSrvEjectBatReqEvt, EJECT_EXT_BATTERY_REQ_SIG);
    ejectBatteryReq->sender = (QActive*)me;
    SendToServer(POWER_SRV_ID, (QEvt*)ejectBatteryReq);
#endif
#endif
}


static void MainApp_SendPowerDlgCmd(cMainApp * const me, eEmergencyModeCmd cmd)
{
#ifdef HAS_POWER_DELEGATE
    if(!isPowerDlgCreated)
    {
        return;
    }
    PowerDlgSetEvt* req = Q_NEW(PowerDlgSetEvt,POWER_EMERGENCY_MODE_REQ_SIG);
    req->cmd = cmd;
    req->sender = (QActive*)me;
    /* Post to Server using QPPost*/
    QACTIVE_POST((QActive*)&powerDlg, (QEvt*)req, 0);
#endif
}

static bool MainApp_IsPowerInBatteryMode()
{/* check if the DC (detect by ADC) or USB5V  is out */
    bool ret = TRUE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if((battInfo.inputSourceState.isDcPlugIn)||(battInfo.inputSourceState.isUsbPlugIn))
    {
        ret =FALSE;
    }
    return ret;
}

static bool MainApp_IsExtBatteryExisted()
{
    bool ret = FALSE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if(battInfo.extBattState < EJECT_BATT_STA)
    {
        ret = TRUE;
    }
    return ret;
}

static bool MainApp_IsReadyForSleep()
{/* this function check if the DC (detect by GPIO) and Micro USB is out, to make sure they are ready for interrupt */
    bool ret = FALSE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if((!battInfo.inputSourceState.isDcPlugInDetectByGPIO) &&
       (!battInfo.inputSourceState.isUsbPlugIn))
    {
        ret = TRUE;
    }
    return ret;
}

static int8 MainApp_GetBatteryLedCount(uint8 batteryState)
{
    int8 count;

    switch((eBatteryState)batteryState)
    {
        case BATT_95_100_PERT_STA:
        case BATT_76_94_PERT_STA:
        case EJECT_BATT_STA:
            count = 4;
            break;
        case BATT_51_75_PERT_STA:
            count = 3;
            break;
        case BATT_26_50_PERT_STA:
            count = 2;
            break;
        case BATT_16_25_PERT_STA:
        case BATT_5_15_PERT_STA:
        case BATT_0_5_PERT_STA:
        default:
            count = 1;
            break;
    }
    return count;
}

static bool MainApp_IsExtBattDockEject(cMainApp * const me, eBatteryType battType,
                                                    uint8 localBatteryState, bool isCharging)
{
    eBatteryState batteryState = (eBatteryState)localBatteryState;
    bool ret = FALSE;
    const uint32 EXT_BATT_LEDS_INDICATION[]=
    {
        EXT_BATT_LED_1,
        EXT_BATT_LED_2,
        EXT_BATT_LED_3,
        EXT_BATT_LED_4,
    };

    extBatteryDockInfo.calTimer += MAIN_APP_TIMEOUT_IN_MS;

    /*Control LED when external battery is ejecting or dockning*/
    if(TRUE==extBatteryDockInfo.isEjecting)
    {
        ret = TRUE;
        if((extBatteryDockInfo.ledCount >0) && (extBatteryDockInfo.calTimer%EXT_BATT_EJECT_INTERVAL_MS==0))
        {
            extBatteryDockInfo.ledCount--;
            LedSrv_SetPatt((QActive*)me, EXT_BATT_LEDS_INDICATION[extBatteryDockInfo.ledCount], OFF_PATT);
            /*Control solenoid to eject external battery when turning off LED1*/
            if(extBatteryDockInfo.ledCount <=0)
            {
                TP_PRINTF(">>> Eject SOL_ON!!\r\n");
                MainApp_EjectExtBattery(me);
                LedSrv_SetPatt((QActive*)me, 1<<LED_EJECT, EJECT_BATTERY_PATT);
            }
        }
        else if((extBatteryDockInfo.ledCount <=0) && (extBatteryDockInfo.calTimer%(EXT_BATT_EJECT_INTERVAL_MS+EXT_BATT_EJECT_INTERVAL_DELAY_MS)==0))
        {
            TP_PRINTF(">>> Eject Done!!\r\n");
            ret = FALSE;
        }
    }
    else if(TRUE==extBatteryDockInfo.isDocking)
    {
        ret = TRUE;
        if(extBatteryDockInfo.calTimer%EXT_BATT_INSERT_INTERVAL_MS==(EXT_BATT_INSERT_INTERVAL_MS-MAIN_APP_TIMEOUT_IN_MS))
        {   /* In case battery voltage is updated slowly, check it again before turn on each LED. */
            extBatteryDockInfo.ledCount = MainApp_GetBatteryLedCount(batteryState);
            TP_PRINTF(">>> Dock ledCount=%d!!\r\n",extBatteryDockInfo.ledCount);
        }
        if((extBatteryDockInfo.ledCount > extBatteryDockInfo.currCount) && (extBatteryDockInfo.calTimer%EXT_BATT_INSERT_INTERVAL_MS==0))
        {
            LedSrv_SetPatt((QActive*)me, EXT_BATT_LEDS_INDICATION[extBatteryDockInfo.currCount], SOLID_ON_PATT);
            extBatteryDockInfo.currCount++;
        }
        else if(TRUE==isExtBattDockInSleep && FALSE==isCharging)
        {
            if((extBatteryDockInfo.ledCount <= extBatteryDockInfo.currCount) && (extBatteryDockInfo.calTimer%(EXT_BATT_INSERT_INTERVAL_MS+EXT_BATT_INSERT_INTERVAL_DELAY_MS)==0))
            {
                TP_PRINTF(">>> Dock Done (sleep)!!\r\n");
                ret = FALSE;
            }
        }
        else if((extBatteryDockInfo.ledCount <= extBatteryDockInfo.currCount) && (extBatteryDockInfo.calTimer%EXT_BATT_INSERT_INTERVAL_MS==0))
        {
            TP_PRINTF(">>> Dock Done!!\r\n");
            ret = FALSE;
        }
    }

    return ret;
}

static void MainApp_ResetExtBattDockEject(tBatteryInfo battInfo)
{
    extBatteryDockInfo.isDocking = FALSE;
    extBatteryDockInfo.isEjecting = FALSE;
    extBatteryDockInfo.calTimer = 0;
    extBatteryDockInfo.currCount = 0;
    extBatteryDockInfo.ledCount = MainApp_GetBatteryLedCount(battInfo.extBattState);
}

//TODO: to finish the battery indication
static void MainApp_UpdateBatteryIndication(cMainApp * const me)
{
    static int32 countTimer = AC_PLUG_IN_BATT_LED_INDICATE_DELAY_MS;
    static eBatteryState preIntBattState = BATTERY_STATE_MAX;
    static eBatteryState preExtBattState = BATTERY_STATE_MAX;
    static bool preIsIntBattCharging = FALSE, preIsExtBattCharging = FALSE;
    bool isIntBattCharging = FALSE;
    bool isExtBattCharging = FALSE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    /* check if the battery state is valid*/
    if((battInfo.intBattState == BATTERY_STATE_MAX)||
       (battInfo.extBattState == BATTERY_STATE_MAX))
    {
        TP_PRINTF("battery state is not ready yet\r\n");
        return;
    }

    if(battInfo.inputSourceState.isDcPlugIn)
    {
        if(countTimer <= 0)
        {
            isIntBattCharging = TRUE;
            isExtBattCharging = TRUE;
            if(battInfo.inputSourceState.isChargingDone && countTimer <= 0)
            {   /* Base on CH_STATUS pin to judge internal battery charged full or not */
                battInfo.intBattState = BATT_95_100_PERT_STA;
            }
        }
        else
        {
            countTimer -= MAIN_APP_TIMEOUT_IN_MS;
        }
    }
    else if(battInfo.inputSourceState.isUsbPlugIn)
    {
        if(countTimer <= 0)
        {
            isExtBattCharging = TRUE;
            /*Start internal battery indication when external battery is full*/
            if(BATT_95_100_PERT_STA==battInfo.extBattState)
            {
                isIntBattCharging = TRUE;
                if(battInfo.inputSourceState.isChargingDone && countTimer <= 0)
                {   /* Base on CH_STATUS pin to judge internal battery charged full or not */
                    battInfo.intBattState = BATT_95_100_PERT_STA;
                }
            }
        }
        else
        {
            countTimer -= MAIN_APP_TIMEOUT_IN_MS;
        }
    }
    else
    {
        countTimer = AC_PLUG_IN_BATT_LED_INDICATE_DELAY_MS;
    }

    if(isExtBattEjectInSleep || extBatteryDockInfo.isEjecting)
    {   /* Eject Process... */
        if(FALSE==isExtBattEjectInSleep && FALSE==isExtBattDockInSleep && EJECT_BATT_STA==preExtBattState)
        {   /*If external battery doesn't exist, ignore the eject requested.*/
            TP_PRINTF(">>> Eject Quit, no battery!!\r\n");
            isExtBatteryEjecting = FALSE;
            isExtBattEjectInSleep = FALSE;
            MainApp_ResetExtBattDockEject(battInfo);
        }
        else
        {
            if(FALSE==MainApp_IsExtBattDockEject(me, EXT_BATTERY_TYPE, battInfo.extBattState, isExtBattCharging))
            {
                MainApp_ResetExtBattDockEject(battInfo);
                /* In case external battery is reloaded immediatly or ejected failed  */
                if(battInfo.extBattState<EJECT_BATT_STA || battInfo.inputSourceState.isExtBattDetectByGPIO)
                {
                    if(FALSE==isExtBattEjectInSleep && FALSE==isExtBattDockInSleep)
                    {
                        TP_PRINTF(">>> Eject Reload Immediately!!\r\n");
                        extBatteryDockInfo.isDocking = TRUE;
                    }
                    else
                    {
                        TP_PRINTF(">>> Eject Reload Immediately (Sleep)!!\r\n");
                        extBatteryDockInfo.isDocking = TRUE;
                        isExtBattDockInSleep = TRUE;
                    }
                }
                else
                {
                    TP_PRINTF(">>> Eject End!!\r\n");
                    isExtBattDockInSleep = FALSE;
                }
                preExtBattState = (eBatteryState)battInfo.extBattState;
                isExtBatteryEjecting = FALSE;
                isExtBattEjectInSleep = FALSE;
            }
        }
    }
    else if(isExtBattDockInSleep || extBatteryDockInfo.isDocking ||
           (FALSE==isExtBattDockInSleep && preExtBattState==EJECT_BATT_STA && EJECT_BATT_STA!=battInfo.extBattState))
    {   /* Dock Process... */
        if(FALSE==extBatteryDockInfo.isDocking)
        {
            TP_PRINTF(">>> Dock Start!!\r\n");
            MainApp_ResetExtBattDockEject(battInfo);
            extBatteryDockInfo.isDocking = TRUE;
        }
        else
        {
            if(FALSE==MainApp_IsExtBattDockEject(me, EXT_BATTERY_TYPE, battInfo.extBattState, isExtBattCharging) ||
               FALSE==battInfo.inputSourceState.isExtBattDetectByGPIO)
            {
                TP_PRINTF(">>> Dock End!!\r\n");
                isExtBattDockInSleep = FALSE;
                preExtBattState = BATTERY_STATE_MAX;
                MainApp_ResetExtBattDockEject(battInfo);
            }
        }
    }
    else if(isEmergencyMode)
    {   /* Emergency Process... only need to control internal battery LED indication */
        if(preIntBattState!= battInfo.intBattState)
        {
            preIntBattState = (eBatteryState)battInfo.intBattState;
            MainApp_ShowBatteryIndication(me, INT_BATTERY_TYPE, battInfo.intBattState, isIntBattCharging);
        }
        preExtBattState = BATTERY_STATE_MAX;
        MainApp_ResetExtBattDockEject(battInfo);
    }
    else
    {   /* Normal Process... */
        if(preIsIntBattCharging!= isIntBattCharging || preIntBattState!= battInfo.intBattState || FALSE==isBatteryLedInitialized)
        {   /* Internal Battery LED Control */
            preIsIntBattCharging = isIntBattCharging;
            preIntBattState = (eBatteryState)battInfo.intBattState;
            MainApp_ShowBatteryIndication(me, INT_BATTERY_TYPE, battInfo.intBattState, isIntBattCharging);
        }
        if(preIsExtBattCharging!= isExtBattCharging || preExtBattState!= battInfo.extBattState || FALSE==isBatteryLedInitialized)
        {   /* External Battery LED Control */
            preIsExtBattCharging = isExtBattCharging;
            preExtBattState = (eBatteryState)battInfo.extBattState;
            MainApp_ShowBatteryIndication(me, EXT_BATTERY_TYPE, battInfo.extBattState, isExtBattCharging);
        }
        isBatteryLedInitialized = TRUE;
        MainApp_ResetExtBattDockEject(battInfo);
    }
}

static void MainApp_ShowBatteryIndication(cMainApp * const me, eBatteryType battType,
                                                    uint8 batteryState, bool isCharging)
{     
    const uint32 INT_BATT_NOCHARGING_LEDS_SOLID[]=
    {
        ALL_INT_BATT_LEDS, //BATT_95_100_PERT_STA
        ALL_INT_BATT_LEDS, //BATT_76_94_PERT_STA
        THREE_INT_BATT_LEDS, //BATT_51_75_PERT_STA
        TWO_INT_BATT_LEDS, //BATT_26_50_PERT_STA
        ONE_INT_BATT_LEDS, //BATT_16_25_PERT_STA
        0, //BATT_5_15_PERT_STA
        0, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    const uint32 EXT_BATT_NOCHARGING_LEDS_SOLID[]=
    {
        ALL_EXT_BATT_LEDS, //BATT_95_100_PERT_STA
        ALL_EXT_BATT_LEDS, //BATT_76_94_PERT_STA
        THREE_EXT_BATT_LEDS, //BATT_51_75_PERT_STA
        TWO_EXT_BATT_LEDS, //BATT_26_50_PERT_STA
        ONE_EXT_BATT_LEDS, //BATT_16_25_PERT_STA
        0, //BATT_5_15_PERT_STA
        0, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    const uint32 INT_BATT_CHARGING_LEDS_SOLID[]=
    {
        ALL_INT_BATT_LEDS, //BATT_95_100_PERT_STA
        THREE_INT_BATT_LEDS, //BATT_76_94_PERT_STA
        TWO_INT_BATT_LEDS, //BATT_51_75_PERT_STA
        ONE_INT_BATT_LEDS, //BATT_26_50_PERT_STA
        0, //BATT_16_25_PERT_STA
        0, //BATT_5_15_PERT_STA
        0, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    const uint32 EXT_BATT_CHARGING_LEDS_SOLID[]=
    {
        ALL_EXT_BATT_LEDS, //BATT_95_100_PERT_STA
        THREE_EXT_BATT_LEDS, //BATT_76_94_PERT_STA
        TWO_EXT_BATT_LEDS, //BATT_51_75_PERT_STA
        ONE_EXT_BATT_LEDS, //BATT_26_50_PERT_STA
        0, //BATT_16_25_PERT_STA
        0, //BATT_5_15_PERT_STA
        0, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    const uint32 INT_BATT_CHARGING_LEDS_BLINK[]=
    {
        ZERO_INT_BATT_LEDS, //BATT_95_100_PERT_STA
        FOURTH_INT_BATT_LEDS, //BATT_76_94_PERT_STA
        THIRD_INT_BATT_LEDS, //BATT_51_75_PERT_STA
        SECOND_INT_BATT_LEDS, //BATT_26_50_PERT_STA
        FIRST_INT_BATT_LEDS, //BATT_16_25_PERT_STA
        FIRST_INT_BATT_LEDS, //BATT_5_15_PERT_STA
        FIRST_INT_BATT_LEDS, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    const uint32 EXT_BATT_CHARGING_LEDS_BLINK[]=
    {
        ZERO_EXT_BATT_LEDS, //BATT_95_100_PERT_STA
        FOURTH_EXT_BATT_LEDS, //BATT_76_94_PERT_STA
        THIRD_EXT_BATT_LEDS, //BATT_51_75_PERT_STA
        SECOND_EXT_BATT_LEDS, //BATT_26_50_PERT_STA
        FIRST_EXT_BATT_LEDS, //BATT_16_25_PERT_STA
        FIRST_EXT_BATT_LEDS, //BATT_5_15_PERT_STA
        FIRST_EXT_BATT_LEDS, //BATT_0_5_PERT_STA
        0, //EJECT_BATT_STA
    };
    if(isCharging)
    {
        if(battType == INT_BATTERY_TYPE)
        {
            LedSrv_SetPatt((QActive*)me, ALL_INT_BATT_LEDS, OFF_PATT );
            LedSrv_SetPatt((QActive*)me, INT_BATT_CHARGING_LEDS_SOLID[batteryState], SOLID_ON_PATT);
            LedSrv_SetPatt((QActive*)me, INT_BATT_CHARGING_LEDS_BLINK[batteryState], CHARGE_BATTERY_PATT);
        }
        else
        {
            LedSrv_SetPatt((QActive*)me, ALL_EXT_BATT_LEDS, OFF_PATT );
            LedSrv_SetPatt((QActive*)me, EXT_BATT_CHARGING_LEDS_SOLID[batteryState], SOLID_ON_PATT);
            LedSrv_SetPatt((QActive*)me, EXT_BATT_CHARGING_LEDS_BLINK[batteryState], CHARGE_BATTERY_PATT);
        }     
    }
    else
    {
        if(battType == INT_BATTERY_TYPE)
        {
            LedSrv_SetPatt((QActive*)me, ALL_INT_BATT_LEDS, OFF_PATT );          
            if(batteryState>=BATT_5_15_PERT_STA)
            {
                LedSrv_SetPatt((QActive*)me, 1<<LED_INT_BAT1, SHUTDOWN_BATT_PATT);
            }
            else
            {
                LedSrv_SetPatt((QActive*)me, INT_BATT_NOCHARGING_LEDS_SOLID[batteryState], SOLID_ON_PATT);
            }
        }
        else
        {
            LedSrv_SetPatt((QActive*)me, ALL_EXT_BATT_LEDS, OFF_PATT );
            if(batteryState==BATT_5_15_PERT_STA || batteryState==BATT_0_5_PERT_STA)
            {
                LedSrv_SetPatt((QActive*)me, 1<<LED_EXT_BAT1, SHUTDOWN_BATT_PATT);
            }
            else
            {
                LedSrv_SetPatt((QActive*)me, EXT_BATT_NOCHARGING_LEDS_SOLID[batteryState], SOLID_ON_PATT);
            }            
        }        
    }
}


static void MainApp_PublishSystemStatus(cMainApp * const me, eSystemStatus systemStatus)
{
    SystemStatusEvt *pe = Q_NEW(SystemStatusEvt, SYSTEM_STATE_SIG);
    pe->systemStatus = systemStatus;
    QF_PUBLISH(&pe->super, me);
}

static void MainApp_PlayPauseReset(void)
{
    trackDirection.spCount = 0;
    trackDirection.calTimer = 0;
}

static void MainApp_PlayPause(cMainApp * const me)
{
    if (trackDirection.spCount>0)
    {
        trackDirection.calTimer += MAIN_APP_TIMEOUT_IN_MS;
    }
    eCallState callState =  NO_CALL_STA;
    if(Setting_IsReady(SETID_CALLING_STATUS))
    {
        callState =  *(eCallState*)Setting_Get(SETID_CALLING_STATUS);
    }
    if ((trackDirection.calTimer >= BT_BACKWARD_TIMEOUT_MS)|| (callState!=NO_CALL_STA))
    { /* if the time exit set time, or when in calling status (no need to check double/triple press when in calling)*/
        /*Check how many times to press play,pause button*/
        switch (trackDirection.spCount)
        {
            case 0:
                break;
            case 1:
                {
                    TP_PRINTF("[%s] Send Play/Pause Cmd\n",__FUNCTION__);
                    eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
                    if(btStatus==BT_INCOMING_CALL_EST_STA)
                    {
                        BluetoothSrv_SendBtCmd((QActive*)me, BT_ANSWER_CMD);
                    }
                    else if((btStatus==BT_TWC_CALL_WAITING_STA) || (btStatus==BT_TWC_CALL_ON_HOLD_STA) )
                    {
                        BluetoothSrv_SendBtCmd((QActive*)me, BT_TWC_ACCEPT_WAITING_HOLD_ACTIVE_CMD);
                    }
                    else
                    {
                        BluetoothSrv_SendBtCmd((QActive*)me, BT_PLAY_PAUSE_CMD);
                    }

                    MainApp_PlayPauseReset();
                }
                break;
            case 2:
                {
                    TP_PRINTF("[%s] Send Forward Cmd\n",__FUNCTION__);
                    BluetoothSrv_SendBtCmd((QActive*)me, BT_AVRCP_SKIP_FORWARD_CMD);
                    MainApp_PlayPauseReset();
                }
                break;
            case 3:
                {
                    TP_PRINTF("[%s] Send Backward Cmd\n",__FUNCTION__);
                    BluetoothSrv_SendBtCmd((QActive*)me, BT_AVRCP_SKIP_BACKWORD_CMD);
                    MainApp_PlayPauseReset();
                }
                break;
            default:
                {
                    TP_PRINTF("[%s] More than 3 times or no press\n",__FUNCTION__);
                    MainApp_PlayPauseReset();
                }
                break;
        }
    }

}

static bool MainApp_IsSystemIdle(cMainApp * const me)
{
    bool ret = FALSE;
    if(MainApp_IsBtIdle() && MainApp_IsAuxInIdle() && MainApp_IsBatteryOnly())
    {
        ret = TRUE;
    }
    return ret;
}

static bool MainApp_IsBtIdle()
{
    bool ret = FALSE;
    eBtStatus btStatus = BT_MAX_STA;
    eAudioChannel channel = AUDIO_CHANNEL_INVALID;
    if(Setting_IsReady(SETID_BT_STATUS))
    {
        btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
        channel = *(eAudioChannel*)Setting_Get(SETID_CHANNEL);
        if( (btStatus==BT_CONNECTABLE_STA) || (btStatus==BT_CONNECTED_STA) || (btStatus==BT_DISCOVERABLE_STA) ||
            (btStatus==BT_STREAMING_A2DP_STA && channel==BT_CHANNEL && isMusicDetected==FALSE) )
        {
            ret = TRUE;
        }
    }
    return ret;
}

static bool MainApp_IsAuxInIdle()
{
    bool ret = TRUE;
    eAudioChannel channel = AUDIO_CHANNEL_INVALID;
    if(Setting_IsReady(SETID_CHANNEL))
    {
        channel = *(eAudioChannel*)Setting_Get(SETID_CHANNEL);
        if((channel==AUXIN_CHANNEL) && (isMusicDetected==TRUE))
        { // aux in is playing
            ret = FALSE;
        }
    }
    return ret;
}

static bool MainApp_IsBatteryOnly()
{
    bool ret = TRUE;
    tBatteryInfo battInfo;
    if(Setting_IsReady(SETID_BATT_INFO))
    {
        battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
        if(battInfo.inputSourceState.isDcPlugIn)
        { // only check if it's charging with DC. USB charging will still auto shut down
            ret = FALSE;
        }
    }
    return ret;
}

static void MainApp_StartBtDlg()
{
    QEvt* evt = Q_NEW(QEvt, MAINAPP_START_DLG_SIG);
    QACTIVE_POST((QActive*)&bluetoothDlg, evt, 0);
}

static void MainApp_StopBtDlg()
{
    QEvt* evt = Q_NEW(QEvt, MAINAPP_STOP_DLG_SIG);
    QACTIVE_POST((QActive*)&bluetoothDlg, evt, 0);
}



static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e)
{
    KeyStateEvt *evt = (KeyStateEvt*)e;

    /*Forward, Backward track detection*/
    if (PLAY_PAUSE_KEY != (evt->keyId))
    {
        MainApp_PlayPauseReset();
    }

    switch(evt->keyEvent)
    {
        case KEY_EVT_UP:
            MainApp_KeyUpEvtAction(me, evt);
            break;
        case KEY_EVT_DOWN:
            MainApp_KeyDownEvtAction(me, evt);
            break;
        case KEY_EVT_SHORT_PRESS:
            MainApp_KeySPressEvtAction(me, evt);
            break;
        case KEY_EVT_LONG_PRESS:
            MainApp_KeyLPressEvtAction(me, evt);
            break;
        case KEY_EVT_VERY_LONG_PRESS:
            MainApp_KeyVLPressEvtAction(me, evt);
            break;
        case KEY_EVT_HOLD:
            MainApp_KeyHoldEvtAction(me, evt);
            break;
        case KEY_EVT_REPEAT:
            MainApp_KeyRepeatEvtAction(me, evt);
            break;
        case KEY_EVT_VERY_LONG_HOLD:
            MainApp_KeyVeryLHoldEvtAction(me, evt);
            break;
        default:break;
    }
}
static void MainApp_KeyUpEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{

}
static void MainApp_KeyDownEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
#ifdef BT_NFC_PAIR
        case NFC_TAG_KEY:
        {
            eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
            if(btStatus != BT_DISCOVERABLE_STA)
            {
                 BluetoothSrv_SendBtCmd((QActive*)me, BT_ENTER_PAIRING_CMD);
                 BtNfcEvt* indEvt = Q_NEW(BtNfcEvt,BT_NFC_IND_SIG);
                 SendToServer(DSS_SRV_ID, (QEvt*)indEvt);
                 TP_PRINTF("NFC Key Down. Go pairing mode!\r\n");
            }
            break;
        }
#endif
        default:break;
    }

}

static void MainApp_KeySPressEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
        case POWER_KEY:
        {
            eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
            if(btStatus == BT_INCOMING_CALL_EST_STA)
            { //1st call
                BluetoothSrv_SendBtCmd((QActive*)me, BT_REJECT_CMD);
            }
            else if (btStatus == BT_TWC_CALL_WAITING_STA)
            { // 2nd call coming
                BluetoothSrv_SendBtCmd((QActive*)me, BT_TWC_RELEASE_ALL_HELD_CMD);
            }
            else if ((btStatus == BT_ACTIVE_CALL_STA) || (btStatus == BT_TWC_CALL_ON_HOLD_STA))
            {
                BluetoothSrv_SendBtCmd((QActive*)me, BT_CANCEL_END_CMD);
            }
            else
            {
                isPowerDownReq = TRUE;
            }
            break;
        }
        case EJECT_KEY:
        {
            if(isExtBatteryEjecting == FALSE)
            {
                isExtBatteryEjecting = TRUE;
                extBatteryDockInfo.isEjecting = TRUE;
                extBatteryDockInfo.isDocking = FALSE;
            }
            break;
        }
        case PLAY_PAUSE_KEY:
        {
            trackDirection.spCount++;
            break;
        }
        case VOLUME_DOWN_KEY:
        {
            MainApp_VolumeDown(me, 1);
            break;
        }
        case VOLUME_UP_KEY:
        {
            MainApp_VolumeUp(me, 1);
            break;
        }
        case BT_KEY:
        {
#ifdef LOW_POWER_DRC_QUICK_TEST
            static eAudioPowerDrcLevel drcLevel = AUDIO_LOW_POWER_DRC_LEVEL;

            if(drcLevel == AUDIO_NORMAL_BATTERY_DRC_LEVEL)
            {
                drcLevel = AUDIO_LOW_POWER_DRC_LEVEL;
                LedSrv_SetPatt((QActive*)me, 1<<LED_POWER_RED, SOLID_ON_PATT);
            }
            else
            {
                drcLevel = AUDIO_NORMAL_BATTERY_DRC_LEVEL;
                LedSrv_SetPatt((QActive*)me, 1<<LED_POWER_RED, OFF_PATT);
            }            
            AudioSrc_SetDrcRange((QActive*)me,drcLevel);;
#endif
            eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
            if(btStatus == BT_DISCOVERABLE_STA)
            {
                  BluetoothDlg_GoConnectable((QActive*)me);
            }
            break;
        }
        /*if necessary, add the handler for more keys here */
        default:break;
    }
}
static void MainApp_KeyLPressEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
        default:
            break;
    }
}
static void MainApp_KeyVLPressEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
        default:
            break;
    }
}
static void MainApp_KeyHoldEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
        case POWER_KEY:
        {
            MainApp_EmergencyModeParse(me, TRUE);
            break;
        }
        case BT_KEY:
        {
            eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
            if(btStatus != BT_DISCOVERABLE_STA)
            {
                BluetoothSrv_SendBtCmd((QActive*)me, BT_ENTER_PAIRING_CMD);
            }
            break;
        }
        case VOLUME_DOWN_KEY:
        {
            if(isReachVolumeLimit)
            {
                MainApp_VolumeDown(me, 4);
            }
            break;
        }
        case VOLUME_UP_KEY:
        {
            if(isReachVolumeLimit)
            {
                MainApp_VolumeUp(me, 4);
            }
            break;
        }
        /*if necessary, add the handler for keys here */
        default:break;
    }
}

static void MainApp_KeyRepeatEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
    switch(e->keyId)
    {
        case VOLUME_DOWN_KEY:
        {
            if(FALSE==isReachVolumeLimit)
            {
                MainApp_VolumeDown(me, 4);
            }
            break;
        }
        case VOLUME_UP_KEY:
        {
            if(FALSE==isReachVolumeLimit)
            {
                MainApp_VolumeUp(me, 4);
            }
            break;
        }
        /*if necessary, add the handler for more keys here */
        default:break;
    }
}

static void MainApp_KeyVeryLHoldEvtAction(cMainApp * const me, KeyStateEvt const * const e)
{
  switch(e->keyId)
    {
        /*if necessary, add the handler for keys here */
        case POWER_KEY:
        {
            break;
        }
        case BT_KEY:
        {
            AudioSrv_SendAudioSrvToneCmd((QActive*)me, BT_TONE_RESET_PDL_CMD);
            BluetoothSrv_SendBtCmd((QActive*)me, BT_RESET_PAIR_LIST_CMD);
            MainApp_InitialVariablesForFactoryReset(me);
            break;
        }
        default:break;
    }
}

static void MainApp_EmergencyModeExit(cMainApp * const me)
{
    MainApp_SendPowerDlgCmd(me, EXIT_EMERGENCY_MODE_CMD);
    LedSrv_SetPatt((QActive*)me, EMERGENCY_MODE_FLASH_LEDS, EMERGENCY_MODE_PATT);
    LedSrv_SetPatt((QActive*)me, EMERGENCY_MODE_ON_LEDS, SOLID_ON_PATT);
}

static void MainApp_EmergencyModeEnter(cMainApp * const me)
{
    MainApp_SendPowerDlgCmd(me, ENTER_EMERGENCY_MODE_CMD);
    LedSrv_SetPatt((QActive*)me, EMERGENCY_MODE_FLASH_LEDS, EMERGENCY_MODE_PATT);
    LedSrv_SetPatt((QActive*)me, EMERGENCY_MODE_OFF_LEDS, OFF_PATT);
}

static void MainApp_EmergencyModeParse(cMainApp * const me, bool isEnable)
{
    if(isEnable)
    {
        if(FALSE==isEmergencyMode)
        {
            tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
            if((battInfo.intBattState <= BATT_16_25_PERT_STA) && (battInfo.extBattState >= BATT_5_15_PERT_STA) && (battInfo.extBattState != EJECT_BATT_STA)
                && (FALSE==battInfo.inputSourceState.isDcPlugIn) && (FALSE==battInfo.inputSourceState.isUsbPlugIn))
            {   /* If internal battery > 15%  & external battery <15%, allow to enter emergency mode */
                TP_PRINTF(">>> Emergency: Enter!!\r\n");
                isEmergencyMode = TRUE;
                MainApp_EmergencyModeEnter(me);
                if(isEmergencyModeInSleep)
                {
                    MainApp_ShowBatteryIndication(me, INT_BATTERY_TYPE, battInfo.intBattState, FALSE);
                }
            }
        }
    }
    else
    {
        if(isEmergencyMode)
        {
            TP_PRINTF(">>> Emergency: Exit!!\r\n");
            MainApp_EmergencyModeExit(me);
        }
    }
}

static bool MainApp_EmergencyModeQuit(cMainApp * const me)
{
    bool ret = FALSE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if(gEmergencyTimer > EMERGENCY_MODE_TIMEOUT_MS)
    {
         if(gEmergencyTimer >= (EMERGENCY_MODE_TIMEOUT_MS+READY_TO_ENTER_EMERGENCY_TIMEOUT_MS))
        {
            TP_PRINTF(">>> Emergency: Quit_End!!\r\n");
            ret = TRUE;
        }
    }
    else if((battInfo.intBattState >= BATT_5_15_PERT_STA) || (battInfo.extBattState == EJECT_BATT_STA)
          || (battInfo.inputSourceState.isDcPlugIn) || (battInfo.inputSourceState.isUsbPlugIn) || (gEmergencyTimer == EMERGENCY_MODE_TIMEOUT_MS))
    {   /* If int battery capacity is less than 15% or ext battery ejected or AC or Micro USB plun in, or 1 hour timeout, escape emergency mode */
        TP_PRINTF(">>> Emergency: Quit_Start!!\r\n");
        MainApp_EmergencyModeExit(me);
        gEmergencyTimer = EMERGENCY_MODE_TIMEOUT_MS;
    }
    gEmergencyTimer += MAIN_APP_TIMEOUT_IN_MS;
    return ret;
}

static bool MainApp_IsBatteryLowPowerOff(cMainApp * const me)
{
    bool ret = FALSE;
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if(battInfo.intBattState>=BATT_0_5_PERT_STA && battInfo.extBattState>=BATT_0_5_PERT_STA
       && (FALSE==battInfo.inputSourceState.isDcPlugIn) && (FALSE==battInfo.inputSourceState.isUsbPlugIn))
    {
        ret = TRUE;
    }
    return ret;
}

static void MainApp_UpdateAudioPowerDrcRange(cMainApp * const me)
{
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    if(battInfo.inputSourceState.isDcPlugIn)
    { /* adapter mode */
        AudioSrc_SetDrcRange((QActive*)me,AUDIO_ADAPTER_DRC_LEVEL);
    }
    else if((battInfo.intBattState>=BATT_5_15_PERT_STA) && (battInfo.extBattState>=BATT_5_15_PERT_STA))
    { /* low power mode <15%*/
        AudioSrc_SetDrcRange((QActive*)me,AUDIO_LOW_POWER_DRC_LEVEL);
    }
    else
    { /* normal battery mode*/
        AudioSrc_SetDrcRange((QActive*)me,AUDIO_NORMAL_BATTERY_DRC_LEVEL);
    }
}


/*
static void MainApp_ProductionTestExampleCode(cMainApp * const me)
{
    // Get battery info from setting server (Power server will keep updating this)
    tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
    // #c internal/externa battery voltage
    int16	intBatteryVol = battInfo.voltage.intBatteryVol;
    int16	extBatteryVol = battInfo.voltage.extBatteryVol;
    // #g DC9V level (voltage)
    int16   dcPlugInVoltage = battInfo.inputSourceState.dcPlugInVoltage;
    // #i Read Charging Status
    eChargerState chargerState= battInfo.chargerState;

    // #d,e Read MCU & DSP version
    char* mcuVersion = PRODUCT_VERSION_MCU;
    char* DSPVersion = PRODUCT_VERSION_DSP;

    // #h Read BT connection status
    eBtStatus btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);

    // #i control BT PWR
    BtCmdEvt* req = Q_NEW(BtCmdEvt,BT_REQ_SIG);
    req->btCmd = BT_PWR_ON_CMD; //BT_PWR_OFF_CMD
    req->sender = (QActive*)me;
    SendToServer(BT_SRV_ID, (QEvt*)req);

    // #j Sig Sens Det, already has it in debug server

    // #k AMP mute
    AudioMuteReqEvt* req3 = Q_NEW(AudioMuteReqEvt, AUDIO_MUTE_SIG);
    req3->mute = TRUE;
    req3->sender = (QActive*) me;
    SendToServer(AUDIO_SRV_ID,(QEvt *) req3);

    // #m control SOL ON/OFF
    PowerSrvSetEvt* req2 = Q_NEW(PowerSrvSetEvt, POWER_SET_SIG);
    req2->inputSource = IGNORE_INPUT_SET;
    req2->batterySource = IGNORE_BATTERY_SET;
    req2->extraCommand = ENABLE_SOL_CMD; //DISABLE_SOL_CMD
    req2->sender = (QActive*)me;
    SendToServer(POWER_SRV_ID, (QEvt*)req2);
}
*/


/*
static void MainApp_LedTestCode()
{

    static eLed ledId = LED_INT_BAT1;
    LedReqEvt* req = Q_NEW(LedReqEvt, LED_REQ_SIG);
    LedSrv_SetEvtOn((QActive*)me, req, 1<<ledId , 100);
    SendToServer(LED_SRV_ID, (QEvt*)req);
    ledId++;
    if(ledId>=LED_MAX)
    {
        ledId = LED_INT_BAT1;
    }

    LedReqEvt* req = Q_NEW(LedReqEvt, LED_REQ_SIG);
    req->leds = 1<<LED_INT_BAT1;
    LedSrv_SetPatt((QActive*)me, req, BT_DISCOVERABLE_PATT);
    SendToServer(LED_SRV_ID, (QEvt*)req);

    LedReqEvt* req2 = Q_NEW(LedReqEvt, LED_REQ_SIG);
    req2->leds = 1<<LED_INT_BAT3;
    LedSrv_SetPatt((QActive*)me, req2, SOLID_DIM_PATT);
    SendToServer(LED_SRV_ID, (QEvt*)req2);

}*/



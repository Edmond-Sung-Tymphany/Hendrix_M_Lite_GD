/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Main Application
                  -------------------------

                  SW Module Document




@file        MainApp.c
@brief       Main application for SVS14_Ultra
@author      Christopher Alexander,Bob.Xu
@date        2014-04-24
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-20     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "./MainApp_priv.h"
#include "projBsp.h"
#include "DisplaySrv.h"
#include "SettingSrv.h"
#include "Menu.config"
#include "trace.h"
#include "AudioSrv.h"
/* The objects owned by mainApp */
static cGpioDrv gpioDrv;
static cMenuDlg menuDlg;

/********************************************************************/
/*
* mandatoryAudioSett is the mandatory audio settings which has to be enabled 
* when the system is started.
*/
static const tPageIdDspSettIdMap mandatoryAudioSett[] =
{
    {PAGE_SETTING_VOL,    DSP_VOLUME_SETT_ID},
    {PAGE_SETTING_POLARI, DSP_PHASE_SETT_ID},
};
/*
* optionalAudioSett is the optional audio settings which may be enabled or disabled 
* by the user
*/
static const tPageIdDspSettIdMap optionalAudioSett[] =
{
    {PAGE_SETTING_LP_STATUS,    DSP_EQ_CTRL_USER_LP},
    {PAGE_SETTING_PEQ1_STATUS,  DSP_EQ_CTRL_PEQ1},
    {PAGE_SETTING_PEQ2_STATUS,  DSP_EQ_CTRL_PEQ2},
    {PAGE_SETTING_PEQ3_STATUS,  DSP_EQ_CTRL_PEQ3},
    {PAGE_SETTING_RGC_STATUS,   DSP_EQ_CTRL_RGC}
};

#define SYS_SETTING_DISPLAY     0 // Index of sysSettings
#define SYS_SETTING_TIMEOUT     1
#define SYS_SETTING_STANDBY     2
static tSysSetting sysSettings[] =
{
    {PAGE_SETTING_DISPLAY,    0},
    {PAGE_SETTING_TIMEOUT,    0},
    {PAGE_SETTING_STANDBY,    0}
};

/* System settings */
static int16 scTimeThreshold    = DEFAULT_TIMEOUT_SEC; //screensaver timer threshold, 10 second
static uint32 scTimer           = 0; //timer of screensaver
static uint32 standbyTimer      = 0;
static int16 standbyMode        = 0;
static int16 displayMode        = 0;
/********************************************************************/

/* pDatabase pointer to where all data saved */
static int16 * pDatabase = NULL;
static int16 * pPreset = NULL;

/* Menu and defualt page defination */
const static tPageNode * pDefaultPage = &volNode;

static eDisplayInfoStep displayInfoStep = DISP_INFO_STEP0;

#ifdef Q_SPY
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#else
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#endif

enum MainAppPriSignals /* main appp private signals */
{
    MAINAPP_TIMEOUT_SIG = MAX_SIG,
};

static uint8 txBuffer[NUM_OF_SCREEN_DIGIT+1]; /* sprintf reserve the last byte for '\0'*/

static BOOL isSysMute = FALSE;
/* 
 * These data is located in specific memory area. This will init the menu settings 
 * for setting server.
 */
static const int16 menuData[ArraySize(menuDataAttr)]= 
{800,120,0,500,0,10,500,0,10,500,0,10,250,120,0,0,0,0,0,-200,0,100,0};
static const int16 preset1_region[ArraySize(menuDataAttr)] = 
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static const int16 preset2_region[ArraySize(menuDataAttr)]= 
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static const int16 preset3_region[ArraySize(menuDataAttr)] = 
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

static int16 currDataCopy[ArraySize(menuDataAttr)] = {0};

/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[10];

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    ROM_DADA(menuData);
    ROM_DADA(preset1_region);
    ROM_DADA(preset2_region);
    ROM_DADA(preset3_region);
    ASSERT(ArraySize(menuDataAttr) == NUM_OF_MENU_SETT_ITEMS);
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MainApp);
    QS_OBJ_DICTIONARY(MainApp_PreActive);
   
     /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), MAINAPP_TIMEOUT_SIG,
                            MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);
    /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif

#ifdef HAS_BLE_CTRL
    QActive_subscribe((QActive*) me, SETTING_UPDATE_SIG);
#endif
}

void MainApp_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Application_Xtor((cApplication*)me);
    
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const *const e)
{
    tGPIODevice *pPowerConf;
    pPowerConf = (tGPIODevice*)getDevicebyId(POWER_DEV_ID,NULL);
    GpioDrv_Ctor(&gpioDrv,pPowerConf);
    GpioDrv_ClearBit(&gpioDrv,gpioDrv.gpioConfig->pGPIOPinSet[0].gpioId);
    /* pPreset is set to preset1 by default */
    pPreset = (int16*)Setting_Get(SETID_PRESET_1);
    /* initial the LED for demo usage */
    return Q_TRAN(&MainApp_PreActive);
}

/* PreActive state */
static QState MainApp_PreActive(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            /* Disable power supply for amplify */
            MainApp_SwitchMode(MainApp, POWERING_UP_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            SwitchModeRespEvt* evt = (SwitchModeRespEvt*)e;
            if (evt->modeId == POWERING_UP_MODE)
            {
                MainApp_SwitchMode(MainApp, NORMAL_MODE);
            }
            else if (evt->modeId == NORMAL_MODE)
            {
                MenuDlg_Ctor(&menuDlg, (QActive*)me, &menu);
                PersistantObj_RefreshTick((cPersistantObj*)MainApp,TEN_MS);
            }
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            /* Step1: wait until setting server is ready */
            if(Setting_IsReady(SETID_MENU_DATA))
            {
                pDatabase = (int16*)Setting_Get(SETID_MENU_DATA);
                memcpy(currDataCopy, pDatabase, ArraySize(menuDataAttr)*sizeof(int16));
                /* Recover previous user settings */
                MainApp_RecoverPreSett(me);
            }
            else
            {
                PersistantObj_RefreshTick((cPersistantObj*)MainApp, TEN_MS);
                return Q_HANDLED();
            }
            /* Step 2: display welcome info */
            if(displayInfoStep < DISP_INFO_BYE)
            {
                DisplaySrv_SendString(displayText[displayInfoStep]);
                PersistantObj_RefreshTick((cPersistantObj*)MainApp, SECONDS_IN_MS(TWO_SECONDS));
                displayInfoStep++;
                return Q_HANDLED();
            }
            /* Step 3: Enable power supply for amplify and go to active state*/
            GpioDrv_SetBit(&gpioDrv,gpioDrv.gpioConfig->pGPIOPinSet[0].gpioId);
            DisplaySrv_SetDimTime(DEFAULT_TIMEOUT_SEC);
            return Q_TRAN(MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            /* Two tasks before go to activate state */
            /* Task 1: reset displayInfoStep*/
            displayInfoStep = DISP_INFO_STEP0;
            /* Task 2: Display default page info */
            /* Dsiplay the info */
            MainApp_DisplayPageInfo(pDefaultPage);
            /* End of task 2 */
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp,SECONDS_IN_MS(TWO_SECONDS));
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            scTimer = 0; /* any key evt will reset the timer */
            standbyTimer = 0;
            if(POWER_KEY == evt->keyId && (evt->keyEvent == KEY_EVT_SHORT_PRESS || evt->keyEvent == KEY_EVT_DOWN))
            {
                DisplaySrv_SendString(displayText[DISP_INFO_BYE]);
                AudioSrv_Set(DSP_VOLUME_SETT_ID, DISABLED);
                MenuDlg_Xtor(&menuDlg);
                return Q_TRAN(MainApp_PreDeActive);
            }
            MainApp_ParseKeyEvent((cMainApp*)me,evt);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            return Q_TRAN(MainApp_DeActive);
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            scTimer++;
            standbyTimer++;
            MainApp_RefreshSysSett();
            if(standbyTimer >= (MINUTES_IN_MS(STANDBY_TIME_THRESHOLD_MIN) / TEN_MS) \
               && AUTO_STANDBY == standbyMode)
            {
                /* Setting is off, then turn off the screen */
                DisplaySrv_CleanScreen();
                standbyTimer = 0;
            }
            else if(scTimer >= (SECONDS_IN_MS(scTimeThreshold) / TEN_MS))
            {
                if(DISPLAY_OFF == displayMode)
                {
                    /* Setting is off, then turn off the screen */
                    DisplaySrv_CleanScreen();
                    scTimer = 0;
                }
                else if(DISPLAY_LOGO == displayMode)
                {
                    scTimer--;
                    if(DISP_INFO_STEP0 == displayInfoStep)
                    {
                        displayInfoStep = DISP_INFO_STEP1;
                    }
                    else if(DISP_INFO_STEP1 == displayInfoStep)
                    {
                        displayInfoStep = DISP_INFO_STEP0;
                    }
                    DisplaySrv_SendString(displayText[displayInfoStep]);
                    PersistantObj_RefreshTick((cPersistantObj*)MainApp, SECONDS_IN_MS(TWO_SECONDS));
                    return Q_HANDLED();
                }
            }
            QTimeEvt_armX(TIME_EVT_OF(me), GET_TICKS_IN_MS(1) * TEN_MS, 0);
            return Q_HANDLED();
        }
        case SETTING_UPDATE_SIG:
        {
            SettingUpdateEvt* pUpdEvt = (SettingUpdateEvt *)e;
            if(pUpdEvt->server_id == BLE_CTRL_SRV_ID)
            {
              scTimer = 0;
              standbyTimer = 0;
              MainApp_SyncSettFromBle(me);
              MainApp_RefreshSysSett();
              DisplaySrv_SetDimTime(scTimeThreshold);
            }
            return Q_HANDLED();
        }
        case VIEW_DLG_REQ_SIG:
        {
            uint8 settIndex = 0;
            MenuDataUpdate * pMenuDataEvt = (MenuDataUpdate *)e;
            if(PAGE_SETTING_RESET_YES == pMenuDataEvt->pPageNode->pageSettId)
            {
                AudioSrv_Set(DSP_VOLUME_SETT_ID, DISABLED);
                GpioDrv_ClearBit(&gpioDrv,gpioDrv.gpioConfig->pGPIOPinSet[0].gpioId);
                MenuDlg_Xtor(&menuDlg);
                return Q_TRAN(MainApp_SysReset);
            }
            else if(!MainApp_HandeSysSett(me,pMenuDataEvt))
            {
                /* Find index in database */
                settIndex = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
                /*update database */
                MainApp_UpdateDatabase(pMenuDataEvt,settIndex);
                /* Sett audio */
                MainApp_SetPageSetting(me,pMenuDataEvt->pPageNode,settIndex);
                /* Dsiplay the info */
                MainApp_DisplayPageInfo(pMenuDataEvt->pPageNode);
                MainApp_TrigerDataTxToBle(ONE_ITEM,settIndex);
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            displayInfoStep = DISP_INFO_STEP0;
            QTimeEvt_disarm(TIME_EVT_OF(me));
            Setting_Set(SETID_MENU_DATA, pDatabase);
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* DeActive state  -- power off */
static QState MainApp_PreDeActive(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp,SECONDS_IN_MS(TWO_SECONDS));
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            DisplaySrv_CleanScreen();
            return Q_TRAN(MainApp_DeActive);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState MainApp_SysReset(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp,SECONDS_IN_MS(TWO_SECONDS));
            DisplaySrv_SendString(RESET_DONE_TEXT);
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            if(displayInfoStep < DISP_INFO_BYE)
            {
                DisplaySrv_SendString(displayText[displayInfoStep]);
                PersistantObj_RefreshTick((cPersistantObj*)MainApp, SECONDS_IN_MS(TWO_SECONDS));
                displayInfoStep++;
                return Q_HANDLED();
            }
            MainApp_FactoryReset(me);
            MainApp_RecoverPreSett(me);
            GpioDrv_SetBit(&gpioDrv,gpioDrv.gpioConfig->pGPIOPinSet[0].gpioId);
            return Q_TRAN(MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            displayInfoStep = DISP_INFO_STEP0;
            MenuDlg_Ctor(&menuDlg, (QActive*)me, &menu);
            MainApp_DisplayPageInfo(pDefaultPage);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/* DeActive state  -- power off */
static QState MainApp_DeActive(QActive * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if((evt->keyEvent == KEY_EVT_SHORT_PRESS || evt->keyEvent == KEY_EVT_DOWN) && (evt->keyId == POWER_KEY))
            {
               return Q_TRAN(MainApp_PreActive);
            }
            else
            {
               return Q_HANDLED();
            }
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void MainApp_SwitchMode(cMainApp * const me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

static void MainApp_FormatString(int8 settIndex)
{
    memcpy(txBuffer,CLEAN_SCREEN,NUM_OF_SCREEN_DIGIT); // clean the buff
    if(FLOAT_TYPE(menuDataAttr[settIndex].valPerStep))
    {
      snprintf((char*)txBuffer, sizeof(txBuffer), (char*)menuDataAttr[settIndex].pUnitString, \
          ((float)pDatabase[settIndex]/(float)VALUE_MAGNIFICATION));                
    }
    else
    {
      snprintf((char*)txBuffer, sizeof(txBuffer), (char*)menuDataAttr[settIndex].pUnitString, \
          (pDatabase[settIndex]/VALUE_MAGNIFICATION));
    }  
}

static BOOL MainApp_HandeSysSett(QActive * const me, MenuDataUpdate * pMenuDataEvt)
{
    BOOL hasSysSett = TRUE;
    uint8 i;
    ePageSettingId pageSettId = pMenuDataEvt->pPageNode->pageSettId;
    switch(pageSettId)
    {
      case PAGE_SETTING_LP_ON:
      case PAGE_SETTING_HP_ON:
      case PAGE_SETTING_PEQ1_ON:
      case PAGE_SETTING_PEQ2_ON:
      case PAGE_SETTING_PEQ3_ON:
      case PAGE_SETTING_RGC_ON:
      case PAGE_SETTING_LP_OFF:
      case PAGE_SETTING_HP_OFF:
      case PAGE_SETTING_PEQ1_OFF:
      case PAGE_SETTING_PEQ2_OFF:
      case PAGE_SETTING_PEQ3_OFF:
      case PAGE_SETTING_RGC_OFF:
        {
          /* EQ on and off is special case */
          MainApp_HandleOnOffCase(me,pMenuDataEvt->pPageNode->pageSettId);
        }
        break;
      case PAGE_SETTING_PRE1_LOAD:
      case PAGE_SETTING_PRE2_LOAD:
      case PAGE_SETTING_PRE3_LOAD:
      case PAGE_SETTING_PRE1_SAVE:
      case PAGE_SETTING_PRE2_SAVE:
      case PAGE_SETTING_PRE3_SAVE:
        {
            /* Preset is another special case */
            MainApp_HandlePresetCase(me,pMenuDataEvt->pPageNode->pageSettId);
        }
        break;
      case PAGE_SETTING_DISPLAY:
      case PAGE_SETTING_STANDBY:
        {
            i = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
            MainApp_UpdateDatabase(pMenuDataEvt,i);
            MainApp_RefreshSysSett();
            MainApp_SendStandbyString(i);
            MainApp_TrigerDataTxToBle(ONE_ITEM,i);
        }
        break;
      case PAGE_SETTING_TIMEOUT:
        {
            i = MainApp_SearchSettIndex(pMenuDataEvt->pPageNode->pageSettId);
            MainApp_UpdateDatabase(pMenuDataEvt,i);
            MainApp_RefreshSysSett();
            DisplaySrv_SetDimTime(scTimeThreshold);
            MainApp_FormatString(i);
            DisplaySrv_SendString(txBuffer);
            MainApp_TrigerDataTxToBle(ONE_ITEM,i);
        }
        break;
      case PAGE_SETTING_RESET_NO:
        {
          return hasSysSett;
        }
      case PAGE_SETTING_BT_ON:
          MainApp_SendBtCmd(BT_CONNECT_CMD);
          break;
      case PAGE_SETTING_BT_OFF:
          MainApp_SendBtCmd(BT_OFF_CMD);
          break;
      case PAGE_SETTING_CLEAR_BT:
          MainApp_SendBtCmd(BT_RESET_PAIR_LIST_CMD);
          break;
      default:
        {
            hasSysSett = FALSE;
        }
        break;
    }
    return hasSysSett;
}

static void MainApp_FactoryReset(QActive * const me)
{
    int8 i = 0;
    /* Reset current value */
    for(i = 0; i < ArraySize(menuDataAttr); i++)
    {
        pDatabase[i] = menuDataAttr[i].defaultVal;
    }
    /* Reset all presets to 0 */
    pPreset = (int16*)Setting_Get(SETID_PRESET_1);
    memset(pPreset,0,ArraySize(menuDataAttr));
    pPreset = (int16*)Setting_Get(SETID_PRESET_2);
    memset(pPreset,0,ArraySize(menuDataAttr));
    pPreset = (int16*)Setting_Get(SETID_PRESET_3);
    memset(pPreset,0,ArraySize(menuDataAttr));
    /* Trigger setting server to update flash data */
    Setting_Set(SETID_MENU_DATA, pDatabase);
    MainApp_TrigerDataTxToBle(NUM_OF_MENU_SETT_ITEMS,NO_OFFSET);
}

static void MainApp_SyncSettFromBle(QActive * const me)
{
    int8 settIndex;
    ePageSettingId  settingId;
    /* Find which item is changed */
    for(settIndex = 0; settIndex < ArraySize(menuDataAttr); settIndex++)
    {
        if(currDataCopy[settIndex] != pDatabase[settIndex])
        {
            memcpy(currDataCopy,pDatabase,ArraySize(menuDataAttr)*sizeof(int16));
            break;
        }
    }
    if(settIndex == ArraySize(menuDataAttr))
    {
        return;
    }
    settingId = menuDataAttr[settIndex].settingId;
    /* Sett settings and display related info */
    if(settingId >= PAGE_SETTING_LP_ON && settingId <= PAGE_SETTING_RGC_OFF)
    {
        /* EQ on and off is special case */
        MainApp_HandleOnOffCase(me,menuDataAttr[settIndex].settingId);
    }
    else if(settingId >= PAGE_SETTING_PRE1_LOAD && settingId <= PAGE_SETTING_PRE3_SAVE)
    {
        /* Preset is another special case */
        MainApp_HandlePresetCase(me,menuDataAttr[settIndex].settingId);
    }
    else if(settingId == PAGE_SETTING_STANDBY)
    {
        MainApp_SendStandbyString(settIndex);
    }
    else if(settingId == PAGE_SETTING_DISPLAY)
    {
        MainApp_SendDisplayString(settIndex);
    }
    else if(settingId == PAGE_SETTING_TIMEOUT)
    {
        MainApp_FormatString(settIndex);
        DisplaySrv_SendString(txBuffer);
    }
    else
    {
        /* Sett audio */
        AudioSrv_Set(menuDataAttr[settIndex].dspSettId, TRUE);
        /* Dsiplay the info */
        MainApp_FormatString(settIndex);
        if(PAGE_SETTING_POLARI == settingId) // degree is a special case
        {
           txBuffer[NUM_OF_SCREEN_DIGIT-1] = PHASE_DEGREE;
        }
        DisplaySrv_SendString(txBuffer);
    }
}

static void MainApp_SendDisplayString(uint8 index)
{
    int16 displayMode = pDatabase[index]/VALUE_MAGNIFICATION;
    switch(displayMode)
    {
      case DISPLAY_VOL:
        {
            DisplaySrv_SendString(VOLUME_TEXT);
            break;
        }
      case DISPLAY_LOGO:
        {
            DisplaySrv_SendString(LOGO_TEXT);
            break;
        }
      case DISPLAY_OFF:
        {
            DisplaySrv_SendString(OFF_TEXT);
            break;
        }
    default:break;
    }
}

static void MainApp_SendStandbyString(uint8 index)
{
    int16 modeOfstandby = pDatabase[index]/VALUE_MAGNIFICATION;
    switch(modeOfstandby)
    {
      case AUTO_STANDBY:
        {
            DisplaySrv_SendString(AUTO_TEXT);
            break;
        }
      case TRIGGER_STANDBY:
        {
            DisplaySrv_SendString(TRIGGER_TEXT);
            break;
        }
      case MANUAL_STANDBY:
        {
            DisplaySrv_SendString(MANUAL_TEXT);
            break;
        }
    default:break;
    }
}

static void MainApp_RecoverPreSett(QActive * const me)
{
    MainApp_RefreshSysSett();
    DisplaySrv_SetDimTime(scTimeThreshold);
    MainApp_RecoverAduioSett(me, mandatoryAudioSett, ArraySize(mandatoryAudioSett), TRUE);
    MainApp_RecoverAduioSett(me, optionalAudioSett, ArraySize(optionalAudioSett), FALSE);
}

static void MainApp_RefreshSysSett()
{
    int8 i = 0;
    int8 j = 0;
    for(i = 0; i < ArraySize(sysSettings); i++)
    {
        for(j = 0; j < ArraySize(menuDataAttr); j++)
        {
            if(sysSettings[i].settingId == menuDataAttr[j].settingId)
            {
                sysSettings[i].sysSetting = pDatabase[j]/VALUE_MAGNIFICATION;
            }
        }
    }
    displayMode = sysSettings[SYS_SETTING_DISPLAY].sysSetting;
    scTimeThreshold = sysSettings[SYS_SETTING_TIMEOUT].sysSetting;
    standbyMode = sysSettings[SYS_SETTING_STANDBY].sysSetting;
}
static void MainApp_RecoverAduioSett(QActive * const me, const tPageIdDspSettIdMap * pRecover, uint8 num, BOOL isMandatory)
{
    int8 i = 0;
    int8 j = 0;
    /* sett optional audio settings */
    for(i = 0; i < num; i++)
    {
        for(j = 0; j < ArraySize(menuDataAttr); j++)
        {
            if(pRecover[i].settingId == menuDataAttr[j].settingId)
            {
                BOOL enabled = TRUE;
                if(!isMandatory && (DISABLED == (pDatabase[j]/VALUE_MAGNIFICATION)))
                {
                    enabled = FALSE;
                }
                AudioSrv_Set(pRecover[i].dspSettId, enabled);
                break;
            }
        }
    }
}

static void MainApp_NextRGCValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case RGC_FREQ_31:
        pDatabase[index] = RGC_FREQ_25;
        break;
      case RGC_FREQ_40:
        pDatabase[index] = RGC_FREQ_31;
        break;
      default:break;
    }
}

static void MainApp_PreRGCValue(uint8 index)
{
    switch(pDatabase[index])
    {
      case RGC_FREQ_25:
        pDatabase[index] = RGC_FREQ_31;
        break;
      case RGC_FREQ_31:
        pDatabase[index] = RGC_FREQ_40;
        break;
      default:break;
    }
}

static void MainApp_UpdateDatabase(MenuDataUpdate * pMenuDataEvt, uint8 index)
{
    switch(pMenuDataEvt->keyId)
    {
     case PREV_KEY:
       {
         if(PAGE_SETTING_RGC_FREQ == pMenuDataEvt->pPageNode->pageSettId)
         {
            MainApp_PreRGCValue(index);
            return;
         }
         if(pDatabase[index] < menuDataAttr[index].maxVal)
         {
            pDatabase[index] += menuDataAttr[index].valPerStep;
         }
         else if(PAGE_SETTING_DISPLAY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_DISPLAY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
        else if(PAGE_SETTING_STANDBY == pMenuDataEvt->pPageNode->pageSettId &&\
           pDatabase[index] == menuDataAttr[index].maxVal)
         {
            /* PAGE_SETTING_STANDBY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].minVal;
         }
       }
       break;
     case NEXT_KEY:
       {
         if(PAGE_SETTING_RGC_FREQ == pMenuDataEvt->pPageNode->pageSettId)
         {
            MainApp_NextRGCValue(index);
            return;
         }
         if(pDatabase[index] > menuDataAttr[index].minVal)
         {
            pDatabase[index] -= menuDataAttr[index].valPerStep;
         }
         else if(PAGE_SETTING_DISPLAY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_DISPLAY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
        else if(PAGE_SETTING_STANDBY == pMenuDataEvt->pPageNode->pageSettId && \
           pDatabase[index] == menuDataAttr[index].minVal)
         {
            /* PAGE_SETTING_STANDBY is a special case, here we loop back */
            pDatabase[index] = menuDataAttr[index].maxVal;
         }
       }
       break;
      default:break;
    }
    /* Copy self to self, actually it only sends a update evt */
    Setting_Set(SETID_MENU_DATA, pDatabase);
}

static void MainApp_DisplayPageInfo(const tPageNode * pPageNode)
{
    switch(pPageNode->pageType)
    {
      case PAGE_NAVIGATION_TYPE:
        {
            DisplaySrv_SendString(pPageNode->pPageText);
        }
      break;
      case PAGE_ACTION_TYPE:
        {
            uint8 settIndex = 0;
            /* Find index in database */
            settIndex = MainApp_SearchSettIndex(pPageNode->pageSettId);
            MainApp_FormatString(settIndex);
            /* Dsiplay the info */
            if(PAGE_SETTING_POLARI == menuDataAttr[settIndex].settingId)
            {
                txBuffer[NUM_OF_SCREEN_DIGIT-1] = PHASE_DEGREE;
            }
            DisplaySrv_SendString(txBuffer);
        }
      break;
      default: break;
    }
}
static void MainApp_SetPageSetting(QActive * const me, const tPageNode * pPageNode, uint8 index)
{
    if(PAGE_NAVIGATION_TYPE != pPageNode->pageType)
    {
         AudioSrv_Set(menuDataAttr[index].dspSettId, TRUE);
    }
}
static uint8 MainApp_SearchSettIndex(ePageSettingId pageSettId)
{
    int8 i = 0;
    for(i = 0; i < ArraySize(menuDataAttr); i++)
    {
        if(pageSettId == menuDataAttr[i].settingId)
        {
           break;
        }
    }
    ASSERT(i != ArraySize(menuDataAttr));
    return i;
}

static void MainApp_HandleOnOffCase(QActive * const me, ePageSettingId pageSettId)
{
    ePageSettingId realSettId;
    BOOL           enabled = FALSE;
    switch(pageSettId)
    {
       case PAGE_SETTING_LP_OFF:
       case PAGE_SETTING_LP_ON:
         {
            realSettId = PAGE_SETTING_LP_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ1_OFF:
       case PAGE_SETTING_PEQ1_ON:
         {
            realSettId = PAGE_SETTING_PEQ1_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ2_OFF:
       case PAGE_SETTING_PEQ2_ON:
         {
             realSettId = PAGE_SETTING_PEQ2_STATUS;
         }
         break;
       case PAGE_SETTING_PEQ3_OFF:
       case PAGE_SETTING_PEQ3_ON:
         {
             realSettId = PAGE_SETTING_PEQ3_STATUS;
         }
         break;
       case PAGE_SETTING_RGC_OFF:
       case PAGE_SETTING_RGC_ON:
         {
             realSettId = PAGE_SETTING_RGC_STATUS;
         }
        default: break;
    }
    if(pageSettId >= PAGE_SETTING_LP_ON && pageSettId <= PAGE_SETTING_RGC_ON)
    {
        enabled = TRUE;
    }
    else if (pageSettId >= PAGE_SETTING_LP_OFF && pageSettId <= PAGE_SETTING_RGC_OFF)
    {
        enabled = FALSE;
    }
    else
    {
        /* It is not on off case, somewhere is wrong */
        ASSERT(0);
    }
    int8 i = 0;
    /* update data base and set the audio */
    i = MainApp_SearchSettIndex(realSettId);
    if(enabled)
    {
        pDatabase[i] = ENABLED * VALUE_MAGNIFICATION;
    }
    else
    {
        pDatabase[i] = DISABLED;
    }
    Setting_Set(SETID_MENU_DATA, pDatabase);
    AudioSrv_Set(menuDataAttr[i].dspSettId, enabled);
    MainApp_TrigerDataTxToBle(ONE_ITEM,i);
}

static void MainApp_HandlePresetCase(QActive * const me,ePageSettingId pageSettId)
{
    eSettingId settingId;
    switch(pageSettId)
    {
       case PAGE_SETTING_PRE1_LOAD:
       case PAGE_SETTING_PRE1_SAVE:
         {
            settingId = SETID_PRESET_1;
         }
         break;
       case PAGE_SETTING_PRE2_LOAD:
       case PAGE_SETTING_PRE2_SAVE:
         {
            settingId = SETID_PRESET_2;
         }
         break;
       case PAGE_SETTING_PRE3_LOAD:
       case PAGE_SETTING_PRE3_SAVE:
         {
            settingId = SETID_PRESET_3;
         }
        default: break;
    }
    pPreset = (int16*)Setting_Get(settingId);
    if(isPresetLoad)
    {
        if(PRESET_EMPTY == pPreset[0])// check if preset is empty
        {
            DisplaySrv_SendString(EMPTY_TEXT);
        }
        else
        {
            /* copy pPreset to current data */
            Setting_Set(SETID_MENU_DATA, pPreset);
            MainApp_RecoverPreSett(me);
            DisplaySrv_SendString(LOADED_TEXT);
            MainApp_TrigerDataTxToBle(NUM_OF_MENU_SETT_ITEMS,NO_OFFSET);
        }
    }
    else
    {
        /* copy pDatabase to preset */
        Setting_Set(settingId, pDatabase);
        DisplaySrv_SendString(SAVED_TEXT);
    }
}

static void MainApp_ParseKeyEvent(cMainApp * const me, KeyStateEvt const * const evt)
{
    BOOL volumeUp = TRUE;
    switch(evt->keyId)
    {
        case VOLUME_DOWN_KEY:
            volumeUp = FALSE;
        case VOLUME_UP_KEY:
          {
            MainApp_VolumeCtr((QActive*)me, evt,volumeUp);
          }
          break;
        case PRESET_KEY_1_LOAD:
          {
            pPreset = (int16*)Setting_Get(SETID_PRESET_1);
            MainApp_PresetKeyHandler((QActive*)me,evt);
            break;
          }
        case PRESET_KEY_2_LOAD:
          {
            pPreset = (int16*)Setting_Get(SETID_PRESET_2);
            MainApp_PresetKeyHandler((QActive*)me, evt);
          }
          break;
        case PRESET_KEY_3_LOAD:
          {
            pPreset = (int16*)Setting_Get(SETID_PRESET_1);
            MainApp_PresetKeyHandler((QActive*)me, evt);
          }
          break;
        case MUTE_KEY:
          {
            MainApp_MuteKeyHandler((QActive*)me,evt);
          }
          break;
        default:break;
    }
}

static void MainApp_MuteKeyHandler(QActive * const me, KeyStateEvt const * const e)
{
    switch(e->keyEvent)
    {
      case KEY_EVT_DOWN:
      case KEY_EVT_SHORT_PRESS:
      {
          if(isSysMute)
          {
              AudioSrv_Set(DSP_VOLUME_SETT_ID, ENABLED);
              isSysMute = FALSE;
          }
          else
          {
              isSysMute = TRUE;
              AudioSrv_Set(DSP_VOLUME_SETT_ID, DISABLED);
          }
          break;
      }
      default:break;
    }
}

static void MainApp_PresetKeyHandler(QActive * const me,KeyStateEvt const * const e)
{
    if(KEY_EVT_SHORT_PRESS == e->keyEvent || KEY_EVT_DOWN == e->keyEvent)
    {
        if(PRESET_EMPTY == pPreset[0])// check if preset is empty
        {
            DisplaySrv_SendString(EMPTY_TEXT);
        }
        else
        {
            /* copy pPreset to current data */
            Setting_Set(SETID_MENU_DATA, pPreset);
            MainApp_RecoverPreSett(me);
            DisplaySrv_SendString(LOADED_TEXT);
            /* data should be sync with phone, triger the request so that setting
            server will send a response which carries the data to BLE server. */
            MainApp_TrigerDataTxToBle(NUM_OF_MENU_SETT_ITEMS,NO_OFFSET);
            
        }
    }
}
static void MainApp_VolumeCtr(QActive * const me, KeyStateEvt const * const e, BOOL volUp)
{
    if(KEY_EVT_DOWN == e->keyEvent || KEY_EVT_REPEAT == e->keyEvent)
    {
        uint8 settIndex = 0;
        settIndex = MainApp_SearchSettIndex(PAGE_SETTING_VOL);
        if(volUp)
        {
          if(pDatabase[settIndex] < menuDataAttr[settIndex].maxVal)
          {
            pDatabase[settIndex] += menuDataAttr[settIndex].valPerStep;
            Setting_Set(SETID_MENU_DATA, pDatabase);
          }
        }
        else
        {
          if(pDatabase[settIndex] > menuDataAttr[settIndex].minVal)
          {
            pDatabase[settIndex] -= menuDataAttr[settIndex].valPerStep;
            Setting_Set(SETID_MENU_DATA, pDatabase);
          }
        }
        AudioSrv_Set(menuDataAttr[settIndex].dspSettId, TRUE);
        MainApp_FormatString(settIndex);
        DisplaySrv_SendString(txBuffer);
        MainApp_TrigerDataTxToBle(ONE_ITEM,settIndex);
    }
}

static void MainApp_TrigerDataTxToBle(uint16 numberOfSettItem, uint16 offset)
{
    SettingReadOffsetReqEvt* pReq = Q_NEW(SettingReadOffsetReqEvt, SETTING_READ_OFFSET_REQ_SIG);
    pReq->sender = GetServerPointer(BLE_CTRL_SRV_ID);
    pReq->setting_id = SETID_MENU_DATA;
    pReq->size = numberOfSettItem * sizeof(uint16);
    pReq->offset = offset;
    SendToServer(SETTING_SRV_ID, (QEvt*)pReq);
}

static void MainApp_SendBtCmd(eBtCmd btCmd)
{
    BtCmdEvt *pEvt = Q_NEW(BtCmdEvt,BT_REQ_SIG);
    pEvt->btCmd = btCmd;
    SendToServer(BLE_CTRL_SRV_ID, (QEvt*)pEvt);
}

/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Public project Bsp interfaces
                  -------------------------

                  SW Module Document




@file        projBsp.h
@brief       This file implements the public project bsp interfaces which declared
             at projBsp.h
@author      Bob.Xu
@date        2014-06-12
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-12     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "bsp.h"
#include "projBsp.h"
#include "tp_hwsetup_pic32.h" //SYS_FREQ
#include "uartDrv.h"
#include "DebugSSrv.h"
#include "PowerSrv.h"
/* for bootloader */
#include "../../bootloaders/bl_pic32/src/hwsetup_lib/HardwareProfile_flash.h" //BOOT_FLASH_BASE_ADDRESS

void delay_us(uint32_t time_us) //busy waiting
{
    uint32 targetCount;
    uint32 bakupCount;

    // backup current count of the core timer.
    bakupCount = ReadCoreTimer();

    // Core timer increments every 2 sys clock cycles.
    // Calculate the counts required to complete "us".
    targetCount = CORE_COUNT_PER_US * time_us;

    // Restart core timer.
    WriteCoreTimer(0);

    // Wait till core timer completes the count.
    while(ReadCoreTimer() < targetCount);

    // Restore count back.
    WriteCoreTimer(bakupCount + targetCount);
}

/*..........................................................................*/
/**
* For Q_onAssert and _general_exception_handler to print the error message
*   The interrupts should be disabled before this function call
*   This function is a blocking print with UART with DEBUG_ID
*   This function will have the delay so the caller can continuously print
*
* NOTE:
*   DebugSrv.c and UartDrv.c are built as MIPS16 option, but bsp.c is built w/o MIPS16,
*   thus bsp.c can not jump to DebugSrvInputSourceCtor() and UartDrv_Write_Blocking().
*   ERROR:
*     ld.exe: build/release/production/_ext/2107377574/bsp.o: .text.ProjBsp_PrintError+0x60:
*     Unsupported jump between ISA modes; consider recompiling with interlinking enabled (-minterlink-compressed).
*   SOLUTION:
*     build bsp.c with -minterlink-compressed option.
*     REF: https://gcc.gnu.org/onlinedocs/gcc-4.9.0/gcc/MIPS-Options.html
*
* @param[in]    s               Error message String
*/
// ProjBsp_PrintError for Q_onAssert and _general_exception_handler
void ProjBsp_PrintError(const char* errString)
{
    tUARTDevice* debugDev = (tUARTDevice*)getDevicebyId(DEBUG_DEV_ID, NULL);

    if(debugDev != NULL)
    {
        //Initialize UART only one time
        if (!UartDrv_isUartReady(debugDev->uartId))
        {
            /* debug server should not be Ctor here. */
            //DebugSrvInputSourceCtor();
        }

        //Print if initialized is successful
        if (UartDrv_isUartReady(debugDev->uartId))
        {
            UartDrv_Flush(debugDev->uartId);
            UartDrv_Write_Blocking(debugDev->uartId, (const uint8 *)errString, strlen(errString));
        }
    }
}



void ProjBsp_CyclePrintError(char* errString)
{
    //Turn off all LEDs
    mLED_Blue = 0;
    mLED_Green= 0;
    mLED_Red  = 0;

#ifndef NDEBUG
    /* When connect to debugger, we could set assert_loop to FALSE to leave ASSERT()  */
    bool assert_loop= TRUE;

    //for debug build, print error with flashed RED led
    while(assert_loop) {
        BSP_FeedWatchdog();
        ProjBsp_PrintError(errString);
        delay_us(500*1000); //500ms
        mLED_Red_Tgl();
        DEBUGGER_PAUSE(); //pause if connect to debugger
    }
#else
    //for release build, print one times then reboot directly
    ProjBsp_PrintError(errString);
    ProjBsp_SoftReboot();
#endif
}


/* Durring firmware upgrade, MCU will reboot to bootloader while SAM is sending firmware and can not reboot.
 * Thus we let MCU "jump" back to bootloader instead of pull RESET pin.
 */
void ProjBsp_JumpToBootloader()
{
    //disable all interrupt
    IEC0= 0;  //Disable interrupt on IEC0
    IEC1= 0;  //Disable interrupt on IEC1
    INTDisableInterrupts();

    //jump back to bootloader
    void (*fptr)(void);
    fptr = (void (*)(void))BOOT_FLASH_BASE_ADDRESS;
    fptr();
    while (1) ;  /* Ensure completion of memory access */
}

void ProjBsp_SoftReboot()
{
    //disable all interrupt
    IEC0= 0;  //Disable interrupt on IEC0
    IEC1= 0;  //Disable interrupt on IEC1
    INTDisableInterrupts();

    SoftReset();
}
/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Public project Bsp interfaces
                  -------------------------

                  SW Module Document




@file        projBsp.h
@brief       This file implements the public project bsp interfaces which declared
             at projBsp.h
@author      Bob.Xu
@date        2014-07-14
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-12     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "stm32f0xx.h"

#include "bsp.h"
#include "projBsp.h"
#include "BluetoothDrv.h"
#include "powerDrv.h"
#include "KeySrv.h"
#include "I2CDrv.h"
#include "AudioAdcDrv.h"
#include "AudioSrv.h"
#include "setting_id.h"

extern cAudioAdcDrv audioAdcDrv;
static bool isBtInterruptEnable = FALSE;

static QActive* pSender = NULL;

static void PowerDrv_SetExtInterrupt(uint8 port, uint8 pin, uint32 extiLine,
                                                  EXTITrigger_TypeDef type, IRQn_Type irq, FunctionalState state);

void SetDisableWakeupSourcesFromStandby();
void SetDisableWakeupSources();

void ProjBsp_CyclePrintError(char* errString)
{
    /* To be implemented */
    //ProjBsp_PrintError(); refer to polkAllplayer
}

 /* initial the pin interrupt */
void EXTI_Config(bool isTurnOnInterrupt)
{
    EXTI_InitTypeDef   EXTI_InitStructure;
    NVIC_InitTypeDef   NVIC_InitStructure;

    /* Enable SYSCFG clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

   #ifdef BT_CODEC_STATUS_CHECK
    BluetoothDrv_EnableCodecStatus(isTurnOnInterrupt);
   #endif

    /* Connect EXTI0 Line to PB14 pin  BT status */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource14);
    /* Connect EXTI1 Line to PB15 pin  BT status */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource15);
    EXTI_InitStructure.EXTI_Line = EXTI_Line14 | EXTI_Line15;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
    if(isTurnOnInterrupt)
    {
        isBtInterruptEnable = TRUE;
        EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    }
    else
    {
        isBtInterruptEnable = FALSE;
        EXTI_InitStructure.EXTI_LineCmd = DISABLE;
    }
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel =  EXTI4_15_IRQn;//EXTI0_1_IRQn; 335
    NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}


/**
  * @brief  This function handles External line 0 interrupt request
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line0);
        SetDisableWakeupSourcesFromStandby();
        KeyEvtFromDrv *pte = Q_NEW(KeyEvtFromDrv,WAKE_UP_KEY_INTERRUPT_SIG);
        pte->keyId = POWER_KEY;
        SendToServer(KEY_SRV_ID, (QEvt*)pte);
    }
    if(EXTI_GetITStatus(EXTI_Line1) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line1);
        SetDisableWakeupSourcesFromStandby();
        KeyEvtFromDrv *pte = Q_NEW(KeyEvtFromDrv,WAKE_UP_KEY_INTERRUPT_SIG);
        pte->keyId = POWER_KEY;
        SendToServer(KEY_SRV_ID, (QEvt*)pte);
        }
    }
void SetSender(QActive* sender)
{
    pSender = sender;
        }
//eEnergySense
void SendEnergySenseSig()
{
    if (pSender)
    {
        QEvt* evt = Q_NEW(QEvt, ENERGYSENSE_SIG);
        QACTIVE_POST(pSender, evt, 0);
    }
}

void EXTI4_15_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line14) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line14);
        BluetoothDrv_ReadBtLedStatus(BT_INPUT0);
    }
    if(EXTI_GetITStatus(EXTI_Line15) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line15);
        if(isBtInterruptEnable)
        { /*it's BT LED1 interrupt*/
            BluetoothDrv_ReadBtLedStatus(BT_INPUT1);
        }
    }
    if(EXTI_GetITStatus(EXTI_Line7) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line7);
        SetEnergySenseMask(AUDIO_CHANNEL_INVALID);
        SendEnergySenseSig();
    }
}

uint8 GetAdcMode()
{
    return AudioAdcDrv_GetMode(&audioAdcDrv);
}
/* if bIsSigDetection TRUE  - switch to sleep to activate signal detection
  if bIsSigDetection FALSE - switch to active to activate signal loss */
void SwitchEnergySenseMode(bool bIsSigDetection)
{
    if (bIsSigDetection)
    {/* this is signal loss, so switch adc into sleep */
            AudioAdcDrv_SwitchToActive(&audioAdcDrv, FALSE);
            AudioSrv_SendMuteReq(pSender, TRUE);
        AudioAdcDrv_EnergySenseDSPMemMapCoefs(&audioAdcDrv, TRUE);
    }
    else
    {/*this is signal detection, so switch adc into active */
        AudioAdcDrv_SwitchToActive(&audioAdcDrv, TRUE);
        AudioSrv_SendMuteReq(pSender, FALSE);
        AudioAdcDrv_EnergySenseDSPMemMapCoefs(&audioAdcDrv, FALSE);
    }
}

void SetEnergySenseMask(eAudioChannel maskChannel)
{

    switch(maskChannel)
    {
    case AUDIO_CHANNEL_RCA: // rca
      AudioAdcDrv_SetEnergySenseMask(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT1_MASK);
      break;
    case AUDIO_CHANNEL_1:   // aux
      AudioAdcDrv_SetEnergySenseMask(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT2_MASK);
      break;
    case AUDIO_CHANNEL_2:   // bt
      AudioAdcDrv_SetEnergySenseMask(&audioAdcDrv, AUDIO_ADC_ANALOG_DIFF_INPUT3_MASK);
      break;
    default:                // mask all channels
        AudioAdcDrv_SetEnergySenseMask(&audioAdcDrv, 0xFF);
      break;
    }
}


void MuteAdc(bool mute)
{
    if (mute)
    {
       AudioAdcDrv_SwitchToActive(&audioAdcDrv, FALSE);
    }
    else
    {
        AudioAdcDrv_SwitchToActive(&audioAdcDrv, TRUE);
    }
}

void EXTI2_3_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line2) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line2);
        SetDisableWakeupSources();
        if (pSender)
        {
            QEvt* evt = Q_NEW(QEvt, POWER_SWITCH_SIG);
            QACTIVE_POST(pSender, evt, 0);
        }

    }
}

static void PowerDrv_SetExtInterrupt(uint8 port, uint8 pin, uint32 extiLine,
                                                  EXTITrigger_TypeDef type, IRQn_Type irq, FunctionalState state)
{
    /* Enable the interrupts */
    EXTI_InitTypeDef   EXTI_InitStructure;
    NVIC_InitTypeDef   NVIC_InitStructure;

    /* Connect EXTI Line to gpio pin */
    SYSCFG_EXTILineConfig(port, pin);
    /* Configure EXTI line */
    EXTI_InitStructure.EXTI_Line = extiLine;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = type;
    EXTI_InitStructure.EXTI_LineCmd = state;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set EXTI Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = irq;
    NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
    NVIC_InitStructure.NVIC_IRQChannelCmd = state;
    NVIC_Init(&NVIC_InitStructure);
}

void SetSignalLossDetectInt()
{
    //disable it for now
    //PowerDrv_DisableEXTI_Config();

    GPIO_InitTypeDef GPIO_InitStructure;
    /* Initial GPIO for AC interrupt as it's used for ADC in running time*/
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

     PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource7,
                   EXTI_Line7, EXTI_Trigger_Rising, EXTI4_15_IRQn, ENABLE);
//     PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource7,
//                   EXTI_Line7, EXTI_Trigger_Rising_Falling, EXTI4_15_IRQn, ENABLE);
}

void SetEnableWakeupSourcesFromStandby()
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_Init(GPIOA, &GPIO_InitStructure);


    PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource0,
                   EXTI_Line0, EXTI_Trigger_Rising, EXTI0_1_IRQn, ENABLE);


    PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource1,
                   EXTI_Line1, EXTI_Trigger_Rising, EXTI0_1_IRQn, ENABLE);

}
void SetDisableWakeupSourcesFromStandby()
{

  PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource0,
                   EXTI_Line0, EXTI_Trigger_Rising, EXTI0_1_IRQn, DISABLE);


    PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource1,
                   EXTI_Line1, EXTI_Trigger_Rising, EXTI0_1_IRQn, DISABLE);

}
void SetEnableWakeupSources()
{
    //disable it for now
    //PowerDrv_DisableEXTI_Config();

    GPIO_InitTypeDef GPIO_InitStructure;
    /* Initial GPIO for AC interrupt as it's used for ADC in running time*/
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /* Initial audio detect interrupt */
    /* Initial and power key to PA2 pin*/
    
    PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource2,
                   EXTI_Line2, EXTI_Trigger_Rising_Falling, EXTI2_3_IRQn, ENABLE);
}
#ifdef BT_CODEC_STATUS_CHECK
void SetEnableCodecStatus(bool bEnable)
{
    EXTI_InitTypeDef   EXTI_InitStructure;
    NVIC_InitTypeDef   NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
    /* Codec Status */
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource0);
    /* Configure EXTI0 line to PB0 */
    EXTI_InitStructure.EXTI_Line = EXTI_Line0;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
     if(bEnable)
        EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    else
        EXTI_InitStructure.EXTI_LineCmd = DISABLE;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set EXTI0 Interrupt */
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPriority = 0x00;
     if(bEnable)
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
     else
        NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
    NVIC_Init(&NVIC_InitStructure);

}
#endif
void SetDisableWakeupSources()
{
    PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource2,
               EXTI_Line2, EXTI_Trigger_Rising_Falling, EXTI2_3_IRQn, DISABLE);
}

void SetDisableSignalLossDetectInt()
{
   PowerDrv_SetExtInterrupt(EXTI_PortSourceGPIOA, EXTI_PinSource7,
                   EXTI_Line7, EXTI_Trigger_Rising, EXTI4_15_IRQn, DISABLE);
}

void ProjBsp_SysClkUpdate()
{
}
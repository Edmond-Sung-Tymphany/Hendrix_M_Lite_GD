/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Main Application
                  -------------------------

                  SW Module Document




@file        MainApp.c
@brief       Main application for SVS14_Ultra
@author      Christopher Alexander,Bob.Xu
@date        2014-04-24
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-20     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "./MainApp_priv.h"
#include "projBsp.h"
#include "DisplaySrv.h"
#include "PowerDrv.h"
#include "SettingSrv.h"
#include "Menu.config"
#include "trace.h"
#include "AudioSrv.h"



#define MAIN_APP_TIMEOUT_IN_MS          20

#ifdef Q_SPY
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#else
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#endif

typedef struct
{
    cGpioDrv      ledHwObj;
}led_t;

enum MainAppPriSignals /* main appp private signals */
{
    MAINAPP_TIMEOUT_SIG = MAX_SIG,
};

static cPowerDrv powerDrv;
static led_t powerLed;
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[6];

static void powerLed_init(void);
static bool powerLed_status(void);
static void powerLed_on(void);
static void powerLed_off(void);


#define CAST_ME cMainApp * MainApp = (cMainApp *) me;

static QState MainApp_Initial(cMainApp * const me, QEvt const *const e);

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(cMainApp * const me, QEvt const * const e);

static QState MainApp_PoweringUp(cMainApp * const me, QEvt const * const e);

static QState MainApp_PoweringDwon(cMainApp * const me, QEvt const * const e);

static QState MainApp_DeActive(cMainApp * const me, QEvt const * const e);

static void MainApp_SwitchMode(cMainApp* me, uint16 modeId);

static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e);

static void volume_handler(cMainApp * const me, uint8 vol);

static void powerKey_handler(cMainApp * const me, eKeyEvent keyEvent);
/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[10];

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MainApp);
    QS_OBJ_DICTIONARY(MainApp_PreActive);
    PowerDrv_Ctor(&powerDrv);

     /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), MAINAPP_TIMEOUT_SIG,
                            MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);

    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
        /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif
}

void MainApp_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Application_Xtor((cApplication*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const *const e)
{
    /* initial the LED for demo usage */
    powerLed_init();
    return Q_SUPER(&MainApp_PoweringUp);
}

static QState MainApp_PoweringUp(cMainApp * const me, QEvt const * const e)
{
  static int16       power_init_timer;
  
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            power_init_timer = PowerDrv_InitialPower(&powerDrv);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            power_init_timer -= MAIN_APP_TIMEOUT_IN_MS;
            if ( power_init_timer <= 0 )
            {
                power_init_timer = PowerDrv_InitialPower(&powerDrv);
                if(power_init_timer <= 0)
                {
                    MainApp_SwitchMode(MainApp, NORMAL_MODE);
                }
                else
                {
                    PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
                }
            }
            else
            {
                PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            }

            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt* evt = (KeyStateEvt*)e;
            if((evt->keyId == VOLUME_KNOB_BASE_KEY_ID) || (evt->keyId == BASS_KNOB_BASE_KEY_ID) || (evt->keyId == TREBLE_KNOB_BASE_KEY_ID))
            {
                QActive_defer((QActive*)me, &deferredReqQue, e);
            }
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {

            return Q_TRAN(&MainApp_Active);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(cMainApp * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
            printf("main app active!");
            /*will implement this with UI later*/
            powerLed_on();
            AudioSrv_SetChannel((QActive *)me, AUDIO_CHANNEL_ANALOG_MIXED);
            AudioSrv_SystemTuning(SYSTEM_GAIN_SETT_ID, TRUE);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            while (QActive_recall((QActive*)me, &deferredReqQue)) {} // check if we have events(key_state_sig) in deferred queue
          break;
        case MAINAPP_TIMEOUT_SIG:
        {
          PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
          break;
        }
        case KEY_STATE_SIG:
        {
            MainApp_ParseKeyEvent(me, e);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
          break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState MainApp_PoweringDwon(cMainApp * const me, QEvt const * const e)
{
  //TODO:implement later
}

static QState MainApp_DeActive(cMainApp * const me, QEvt const * const e)
{
    //TODO:implement later
}

static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e)
{
    KeyStateEvt *evt = (KeyStateEvt*)e;
    switch(evt->keyId)
    {
        case VOLUME_KNOB_BASE_KEY_ID:
            volume_handler(me, evt->index);
            break;
        case BASS_KNOB_BASE_KEY_ID:
         {
            uEqDataPackage eqPackage;

            ASSERT(evt->keyId < 0xFFFF);        //id value overflow
            eqPackage.eqDataPackageId = DSP_EQ_CTRL_USER_LP;
            eqPackage.eqDataPackageIdex = evt->index;
            AudioSrv_SetEq(eqPackage.eqDataPackage, TRUE);
         }
            break;
        case TREBLE_KNOB_BASE_KEY_ID:
        {
            uEqDataPackage eqPackage;

            ASSERT(evt->keyId < 0xFFFF);
            eqPackage.eqDataPackageId = DSP_EQ_CTRL_USER_HP;
            eqPackage.eqDataPackageIdex = evt->index;
            AudioSrv_SetEq(eqPackage.eqDataPackage, TRUE);
        }
        case POWER_KEY:
        {
            powerKey_handler(me, evt->keyEvent);
        }
        break;
        default:
            break;
    }
}

static void powerKey_handler(cMainApp * const me, eKeyEvent keyEvent)
{
    switch(keyEvent)
    {
        case KEY_EVT_SHORT_PRESS:
          
          break;

        case KEY_EVT_LONG_PRESS:
          
          break;
        default:
          break;
    }
}

static void volume_handler(cMainApp * const me, uint8 vol)
{
    AudioSrv_SetVolume(vol);
}


static void MainApp_SwitchMode(cMainApp* me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

static void powerLed_init(void)
{
    uint16 attached_device_index = 0;
    tGPIODevice *pLedGPIOConf;

    pLedGPIOConf = (tGPIODevice*)getDevicebyId(LED_DEV_ID,&attached_device_index);
    GpioDrv_Ctor(&powerLed.ledHwObj,pLedGPIOConf);
    powerLed_off();
}


static bool powerLed_status(void)
{
  return (GpioDrv_ReadBit(&powerLed.ledHwObj,GPIO_21) ? FALSE : TRUE);
}

static void powerLed_on(void)
{
    GpioDrv_ClearBit(&powerLed.ledHwObj,GPIO_21);
}

static void powerLed_off(void)
{
   GpioDrv_SetBit(&powerLed.ledHwObj,GPIO_21);
}


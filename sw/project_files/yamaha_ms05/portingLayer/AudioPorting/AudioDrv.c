/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document
 
@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service 
@author      Bob.Xu 
@date        2015-06-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioDrv_priv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "I2CDrv.h"
#include "DspInitTab.h"
#include "DspDrv_tas5754.h"
#include "pcm1862Drv.h"

typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
}tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},
    {DSP_BASS_SETT_ID,    SETID_BASS},
    {DSP_TREBLE_SETT_ID,  SETID_TREBLE},
};

static cI2CDrv          Tas5754i2cObjTW;
static cDspTas5754      DspTas5754TW;
static cI2CDrv          Tas5754i2cObjWF;
static cDspTas5754      DspTas5754WF;

static cI2CDrv          Pcm1862i2cObj;
static cAdcDrv_pcm1862  AdcPcm1862;

static void AudioDrv_DspVolSetId_Handler(void);
static void AMP_TempMonitor();

/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    uint16 device_index = 0;

    ASSERT(me);
    Tas5754i2cObjTW.pConfig = (tI2CDevice*)getDevicebyId(AMP_TWEETER_1_DEV_ID, NULL);
    DspTas5754TW.initData = (uint8 *)registersTW;
    ASSERT(Tas5754i2cObjTW.pConfig || DspTas5754TW.initData);
    DspTas5754_Ctor(&DspTas5754TW,&Tas5754i2cObjTW);

    Tas5754i2cObjWF.pConfig = (tI2CDevice*)getDevicebyId(AMP_WOOFER_1_DEV_ID, NULL);
    DspTas5754WF.initData = (uint8 *)registersWF;
    ASSERT(Tas5754i2cObjWF.pConfig || DspTas5754WF.initData);
    DspTas5754_Ctor(&DspTas5754WF,&Tas5754i2cObjWF);

    Pcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_DEV_ID, NULL);
    ASSERT(Pcm1862i2cObj.pConfig);
    AdcDrv_pcm1862_Ctor(&AdcPcm1862, &Pcm1862i2cObj);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    AdcDrv_pcm1862_Xtor(&AdcPcm1862);
    DspTas5754_Xtor(&DspTas5754TW);
    DspTas5754_Xtor(&DspTas5754WF);
    /* Fill me in! */
}

BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {
        DspTas5754_Init(&DspTas5754TW);
        DspTas5754_Init(&DspTas5754WF);
        AdcDrv_pcm1862_Init(&AdcPcm1862);
        me->drvIsReady = TRUE;
    }
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set 
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    if (AUDIO_CHANNEL_AUXIN == audioChannel)
    {
        AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT1 | PCM1862_ANALOG_DIFF_INPUT2));
    }
    else if (AUDIO_CHANNEL_RCA == audioChannel)
    {
        AdcDrv_pcm1862_SetInput(&AdcPcm1862, PCM1862_ANALOG_DIFF_INPUT1);
    }
    else if(AUDIO_CHANNEL_ANALOG_MIXED == audioChannel)
    {
  //    AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT1 | PCM1862_ANALOG_DIFF_INPUT2));
        AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_INPUT3));
    }
    else{}
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *audioDrvObj)
{
    AudioDrv_CheckJackInStatus();
    AudioDrv_CheckMusicStreamStatus();
}

void AudioDrv_CheckJackInStatus(void)
{
    
}

/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    AudioMusicDetectStateEvt* pAudioMusicStateEvt;
    pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
    QF_PUBLISH(&pAudioMusicStateEvt->super, dummy);
}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    uEqDataPackage * deviceData = (uEqDataPackage*)&audioSettId;

    ASSERT(deviceData->eqDataPackageId < AUDIO_SETT_ID_MAX);

    switch (deviceData->eqDataPackageId)
    {
        case DSP_VOLUME_SETT_ID:
             AudioDrv_DspVolSetId_Handler();
             break;

        case SYSTEM_GAIN_SETT_ID:
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1L, MAX_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1R, MAX_VOLUME);
             AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH2R, MAX_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH2L, MAX_VOLUME);
             AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH2R, MAX_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH2L, MAX_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH1R , MAX_VOLUME);

            AdcDrv_pcm1862_SetPGA(&AdcPcm1862, 0x00);
            break;
 //       case DSP_EQ_CTRL_USER_LP:
          {
            uint8 lpIdex;

            lpIdex = deviceData->eqDataPackageIdex;
            DspTas5754_EqTurning(&DspTas5754TW, BASS_SHELF_TURNING_ID, &lpIdex);
          }
            break;
//        case DSP_EQ_CTRL_USER_HP:
          {
            uint8 lpIdex;

            lpIdex = deviceData->eqDataPackageIdex;
            DspTas5754_EqTurning(&DspTas5754TW, TREBLE_SHELF_TURNING_ID, &lpIdex);
          }
            break;
        default:
             break;
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    DspTas5754_Mute(&DspTas5754TW,muteType,muteEnable);
}

/**
 * Function to monitor the amp status
 */
void AudioDrv_AmpSafetyMonitor()
{
    AMP_TempMonitor();
}


static void AMP_TempMonitor()
{
}

static void AudioDrv_DspVolSetId_Handler(void)
{
    uint8 volumeLevel = MIN_VOLUME;

    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);
    if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
    {
        AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH1L, volumeLevel);
        AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1R, volumeLevel);
    }
}

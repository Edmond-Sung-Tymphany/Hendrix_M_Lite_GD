/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Main Application
                  -------------------------

                  SW Module Document




@file        MainApp.c
@brief       Main application for SVS14_Ultra
@author      Christopher Alexander,Bob.Xu
@date        2014-04-24
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-20     Christopher
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "./MainApp_priv.h"
#include "projBsp.h"
#include "DisplaySrv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"



#define MAIN_APP_TIMEOUT_IN_MS          20
#define MAX_2_8V_mVOLT (2880)
#define MAX_2_8V_ADC   (3656)
#define MIN_2_8V_ADC   (3600)
#define POWER_DETECT_THRESHOLD_ADC  3200 //2.42v
#define START_UP_MUTE_DELAY_TIMER   30
#define AUDIO_SETTING_DELAY_TIMER   7

#ifdef Q_SPY
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#else
#define CAST_ME cMainApp * MainApp = (cMainApp *) me;
#endif

typedef struct
{
    cGpioDrv      ledHwObj;
} led_t;

enum MainAppPriSignals /* main appp private signals */
{
    MAINAPP_TIMEOUT_SIG = MAX_SIG,
};

static cADCDrv     PowerAdcDrv;

static cGpioDrv      powerPinObj;
static led_t powerLed;
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[6];

#define POWER_DETECT_TIME   25
#define SW_RESET_TIME   10
static uint8 PowerDetTimer = POWER_DETECT_TIME;
static uint8 SwResetTimer = 0;
static BOOL fSwReset=0;
static uint8 MuteDelayTimer = START_UP_MUTE_DELAY_TIMER;
static uint8 BootUpMuteTimer = 4;
static bool  fpowerup = TRUE;
static uint8 RestoreVolume ;
static uint8 RestoreEQ;
static BOOL isNeed_RestoreVolume=FALSE;
static BOOL isNeed_RestoreEQ=FALSE;
static uint8 AudioSettingDelayTimer = AUDIO_SETTING_DELAY_TIMER;
static void powerLed_init(void);
static void powerCrl_init(void);
static bool powerLed_status(void);
static void powerLed_on(void);
static void powerLed_off(void);
static void PowerDetect_Ctor(void);
static void MainApp_Power_Monitor(cMainApp * const me);
/*Added to mute AMP while start up*/
static void power_AmpMute(BOOL muteEnable);

#define CAST_ME cMainApp * MainApp = (cMainApp *) me;

static QState MainApp_Initial(cMainApp * const me, QEvt const *const e);

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(cMainApp * const me, QEvt const * const e);

static void MainApp_SwitchMode(cMainApp* me, uint16 modeId);

static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e);

static void volume_handler(cMainApp * const me, uint8 vol);

static void power_on_audio_setting(cMainApp* me);
static void MainApp_RequestMuteAudio(cMainApp * const me, bool isMuteOn);

static QState MainApp_Standby(cMainApp * const me, QEvt const * const e);

/* Internal event queue - Size as needed */
static QEvt const *MainEvtQue[8];

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void MainApp_StartUp(cPersistantObj *me)
{
    QS_OBJ_DICTIONARY(MainApp);
    QS_OBJ_DICTIONARY(MainApp_PreActive);

    /* start up the object and let it run. including the timer*/
    Application_Ctor((cApplication*)me, Q_STATE_CAST(&MainApp_Initial), MAINAPP_TIMEOUT_SIG,
                     MainEvtQue, Q_DIM(MainEvtQue), MAIN_APP_ID);

    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
    /* Subscribe */
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
#endif
    QActive_subscribe((QActive*) me, AUDIO_STATE_SIG); //Added by johnson 2016-6-20
    QActive_subscribe((QActive*) me, AUDIO_MUSIC_STREAM_STATE_SIG); //Added by johnson 2016-6-20
}

void MainApp_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Application_Xtor((cApplication*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MainApp_Initial(cMainApp * const me, QEvt const *const e)
{
    /* initial the LED for demo usage */
    powerLed_init();
    powerCrl_init();
    power_on_audio_setting(me);
    PowerDetect_Ctor();
    return Q_SUPER(&MainApp_Standby);
}

/* Active state  - super state for "normal" behaviour */
static QState MainApp_Active(cMainApp * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            while (QActive_recall((QActive*)me, &deferredReqQue)) {} // check if we have events(key_state_sig) in deferred queue
            MainApp_SwitchMode(MainApp, NORMAL_MODE);
            MuteDelayTimer = START_UP_MUTE_DELAY_TIMER;
            powerLed_on();
            return Q_HANDLED();
        case MAINAPP_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            if(MuteDelayTimer)
            {
                MuteDelayTimer --;
                if(MuteDelayTimer ==0)
                {
                    power_AmpMute(FALSE);
                    MainApp_RequestMuteAudio(me, FALSE);
                }
            }
            if(AudioSettingDelayTimer)
            {
                AudioSettingDelayTimer --;
                if(AudioSettingDelayTimer ==0)
                {
                    if(isNeed_RestoreVolume ==TRUE)
                    {
                        isNeed_RestoreVolume = FALSE;
                        volume_handler(me, RestoreVolume);
                    }

                    if(isNeed_RestoreEQ ==TRUE)
                    {
                        isNeed_RestoreEQ = FALSE;
                        AudioSrv_SetEq((uint16)RestoreEQ, TRUE);
                    }
                }
            }
            MainApp_Power_Monitor(me);
            break;
        }
        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if ((evt->keyId == POWER_KEY) && (evt->keyEvent == KEY_EVT_UP))
            {
                return Q_TRAN(&MainApp_Standby);
            }
            MainApp_ParseKeyEvent(me, e);
            return Q_HANDLED();
        }
        case AUDIO_STATE_SIG:
        {
            eAudioChannel channel;
            AudioJackinStateEvt* evt = (AudioJackinStateEvt*)e;
            if (evt->IsJackIn)
            {
                channel = AUDIO_CHANNEL_AUXIN;
            }
            else
            {
                channel = AUDIO_CHANNEL_RCA;
            }
            MainApp_SwitchAudioChannel(me, channel);
            return Q_HANDLED();
        }
        case AUDIO_MUSIC_STREAM_STATE_SIG:
        {
            AudioMusicDetectStateEvt* pAudioMusicStateEvt = (AudioMusicDetectStateEvt*)e;
            if (pAudioMusicStateEvt->hasMusicStream)
            {
                MainApp_RequestMuteAudio(me, FALSE);

            }
            else
            {
                MainApp_RequestMuteAudio(me, TRUE);
            }

            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            if(fpowerup ==TRUE)
            {
                fpowerup = FALSE;
                AudioSrv_SetChannel((QActive *)me, AUDIO_CHANNEL_RCA);

            }
            return  Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

static void MainApp_ParseKeyEvent(cMainApp * const me, QEvt const * const e)
{

    KeyStateEvt *evt = (KeyStateEvt*)e;
    switch(evt->keyId)
    {
        case VOL_UP_DOWN_KEY:
            volume_handler(me, evt->index);
            break;
        case CONFIG_KEY:
            uEqDataPackage eqPackage;
            ASSERT(evt->keyId < 0xFFFF);//id value overflow
            if(evt->keyEvent== KEY_EVT_DOWN||evt->keyEvent== KEY_EVT_UP)
            {
                if(evt->keyEvent== KEY_EVT_DOWN)
                    eqPackage.eqDataPackageId = DSP_EQ_CTRL_PEQ1;
                else
                    eqPackage.eqDataPackageId = DSP_EQ_CTRL_PEQ2;

                AudioSrv_SetEq(eqPackage.eqDataPackageId , TRUE);
            }

            break;
        default:
            break;
    }
}

static void volume_handler(cMainApp * const me, uint8 vol)
{
    Setting_Set(DSP_VOLUME_SETT_ID, &vol);
    AudioSrv_SetVolume(vol);
}


static void MainApp_SwitchMode(cMainApp* me, uint16 modeId)
{
    SwitchModeReqEvt* reqEvt = Q_NEW(SwitchModeReqEvt, SYSTEM_MODE_REQ_SIG);
    reqEvt->sender = (QActive*)me;
    reqEvt->modeId = modeId;
    SendToController((QEvt*)reqEvt);
}

static void powerLed_init(void)
{
    uint16 attached_device_index = 0;
    tGPIODevice *pLedGPIOConf;

    pLedGPIOConf = (tGPIODevice*)getDevicebyIdAndType(LED_DEV_ID,GPIO_DEV_TYPE, &attached_device_index);
    GpioDrv_Ctor(&powerLed.ledHwObj,pLedGPIOConf);
    powerLed_off();
}

static void powerCrl_init(void)
{
    uint16 attached_device_index = 0;
    tGPIODevice *pPowerGPIOConf;

    pPowerGPIOConf = (tGPIODevice*)getDevicebyIdAndType(POWER_DEV_ID,GPIO_DEV_TYPE,&attached_device_index);
    GpioDrv_Ctor(&powerPinObj,pPowerGPIOConf);
}

static bool powerLed_status(void)
{
    return (GpioDrv_ReadBit(&powerLed.ledHwObj,GPIO_21) ? FALSE : TRUE);
}

static void powerLed_on(void)
{
    GpioDrv_ClearBit(&powerLed.ledHwObj,GPIO_21);
}

static void powerLed_off(void)
{
    GpioDrv_SetBit(&powerLed.ledHwObj,GPIO_21);
}

static void power_on_audio_setting(cMainApp* me)
{
    uint8 defaultVol = DEFAULT_VOLUME;
    Setting_Set(DSP_VOLUME_SETT_ID, &defaultVol);
}

static void MainApp_SwitchAudioChannel(cMainApp * const me, eAudioChannel channel)
{
#ifdef HAS_AUDIO_CONTROL
    AudioChannelSwitchReqEvt* audio_switch = Q_NEW(AudioChannelSwitchReqEvt, AUDIO_SWITCH_CHANNEL_SIG);
    audio_switch->channel = channel;
    audio_switch->sender = (QActive *) me;
    SendToServer(AUDIO_SRV_ID, (QEvt*)audio_switch);
#endif
}
static void MainApp_RequestMuteAudio(cMainApp * const me, bool isMuteOn)
{
    AudioMuteReqEvt* muteReqEvt = Q_NEW(AudioMuteReqEvt, AUDIO_MUTE_SIG);
    muteReqEvt->mute = isMuteOn;
    muteReqEvt->sender = (QActive*)me;
    SendToServer(AUDIO_SRV_ID,(QEvt*)muteReqEvt);
}

static void MainApp_RequestMuteChannel(cMainApp * const me, uint32 channel)
{

    AudioMuteChannelReqEvt* pMuteReqEvt = Q_NEW(AudioMuteChannelReqEvt, AUDIO_MUTE_CHANNEL_REQ_SIG);
    pMuteReqEvt->channel_mask = channel;
    pMuteReqEvt->sender = (QActive*)me;
    SendToServer(AUDIO_SRV_ID,(QEvt*)pMuteReqEvt);
}


static void PowerDetect_Ctor(void)
{
    /* ADC for reading battery and AC input status*/
    uint16 attached_device_index = 0;
    tDevice *pPowerDev = NULL;
    pPowerDev = (tDevice*)getDevicebyId(POWER_DETECT_ID,&attached_device_index);
    tADCDevice *pPowerAdcConf = (tADCDevice*)pPowerDev;
    ADCDrv_Ctor(&PowerAdcDrv, pPowerAdcConf);
    ADCDrv_StartScanning(&PowerAdcDrv);
}

static void MainApp_Power_Monitor(cMainApp * const me)
{
    uint16 rawResult =0;
    static uint16 Last_ADvalue=0;
    if (PowerDetTimer > 0)
    {
        if ((PowerDetTimer -= MAIN_APP_TIMEOUT_IN_MS) <= 0)
        {
            rawResult = ADCDrv_GetData(&PowerAdcDrv, ADC_NTC_POWER_DETECT);
            if(rawResult>MIN_2_8V_ADC)
                Last_ADvalue =rawResult;
            if ( rawResult<=POWER_DETECT_THRESHOLD_ADC&&(Last_ADvalue>MIN_2_8V_ADC))
            {
                Last_ADvalue =rawResult;
                powerLed_off();
                MainApp_RequestMuteAudio(me, TRUE);
                SwResetTimer = SW_RESET_TIME;
                fSwReset =TRUE;
            }
            else if(rawResult>=MIN_2_8V_ADC)
            {
                if(fSwReset==TRUE)
                {
                    fSwReset =FALSE;
                    powerLed_on();
                    MainApp_RequestMuteAudio(me, FALSE);
                }
            }
            if(SwResetTimer>0)
            {
                SwResetTimer--;
            }
            //Continus ADC scanning
            ADCDrv_StartScanning(&PowerAdcDrv);
            PowerDetTimer = POWER_DETECT_TIME;
        }
    }
}
/*Added to mute AMP while start up*/
static void power_AmpMute(BOOL muteEnable)
{
    if(muteEnable)
    {
        GpioDrv_ClearBit(&powerPinObj,GPIO_AMP_MUTE);
    }
    else
    {
        GpioDrv_SetBit(&powerPinObj,GPIO_AMP_MUTE);
    }
}
/* Standby state*/

static QState MainApp_Standby(cMainApp * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            powerLed_off();
            MainApp_RequestMuteAudio(me, TRUE);
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            MainApp_SwitchMode(MainApp, STANDBY_MODE);
            return Q_HANDLED();
        }
        case SYSTEM_MODE_RESP_SIG:
        {
            return Q_HANDLED();
        }
        case MAINAPP_TIMEOUT_SIG:
        {
            if(BootUpMuteTimer)
            {
                BootUpMuteTimer --;
                if(BootUpMuteTimer ==0)
                {
                    power_AmpMute(TRUE);
                }
            }
            PersistantObj_RefreshTick((cPersistantObj*)MainApp, MAIN_APP_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }

        case KEY_STATE_SIG:
        {
            KeyStateEvt *evt = (KeyStateEvt*)e;
            if(POWER_KEY== (evt->keyId))
            {
                if(KEY_EVT_DOWN == (evt->keyEvent))
                {
                    return Q_TRAN(&MainApp_Active);
                }
            }
            else if(evt->keyId == VOL_UP_DOWN_KEY)
            {
                isNeed_RestoreVolume = TRUE;
                RestoreVolume = evt->index;
                AudioSettingDelayTimer = AUDIO_SETTING_DELAY_TIMER;
            }
            else if((evt->keyId == CONFIG_KEY))
            {
                if(evt->keyEvent== KEY_EVT_DOWN||evt->keyEvent== KEY_EVT_UP)
                {

                    uEqDataPackage eqPackage;
                    ASSERT(evt->keyId < 0xFFFF);//id value overflow

                    if(evt->keyEvent== KEY_EVT_DOWN)
                    {
                        eqPackage.eqDataPackageId = DSP_EQ_CTRL_PEQ1;
                    }
                    else
                    {
                        eqPackage.eqDataPackageId = DSP_EQ_CTRL_PEQ2;
                    }
                    isNeed_RestoreEQ = TRUE;
                    RestoreEQ = (uint8)eqPackage.eqDataPackageId;
                    AudioSettingDelayTimer = AUDIO_SETTING_DELAY_TIMER;
                }
            }
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }

        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}



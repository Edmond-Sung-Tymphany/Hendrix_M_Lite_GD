/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Driver
                  -------------------------

                  SW Module Document

@file        AudioDrv.c
@brief       This file implementes the middle layer of the audio service
@author      Bob.Xu
@date        2015-06-15
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-15     Bob.Xu
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "stm32f0xx_gpio.h"
#include "GPIODrv.h"
#include "./AudioDrv_priv.h"
#include "SettingSrv.h"
#include "trace.h"
#include "AudioSrv.h"
#include "I2CDrv.h"
#include "DspInitTab.h"
#include "DspDrv_tas5754.h"
#include "pcm1862Drv.h"
#include "AudioSrv.config"
typedef struct tCtrIdEQIdMap
{
    eAudioSettId dspSettid;
    eSettingId settingId;
} tCtrIdEQIdMap;

static tCtrIdEQIdMap ctrIdEQIdMap[] =
{
    /* DSP setting ID  index of setting db*/
    {DSP_VOLUME_SETT_ID,  SETID_VOLUME},
    {DSP_BASS_SETT_ID,    SETID_BASS},
    {DSP_TREBLE_SETT_ID,  SETID_TREBLE},
};

typedef struct
{
    eAudioJackId    audioJackInId;
    eSettingId      jackSetId;
    bool            (*isJackInFunc)(void);
    //  eSettingId      musicDetSetId;
    //  bool            (*isMusicOnFunc)(void);
    // int32           muteDebounceCnt;
} tMusicDection;


static tMusicDection musicDetection[] =
{
    {AUXIN_JACK,     SETID_IS_AUXIN_PLUG_IN,    &AudioDrv_IsAuxinJackPluggedIn,/*SETID_AUXIN_MUSIC_DET,    &AudioDrv_IsAuxinHasMusicOn,  INVALID_VALUE*/},
    //{SPDIF1_IN_JACK, SETID_IS_SPDIF_IN_PLUG_IN, &AudioDrv_IsOptJackPluggedIn,   SETID_SPDIF_IN_MUSIC_DET, &AudioDrv_IsOptHasMusicOn,    INVALID_VALUE},
};


static cI2CDrv          Tas5754i2cObj;
static cDspTas5754  DspTas5754;

static cI2CDrv          Pcm1862i2cObj;
static cAdcDrv_pcm1862  AdcPcm1862;

static cGpioDrv audioGpioDrv;


static int32 musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
static int32 jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
static BOOL fStartup_auio_detect= TRUE;
static bool fmute = FALSE;
static BOOL AudioDrv_check_mute(void);
static void AudioDrv_DspVolSetId_Handler(void);

/* Private functions / variables. Declare and drivers here */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioDrv_Ctor(cAudioDrv *me)
{
    ASSERT(me);
    Tas5754i2cObj.pConfig = (tI2CDevice*)getDevicebyId(DSP_DEV_ID, NULL);
    DspTas5754.initData = (uint8 *)registers;
    ASSERT(Tas5754i2cObj.pConfig || DspTas5754.initData);
    DspTas5754_Ctor(&DspTas5754,&Tas5754i2cObj);

    Pcm1862i2cObj.pConfig = (tI2CDevice*)getDevicebyId(AUDIO_DEV_ID, NULL);
    ASSERT(Pcm1862i2cObj.pConfig);
    AdcDrv_pcm1862_Ctor(&AdcPcm1862, &Pcm1862i2cObj);

    //Initialize Audio GPIO pins
    audioGpioDrv.gpioConfig= (tGPIODevice*)getDevicebyIdAndType(AUDIO_ADC_DEV_ID,GPIO_DEV_TYPE, NULL);
    ASSERT(audioGpioDrv.gpioConfig);
    GpioDrv_Ctor(&audioGpioDrv, audioGpioDrv.gpioConfig);
}

void AudioDrv_Xtor(cAudioDrv *me)
{
    /* AdcDrv_pcm1862_Xtor(&AdcPcm1862);
     DspTas5754_Xtor(&DspTas5754);*/
    /* Fill me in! */
}

BOOL AudioDrv_Init(cAudioDrv *me)
{
    if(!(me->drvIsReady))
    {
        AdcDrv_pcm1862_Init(&AdcPcm1862);
        DspTas5754_Init(&DspTas5754);
        me->drvIsReady = TRUE;
    }
    jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
    bool defaultValue = FALSE;
    Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultValue);
    Setting_Set(SETID_MUSIC_DET, &defaultValue);
    //AudioDrv_Mute(AUDIO_AMP_SOFT_MUTE, /*muteEnable:*/TRUE);
    return TRUE;
}

void AudioDrv_Reset(cAudioDrv *me)
{
    me->drvIsReady = FALSE;
}
/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
/**
 * Function to change the channel. To call this function, normally you have to
 * call AudioDrv_Mute to mute the system in order to avoid pop noise, then set
 * the channel and last,call AudioDrv_Mute to umute the system
 * @param[in]     theChannelToSet, the channel which will replace the current channel
 */
void AudioDrv_SetChannel(eAudioChannel audioChannel)
{
    if (AUDIO_CHANNEL_AUXIN == audioChannel)
    {
        AudioDrv_AmpMute(TRUE);
        AdcDrv_pcm1862_SetInput_L(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT2));
        if(AudioDrv_check_mute()==TRUE)
            AdcDrv_pcm1862_enableMute(&AdcPcm1862,TRUE);
        else
            AdcDrv_pcm1862_mute_RightChannel(&AdcPcm1862,TRUE);
        AudioDrv_AmpMute(FALSE);
    }
    else if (AUDIO_CHANNEL_RCA == audioChannel)
    {
        //AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_INPUT3|PCM1862_ANALOG_INPUT2));
        AudioDrv_AmpMute(TRUE);
        AdcDrv_pcm1862_SetInput_L(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT1));
        if(fStartup_auio_detect ==TRUE)
        {
            fStartup_auio_detect = FALSE;
        }
        else
        {
            if(AudioDrv_check_mute()==TRUE)

                AdcDrv_pcm1862_enableMute(&AdcPcm1862,TRUE);
            else

                AdcDrv_pcm1862_mute_RightChannel(&AdcPcm1862,TRUE);

            AudioDrv_AmpMute(FALSE);
        }
    }
    else if(AUDIO_CHANNEL_ANALOG_MIXED == audioChannel)
    {
        //    AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT1 | PCM1862_ANALOG_DIFF_INPUT2));
        AdcDrv_pcm1862_SetInput(&AdcPcm1862, (PCM1862_ANALOG_DIFF_INPUT2|PCM1862_ANALOG_INPUT3));
    }
    else {}
}

/**
 * Function to update audio status including jackin status,  music steam status and so on.
 */
void AudioDrv_UpdateStatus(cAudioDrv *audioDrvObj)
{
    AudioDrv_CheckJackInStatus();
    AudioDrv_CheckMusicStreamStatus();
}

void AudioDrv_CheckJackInStatus(void)
{
    uint8 i = 0;
    if ((jackDetTimer > 0) && ((jackDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0))
    {
        for( i = 0; i < ArraySize(musicDetection); i++)
        {
            bool isJackIn = (musicDetection[i].isJackInFunc)();
            static bool preJackStatus = 0;
            if (isJackIn != preJackStatus)
            {
                AudioDrv_AmpMute(TRUE);
                preJackStatus =isJackIn;
                //TP_PRINTF("Jack Detect channel %d is %d\r\n", musicDetection[i].audioJackInId, isJackIn);
                AudioJackinStateEvt* pAudioStateEvt = Q_NEW(AudioJackinStateEvt, AUDIO_STATE_SIG);
                pAudioStateEvt->jackId = musicDetection[i].audioJackInId;
                pAudioStateEvt->IsJackIn = isJackIn;
                QF_PUBLISH(&pAudioStateEvt->super, me);

                /* Note: As the first music detect after analog jack plugged in is wrong(always on), so
                  * if the analog jack is just plugged in, then reset the music detection timer to 4 seconds. */
                /*
                         if(isJackIn && musicDetection[i].audioJackInId == AUXIN_JACK)
                         {
                             musicDetTimer = AUDIO_ACTIVE_FIRST_DET_AFTER_PLUGGED_TIME;
                         }*/

                /* To avoid pop noise, mute the multi room channel(from DSP to ASE-TK) once jack status was changed. */
                // DSPDrv1451_MuteLineInToAsetk(&DspADAU1451Drv, TRUE);
            }
        }
        jackDetTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
    }
}

/**
 * Function to update the music stream status
 */
void AudioDrv_CheckMusicStreamStatus(void)
{
    bool preStatus = *(bool*)Setting_Get(SETID_MUSIC_DET);
    bool hasMusicStream = preStatus;

    if (musicDetTimer > 0)
    {
        if ((musicDetTimer -= AUDIO_SRV_TIMEOUT_IN_MS) <= 0)
        {
            hasMusicStream = AudioDrv_IsAuxinHasMusicOn();
            musicDetTimer = AUDIO_ACTIVE_MUSIC_DETECT_TIME;
            if (preStatus != hasMusicStream)
            {
                AudioMusicDetectStateEvt* pAudioMusicStateEvt;
                pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = hasMusicStream;
                Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
                QF_PUBLISH(&pAudioMusicStateEvt->super, dummy);
            }
        }
    }
}

/**
 * Function to change audio settings, such as EQ.
 * @param[in]     pAudioEvt, a pointer of the audio event
 */
void AudioDrv_SetAudio(cAudioDrv *me, eAudioSettId audioSettId, BOOL enabled, uint32 param, uint32 param2)
{
    uEqDataPackage * deviceData = (uEqDataPackage*)&audioSettId;

    ASSERT(deviceData->eqDataPackageId < AUDIO_SETT_ID_MAX);

    switch (deviceData->eqDataPackageId)
    {
        case DSP_VOLUME_SETT_ID:
            AudioDrv_DspVolSetId_Handler();
            break;

        case SYSTEM_GAIN_SETT_ID:
            //mute the other mixers, in case audio come cross
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1R, MUTE_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1L, MUTE_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH1R, MUTE_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH1L, MUTE_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH2R, MUTE_VOLUME);
            AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX2_CH2L, MUTE_VOLUME);
            AdcDrv_pcm1862_SetPGA(&AdcPcm1862, 0); //change to -6db (0xf4)
            break;
        case DSP_EQ_CTRL_PEQ1:
        {
            uint8 lpIdex;
            lpIdex = deviceData->eqDataPackageIdex;
            DspTas5754_EqTurning(&DspTas5754, DSP_EQ_CTRL_PEQ1, &lpIdex);
        }
        break;
        case DSP_EQ_CTRL_PEQ2:
        {
            uint8 lpIdex;
            lpIdex = deviceData->eqDataPackageIdex;
            DspTas5754_EqTurning(&DspTas5754, DSP_EQ_CTRL_PEQ2, &lpIdex);
        }
        break;
        default:
            break;
    }
}

/**
 * Function to mute the system.
 * @param[in]   muteType    This parameter defines the way of how to mute the system,
 * you could mute the input source, or mute by dsp or mute the output
 * @param[in]   muteEnable  mute or unmute
 */
void AudioDrv_Mute(eAudioMuteType muteType, bool muteEnable)
{
    DspTas5754_Mute(&DspTas5754,muteType,muteEnable);
//    AdcDrv_pcm1862_enableMute((&AdcPcm1862),TRUE);
    AudioDrv_AmpMute(muteEnable);
    if(muteEnable ==FALSE)
    {
        if(AudioDrv_check_mute()==TRUE)
            AdcDrv_pcm1862_enableMute(&AdcPcm1862,TRUE);
        else
            AdcDrv_pcm1862_mute_RightChannel((&AdcPcm1862),TRUE);
    }
}

/**
 * Function to monitor the amp status
 */
void AudioDrv_AmpSafetyMonitor()
{
}

static void AudioDrv_DspVolSetId_Handler(void)
{
    uint8 volumeLevel = MIN_VOLUME;
    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);

    if(volumeLevel <= MAX_VOLUME && volumeLevel >= MIN_VOLUME)
    {
        if(volumeLevel==MIN_VOLUME)
        {
            fmute = TRUE;
            AdcDrv_pcm1862_enableMute(&AdcPcm1862, TRUE);
        }
        else
        {
            if(fmute ==TRUE)
            {
                fmute = FALSE;
                AdcDrv_pcm1862_mute_RightChannel(&AdcPcm1862,TRUE);
            }
        }
        AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1L, volumeLevel);
        AdcDrv_pcm1862_SetMixerGain(&AdcPcm1862, PCM1862_MIX1_CH1R, volumeLevel);
    }
}
static bool AudioDrv_IsAuxinJackPluggedIn(void)
{
    bool ret;
    int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_JACK_DET1);
    ret = det1;
    return ret;
}

static bool AudioDrv_IsAuxinHasMusicOn(void)
{
    bool ret;
    int8 det1 = GpioDrv_ReadBit(&audioGpioDrv, GPIO_IN_AUDIO_DETECT);
    ret = det1;
    return ret;
}

static void AudioDrv_AmpMute(BOOL muteEnable)
{
    if(muteEnable)
    {
        GpioDrv_ClearBit(&audioGpioDrv,AMP_MUTE_IO);
    }
    else
    {
        GpioDrv_SetBit(&audioGpioDrv,AMP_MUTE_IO);
    }
}

static BOOL AudioDrv_check_mute(void)
{
    uint8 volumeLevel = MIN_VOLUME;
    volumeLevel =  *(uint8*)Setting_Get(ctrIdEQIdMap[DSP_VOLUME_SETT_ID].settingId);
    if(volumeLevel ==MIN_VOLUME)
    {
        fmute =TRUE;
        return TRUE;
    }
    else
        return FALSE;
}

#ifdef HAS_AUDIO_MUTE_CHANNEL
void AudioDrv_MuteChannel(uint32 channel_mask)
{
    if(channel_mask)
    {
        AdcDrv_pcm1862_enableMute(&AdcPcm1862,TRUE);
    }
    else
    {
        AdcDrv_pcm1862_enableMute(&AdcPcm1862,FALSE);;
    }
}
#endif

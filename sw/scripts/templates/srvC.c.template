/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  ${name} Server
                  -------------------------

                  SW Module Document




@file        ${nameAndExt}
@brief       ${brief}
@author      ${user} 
@date        ${date}
@Copyright (c) <2015> Tymphany HK Ltd. All rights reserved.

DESCRIPTION: Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./${name}Srv_priv.h"
#include "trace.h"

#ifdef Q_SPY
#define CAST_ME c${name}Srv * ${name}Srv = (c${name}Srv *) me;
#else
#define CAST_ME
#endif

/* Private functions / variables. Declare and drivers here */
/* Internal event queue - Size as needed */
static QEvt const *${name}EvtQue[???];

/* State function definitions */
static QState ${name}Srv_Initial(QActive * const me);
static QState ${name}Srv_PreActive(QActive * const me, QEvt const * const e);
static QState ${name}Srv_Active(QActive * const me, QEvt const * const e);

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void ${name}Srv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    /* Add to QSPY directory - only does so if QSPY enabled. 
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(${name}Srv);
    QS_OBJ_DICTIONARY(${name}Srv_PreActive);
    QS_OBJ_DICTIONARY(${name}Srv_Active);
    QS_OBJ_DICTIONARY(${name}Srv_DeActive);

    /* start up the object and let it run. Called by the controller */
    Server_Ctor((cServer*)me, Q_STATE_CAST(${name}Srv_Initial));

    /* active object start */
    QActive_start((QActive*)me, MY_ID, ${name}EvtQue, Q_DIM(${name}EvtQue), (void *)0, 0U, (QEvt *)0);

    /* Subscribe */
}

void ${name}Srv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState ${name}Srv_Initial(c${name}Srv * const me, QEvt const * const e)
{

    return Q_TRAN(&${name}Srv_PreActive);
}


/* This state is used to as wait state. Wait until power  */
static QState ${name}Srv_PreActive(c${name}Srv * const me, QEvt const * const e)
{
    switch(e->sig)
    {   
        /* fill me in */
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);     
            return Q_TRAN(&${name}Srv_Active);
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


/*   Active state - first state where "normal" service begins  */
static QState ${name}Srv_Active(c${name}Srv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        /* fill me in */
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*   DeActive state - Use this state to ramp down the server  */
static QState ${name}Srv_DeActive(c${name}Srv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        /* fill me in */
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/

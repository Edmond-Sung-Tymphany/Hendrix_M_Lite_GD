/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  AllPlay Server
                  -------------------------

                  SW Module Document




@file        AllPlaySrv.c
@brief       All play server provides an inteface to allplay/alljoyn modules
@author      Chris Alexander
@date        2014-02-10
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-02-10     Chris Alexander
REASON     : First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "./AllPlaySrv_priv.h"
#include "bsp.h"
#include "trace.h"
#include "controller.h"
#include "PowerSrv.h"
#include "SettingSrv.h"
#include "AllPlayDrv.h"
#include "UartDrv.h"
#include "NvmDrv.h"    //NvmDrv_WriteWord()
#include "projBsp.h"   //ProjBsp_JumpToBootloader()

Q_DEFINE_THIS_FILE

#ifdef ALLPLAYSRV_DEBUG
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...) TymQP_DumpQueue_WithLog((QActive *)(me), __func__, __VA_ARGS__)
#else
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...)
    #undef   TP_PRINTF
    #define  TP_PRINTF(...)
#endif

#define CAST_ME cAllPlaySrv * allPlaySrv = (cAllPlaySrv *) me;
#define AJ_UART_TX_BUF_SIZE     (0x416 * 4)     // AJ_SlippedBuffer.allocatedLen * AJ_SerialLinkParams.maxWindowSize
#define AJ_UART_RX_BUF_SIZE     (0x416)         // AJ_SlippedBuffer.allocatedLen
#define ALLPLAY_VOLUME_CHANGE_TIMEOUT_IN_MS     (500) // 500ms
const uint16 ALLPLAY_SRV_TICK_TIME = GET_TICKS_IN_MS(5);
const uint16 ALLPLAY_ASSERT_RESET_WAIT_TIME = GET_TICKS_IN_MS(50);

static QEvt const * EvtQueue[ALLPLAY_SRV_EVT_Q_SIZE];
cUartDrv            aj_uart;        // aj_target_serial needs this UART object
static cAllPlayDrv  allPlayDrv;
static uint8        uartTxBuf[AJ_UART_TX_BUF_SIZE];
static uint8        uartRxBuf[AJ_UART_RX_BUF_SIZE];
static cRingBuf     txBuf;
static cRingBuf     rxBuf;
static bool isChangingVol = FALSE;
static int16 changeVolTimer = 0;

/* internal signals */
enum AllplaySrvPriSignals /* allplay srv private signals */
{
    ALLPLAY_RESET_ASSERT_SIG = MAX_SIG,
    ALLPLAY_UART_RX_SIG,
    ALLPLAY_TIMEOUT_SIG
};

enum allplay_message_type AllPlaySrv_Ticker(cAllPlaySrv* me)
{
    int timeout = 10; //qualcomm's setting is 100ms
    allplay_message_t* apmsg;
    enum allplay_message_type messageType;

    // From main loop: read events and responses
    apmsg = allplay_read_message(allPlayDrv.apctx, timeout);
    if (!apmsg) {
        return ALLPLAY_ERROR;
    }

    messageType = apmsg->messageType;
    switch (apmsg->messageType)
    {
        case ALLPLAY_ERROR:    // Errors
        {
            allplay_status errorCode = ((allplay_error_t*)apmsg)->code;
            switch (errorCode) {
                case ALLPLAY_ERROR_FAILED:
                    //...
                    break;
                case ALLPLAY_ERROR_NONE:
                case ALLPLAY_NOT_CONNECTED:
                    // should never happen, just silence the compiler
                    break;
            }
        }
        break;
        // Responses
        case ALLPLAY_RESPONSE_VOLUME:
        {
            changeVolTimer = 0;
            isChangingVol = FALSE;
        }
        case ALLPLAY_RESPONSE_VOLUME_ADJUST:
        case ALLPLAY_RESPONSE_MUTE:
        case ALLPLAY_RESPONSE_PLAY:
        case ALLPLAY_RESPONSE_PAUSE:
        case ALLPLAY_RESPONSE_STOP:
        case ALLPLAY_RESPONSE_NEXT:
        case ALLPLAY_RESPONSE_PREVIOUS:
        case ALLPLAY_RESPONSE_SET_POSITION:
        case ALLPLAY_RESPONSE_NETWORK_REQUEST_WPS:
        case ALLPLAY_RESPONSE_SETUP:
        case ALLPLAY_RESPONSE_RESET_TO_FACTORY:
        case ALLPLAY_RESPONSE_SET_RESAMPLING_MODE:
        case ALLPLAY_RESPONSE_WIFIENABLE:
        case ALLPLAY_RESPONSE_FIRMWARE_UPDATE:
        case ALLPLAY_RESPONSE_CONNECT_WIFI:
        case ALLPLAY_RESPONSE_SET_MCU_IDLE:
        case ALLPLAY_RESPONSE_SET_BATTERY_STATE:
        case ALLPLAY_RESPONSE_SET_EXTERNAL_SOURCE:
            // request was successful otherwise we would have received an ALLPLAY_ERROR_FAILED
            TP_PRINTF("Successful reply\n");
            break;
        case ALLPLAY_RESPONSE_PLAYER_STATE:
        case ALLPLAY_EVENT_PLAYER_STATE_CHANGED:
        {
            allplay_player_state_t* streamInfo = (allplay_player_state_t*)apmsg;
            {
                TP_PRINTF("Stream info:\n"
                        "   state: %d\n"
                        "   duration: %d\n"
                        "   position: %d\n"
                        "   sample rate: %uKHz\n"
                        "   audio channels: %u\n"
                        "   sample size: %u\n"
                        "   title: %s\n"
                        "   artist: %s\n"
                        "   album: %s\n"
                        "   contentSource: %s\n",
                        streamInfo->state,
                        streamInfo->duration,
                        streamInfo->position,
                        streamInfo->sampleRate,
                        streamInfo->audioChannels,
                        streamInfo->bitsPerSample,
                        (streamInfo->title ? streamInfo->title : "<null>"),
                        (streamInfo->artist ? streamInfo->artist : "<null>"),
                        (streamInfo->album ? streamInfo->album : "<null>"),
                        (streamInfo->contentSource ? streamInfo->contentSource : "<null>")
                      );
                if(streamInfo->contentSource == NULL)
                    allPlayDrv.contentSource = ALLPLAY_AP;
                else if(strcmp(streamInfo->contentSource, "bluetooth") == 0 )
                    allPlayDrv.contentSource = ALLPLAY_BT;
                else if(strcmp(streamInfo->contentSource, "linein") == 0 )
                    allPlayDrv.contentSource = ALLPLAY_LINE_IN;
                else if(strcmp(streamInfo->contentSource, "AUX-IN") == 0 )
                    allPlayDrv.contentSource = MCU_AUXIN;
                else
                    allPlayDrv.contentSource = ALLPLAY_AP;

                allPlayDrv.ePlayerState = streamInfo->state;
                AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            }
        }
        break;
#ifdef HAS_ALLPLAY_BT
        case ALLPLAY_RESPONSE_BLUETOOTH_ENABLE:
        case ALLPLAY_RESPONSE_BLUETOOTH_ENABLE_PAIRING:
        {
            // request was successful otherwise we would have received an ALLPLAY_ERROR_FAILED
            TP_PRINTF("Successful reply\n");
        }
        break;
        case ALLPLAY_RESPONSE_BLUETOOTH_GET_STATE:
        case ALLPLAY_EVENT_BLUETOOTH_STATE_CHANGED:
        {
            allplay_bluetooth_state_t* bluetoothState= (allplay_bluetooth_state_t*)apmsg;
            {
                TP_PRINTF("bluetooth state:\n"
                        "   enabled: %d\n"
                        "   pairable: %d\n"
                        "   btDevicesCount: %d\n"
                        "   a2dpDevicesCount: %d\n",
                        bluetoothState->enabled,
                        bluetoothState->pairable,
                        bluetoothState->btDevicesCount,
                        bluetoothState->a2dpDevicesCount
                      );
            }

            eAllPlayStateIndEvt allPlayState = ALLPLAY_STATE_MAX;
            if(TRUE == bluetoothState->enabled)
            {
                if(bluetoothState->enabled != allPlayDrv.bAllplayBtEnabled)
                {
                    allPlayState = ALLPLAY_STATE_BT_ENABLE;
                }
                else if(TRUE == bluetoothState->pairable
                   && bluetoothState->pairable != allPlayDrv.bAllplayBtPairable)
                {
                    allPlayState = ALLPLAY_STATE_BT_PAIRING_ENABLE;
                }
                else if(0 != (bluetoothState->btDevicesCount + bluetoothState->a2dpDevicesCount)
                        && allPlayDrv.bAllplayBtConnected == FALSE)
                {
                    allPlayState = ALLPLAY_STATE_BT_DEVICE_CONNECTED;
                }
                else if(0 == (bluetoothState->btDevicesCount + bluetoothState->a2dpDevicesCount)
                        && allPlayDrv.bAllplayBtConnected == TRUE)
                {
                    allPlayState = ALLPLAY_STATE_BT_DEVICE_DISCONNECTED;
                }
                else if(FALSE == bluetoothState->pairable
                   && bluetoothState->pairable != allPlayDrv.bAllplayBtPairable)
                {
                    allPlayState = ALLPLAY_STATE_BT_PAIRING_DISABLE;
                }
            }
            else
            {
                allPlayState = ALLPLAY_STATE_BT_DISABLE;
            }
            {
                /* publish the event for bluetooth state change */
                AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
                assert(p);
                p->allPlayState = allPlayState;
                QF_PUBLISH(&p->super, 0);
            }

            allPlayDrv.bAllplayBtEnabled = bluetoothState->enabled;
            allPlayDrv.bAllplayBtPairable = bluetoothState->pairable;
            if(0 == (bluetoothState->btDevicesCount + bluetoothState->a2dpDevicesCount))
            {
                allPlayDrv.bAllplayBtConnected = FALSE;
            }
            else
            {
                allPlayDrv.bAllplayBtConnected = TRUE;
            }
            AllPlaySrv_SaveInfo(me);
        }
        break;
#endif /* HAS_ALLPLAY_BT */
        case ALLPLAY_RESPONSE_RSSI:
        {
            int i = 0;
            allplay_rssi_t *rssiInfo = (allplay_rssi_t*)apmsg;
            TP_PRINTF("RSSI:\n");
            while(i < sizeof(rssiInfo->chain)/sizeof(int32_t)) {
                TP_PRINTF("   chain %d: %d\n", i, rssiInfo->chain[i]);
                ++i;
            }
        }
        break;
        case ALLPLAY_EVENT_NETWORK_INFO_CHANGED:
        case ALLPLAY_RESPONSE_NETWORK_INFO:
        {
            allplay_network_info_t *netInfo = (allplay_network_info_t*)apmsg;
            char *type;
            switch (netInfo->type) {
                case ALLPLAY_NETWORK_NONE: type = "None"; break;
                case ALLPLAY_NETWORK_WIFI: type = "Wifi"; break;
                case ALLPLAY_NETWORK_ETHERNET: type = "Ethernet"; break;
                default: type = "Unknown"; break;
            }

            allPlayDrv.networkType = netInfo->type;
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            TP_PRINTF("Network info:\n"
                    "   type: %s\n"
                    "   ip: %03u.%03u.%03u.%03u\n"
                    "   mac: %02x:%02x:%02x:%02x:%02x:%02x\n"
                    "   ssid: %s\n"
                    "   rssi: %d\n",
                    type,
                    netInfo->wifiIp[0], netInfo->wifiIp[1], netInfo->wifiIp[2], netInfo->wifiIp[3],
                    netInfo->wifiMac[0], netInfo->wifiMac[1], netInfo->wifiMac[2], netInfo->wifiMac[3], netInfo->wifiMac[4], netInfo->wifiMac[5],
                    netInfo->ssid,
                    netInfo->rssi);
            {
                /* publish the event for system mode change */
                AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
                assert(p);
                p->allPlayState = ALLPLAY_STATE_NETWORK_INFO_CHANGED;
                p->payload.networkType = netInfo->type;
                QF_PUBLISH(&p->super, 0);
            }
        }
        break;
        case ALLPLAY_RESPONSE_SYSTEM_MODE:
        {
            allPlayDrv.eSystemMode = ((allplay_system_mode_t*)apmsg)->mode;;
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            TP_PRINTF("System mode: %s (%d)\n", AllPlayDrvHelper_convertSysmodeToString(allPlayDrv.eSystemMode), allPlayDrv.eSystemMode);
            {
                /* publish the event for system mode change */
                AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
                assert(p);
                p->allPlayState = ALLPLAY_STATE_SYSTEM_MODE_CHANGED;
                p->payload.currentSystemMode = allPlayDrv.eSystemMode;
                QF_PUBLISH(&p->super, 0);
            }
        }
        break;
        case ALLPLAY_RESPONSE_FIRMWARE_VERSION:
        {
            allplay_firmware_version_t *firmwareVersion = (allplay_firmware_version_t*)apmsg;
            TP_PRINTF("Firmware Version: %s\n", firmwareVersion->version);
        }
        break;
        case ALLPLAY_RESPONSE_VOLUME_INFO:
        {
            allplay_volume_info_t *volumeInfo = (allplay_volume_info_t*)apmsg;
            TP_PRINTF("Volume info: mute:%d, volume: %d (max: %d)\n", volumeInfo->mute, volumeInfo->volume, volumeInfo->max_volume);

            /* publish the event for vol reponse */
            AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
            assert(p);
            p->allPlayState = ALLPLAY_STATE_VOLUME_INFO;
            p->payload.volChangeInfo.mute = volumeInfo->mute;
            p->payload.volChangeInfo.volume = volumeInfo->volume;
            p->payload.volChangeInfo.max_volume = volumeInfo->max_volume;
            QF_PUBLISH(&p->super, 0);
        }
        break;


        // Events
        case ALLPLAY_RESPONSE_RUN_CMD:
        {
            allplay_cmd_t *cmd = (allplay_cmd_t*)apmsg;
            TP_PRINTF("Command id: %u\n", cmd->id);
        }
        break;
        case ALLPLAY_RESPONSE_FIRMWARE_CHECK:
        {
            allplay_firmware_update_info_t *firmwareInfo = (allplay_firmware_update_info_t*)apmsg;
            if (!firmwareInfo->version) {
                TP_PRINTF("FirmwareCheck result: No new firmware\n");
            }
            else {
                TP_PRINTF("FirmwareCheck result: New firmware: version %s (%s)\n", firmwareInfo->version, firmwareInfo->url);
            }
        }
        break;
        case ALLPLAY_RESPONSE_GET_RESAMPLING_MODE:
        {
            allplay_resampling_mode_t *mode = (allplay_resampling_mode_t*)apmsg;
            TP_PRINTF("Resampling mode: %d\n", mode->resamplingMode);
        }
        break;
        case ALLPLAY_RESPONSE_DIRECTENABLE:
            break;

        //...
        // Events
        case ALLPLAY_EVENT_CONNECTION_STATUS_CHANGED:
            TP_PRINTF("####\n####Connection status: %s\n####\n", allplay_is_connected(allPlayDrv.apctx) ? "true" : "false");
            /* query for the volume info to init the allplay library
             * otherwise, it does not report notification about volume change
             * query for the system mode as well, so we know what the system mode is when SAM finishes booting up.
             * */
            if(allplay_is_connected(allPlayDrv.apctx))
            {
                allPlayDrv.bAllplayConnected = TRUE;
                allplay_get_volume_info(allPlayDrv.apctx, 0);
                allplay_get_system_mode(allPlayDrv.apctx, 0);
                allplay_bluetooth_get_state(allPlayDrv.apctx, (void*)0);
                allplay_network_get_info(allPlayDrv.apctx, (void*)0);
            }
            else
            {
                allPlayDrv.bAllplayConnected = FALSE;
            }
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            break;
        //case ALLPLAY_EVENT_PLAYER_STATE_CHANGED:
            // see ALLPLAY_RESPONSE_PLAYER_STATE
        case ALLPLAY_EVENT_VOLUME_CHANGED:
        {
            allplay_volume_info_t *volumeInfo = (allplay_volume_info_t*)apmsg;
            TP_PRINTF("Volume changed: mute:%d, volume: %d (max: %d)\n", volumeInfo->mute, volumeInfo->volume, volumeInfo->max_volume);
            if(isChangingVol)
            {
                TP_PRINTF("The volume changed is triggered by MCU but not JukeBox(phone App).\n");
            }
            else
            {
                /* publish the event for vol. change */
                AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
                assert(p);
                p->allPlayState = ALLPLAY_STATE_VOLUME_CHANGED;
                p->payload.volChangeInfo.mute = volumeInfo->mute;
                p->payload.volChangeInfo.volume = volumeInfo->volume;
                p->payload.volChangeInfo.max_volume = volumeInfo->max_volume;
                QF_PUBLISH(&p->super, 0);
            }
        }
        break;
        case ALLPLAY_EVENT_NETWORK_WPS_RESULT:
        {
            int result = ((allplay_network_wps_result_t*)apmsg)->result;
            TP_PRINTF("WpsResult: %d\n", result);
        }
        break;
        case ALLPLAY_EVENT_SYSTEM_MODE:
        {
            allPlayDrv.eSystemMode = ((allplay_system_mode_t*)apmsg)->mode;
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            TP_PRINTF("SystemMode: %d\n", allPlayDrv.eSystemMode);
            {
                /* publish the event for system mode change */
                AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
                assert(p);
                p->allPlayState = ALLPLAY_STATE_SYSTEM_MODE_CHANGED;
                p->payload.currentSystemMode = allPlayDrv.eSystemMode;
                QF_PUBLISH(&p->super, 0);
            }
        }
        break;
        case ALLPLAY_EVENT_CMD_RESULT:
        {
            allplay_cmd_result_t *cmdResult = (allplay_cmd_result_t*)apmsg;
            TP_PRINTF("Command %u result: exitstatus %d, termsig %d\n",
                    cmdResult->id, cmdResult->exitstatus, cmdResult->termsig);
            TP_PRINTF("stdout=begin=============\n");
            TP_PRINTF("%s\n", cmdResult->stdoutStr);
            TP_PRINTF("stdout=end===============\n");
            TP_PRINTF("stderr=begin=============\n");
            TP_PRINTF("%s\n", cmdResult->stderrStr);
            TP_PRINTF("stderr=end===============\n");
        }
        break;
        case ALLPLAY_EVENT_START_MCU_UPDATE:
            TP_PRINTF("Should reboot into the bootloader/update fw\n");
            NVM_STORAGE_VALUE_SET(NVM_STORAGE_ADDR_UPGRADE_MODE); //notify bootloade to enter upgrade mode
            ProjBsp_JumpToBootloader(); //jump back to bootloader
        break;
        case ALLPLAY_EVENT_FIRMWARE_UPDATE_AVAILABLE:
        {
            allplay_firmware_update_info_t *firmwareInfo = (allplay_firmware_update_info_t*)apmsg;
            TP_PRINTF("New firmware: version %s (%s)\n", firmwareInfo->version, firmwareInfo->url);
        }
        break;
        case ALLPLAY_EVENT_FIRMWARE_UPDATE_STATUS:
        {
            allplay_firmware_update_status_t *updateStatus = (allplay_firmware_update_status_t*)apmsg;
            TP_PRINTF("Update status: %d\n", updateStatus->status);

            /* MCU receive update status (means update finish) only when
             *  - FAIL: Upgrade fail, and MCU does not jump back to bootloader
             *  - PASS: Only update SAM's firmware (The bundle file does not include MCU's firmware)
             * In PASS case, we should reboot system.
             */
            AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
            assert(p);
            if(ALLPLAY_FIRMWARE_UPDATE_SUCCESSFUL==updateStatus->status)
            {
                /*increase upgrade number*/
                uint32 upgrade_times= 0;
                NvmDrv_ReadWord(NVM_STORAGE_ADDR_UPGRADE_TIMES, &upgrade_times);
                NvmDrv_WriteWord(NVM_STORAGE_ADDR_UPGRADE_TIMES, ++upgrade_times);
                TP_PRINTF("[%s] This is the %dth upgrade\r\n", __func__, (int)upgrade_times);
                TP_PRINTF("[%s] ===========================================================\r\n\r\n\r\n", __func__);
                p->allPlayState = ALLPLAY_STATE_SAM_FIRMWARE_UPDATE_SUCCESSFUL;
            }
            else
            {
                p->allPlayState = ALLPLAY_STATE_SAM_FIRMWARE_UPDATE_FAILED;
            }
            QF_PUBLISH(&p->super, 0);

        }
        break;
        default:
            TP_PRINTF("unexpected message");
        break;
    }

    allplay_free_message(allPlayDrv.apctx, &apmsg);
    return messageType;
}

void AllPlaySrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(allPlaySrv);
    QS_OBJ_DICTIONARY(AllPlaySrv_Active);
    QS_OBJ_DICTIONARY(AllPlaySrv_DeActive);

    QS_SIG_DICTIONARY(ALLPLAY_CMD_SIG, allPlaySrv);

    QTimeEvt_ctorX(&allPlaySrv->resetAssertEvt, (QActive*)me, ALLPLAY_RESET_ASSERT_SIG, 0);
    
    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&AllPlaySrv_Initial), ALLPLAY_TIMEOUT_SIG,
                                EvtQueue, Q_DIM(EvtQueue), ALLPLAY_SRV_ID);
}

void AllPlaySrv_ShutDown(cPersistantObj *me)
{
    /* zero all memory that resets an AObject*/
    Server_Xtor((cServer*)me);
    AllPlayDrv_Xtor(&allPlayDrv);
    AllPlaySrv_SaveInfo((cAllPlaySrv*)me); //Save allplay info when (allplayDrv) have any change

    UartDrv_Xtor(&aj_uart);
    RingBuf_Xtor(&txBuf);
    RingBuf_Xtor(&rxBuf);
}

static QState AllPlaySrv_Initial(cAllPlaySrv * const me, QEvt const * const e)
{
     /* suppress the compiler warning about unused parameter */
    (void)me;
    (void)e;
    AllPlayDrv_Ctor(&allPlayDrv, 1);    /* have to construct the allplay driver and assert the reset pin to
                                           make sure the SAM module is in hardware reset state */
    AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
    return Q_TRAN(&AllPlaySrv_DeActive);
}

static void AllPlaySrv_SaveInfo(cAllPlaySrv * const me)
{
    AllPlaySrvInfoEvt allplayInfo;
    allplayInfo.bAllplayConnected   = allPlayDrv.bAllplayConnected;
    allplayInfo.bAllplayBtEnabled   = allPlayDrv.bAllplayBtEnabled;
    allplayInfo.bAllplayBtPairable  = allPlayDrv.bAllplayBtPairable;
    allplayInfo.bAllplayBtConnected = allPlayDrv.bAllplayBtConnected;

    /* TO DO: update the grouping status when get the grouping notificatiion from SAM.
     * Now just add a fake grouping status here, should be remove later
     */
    allPlayDrv.bIsGrouped           = TRUE;
    allplayInfo.bIsGrouped          = allPlayDrv.bIsGrouped;

    allplayInfo.contentSource       = allPlayDrv.contentSource;
    allplayInfo.eSystemMode         = allPlayDrv.eSystemMode;
    allplayInfo.ePlayerState        = allPlayDrv.ePlayerState;
    allplayInfo.networkType         = allPlayDrv.networkType;
    Setting_Set(SETID_ALLPLAY_INFO, &allplayInfo);
}

static void AllPlaySrv_Resp(QActive * sender, cAllPlaySrv * const me)
{
    if(!sender)
    {
        return;
    }
    AllPlaySrvInfoEvt* resp = Q_NEW(AllPlaySrvInfoEvt, ALLPLAY_RESP_SIG);
    assert(resp);
    AllPlaySrvInfoEvt *pAllplayInfo = (AllPlaySrvInfoEvt*)Setting_Get(SETID_ALLPLAY_INFO);
    resp->bAllplayConnected = pAllplayInfo->bAllplayConnected;
    resp->eSystemMode       = pAllplayInfo->eSystemMode;
    resp->ePlayerState      = pAllplayInfo->ePlayerState;
    QACTIVE_POST(sender,(QEvt*)resp,me);
}

static void AllPlaySrv_PublishAllPlayState(cAllPlaySrv * const me, enum allplay_message_type msg_type)
{
    eAllPlayStateIndEvt allPlayState = ALLPLAY_STATE_MAX;
    switch(msg_type)
    {
        case ALLPLAY_EVENT_PLAYER_STATE_CHANGED:
        {
            switch (allPlayDrv.ePlayerState)
            {
                case ALLPLAY_PLAYER_STATE_STOPPED:
                    allPlayState = ALLPLAY_STATE_PLAYER_STOPPED;
                    break;
                case ALLPLAY_PLAYER_STATE_PLAYING:
                    allPlayState = ALLPLAY_STATE_PLAYER_PLAYING;
                    break;
                case ALLPLAY_PLAYER_STATE_PAUSED:
                    allPlayState = ALLPLAY_STATE_PLAYER_PAUSED;
                    break;
                default:
                    break;
            }
            break;
        }
        case ALLPLAY_EVENT_CONNECTION_STATUS_CHANGED:
        {
            if(allplay_is_connected(allPlayDrv.apctx))
                allPlayState = ALLPLAY_STATE_MCU_SAM_CONNECTED;
            else
                allPlayState = ALLPLAY_STATE_MCU_SAM_DISCONNECTED;
            break;
        }
        case ALLPLAY_RESPONSE_RESET_TO_FACTORY:
        {
            allPlayState = ALLPLAY_STATE_SAM_FACTORY_RESET_DONE;
            break;
        }
        default:
            break;
    }

    if(ALLPLAY_STATE_MAX != allPlayState)
    {
         AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
         p->allPlayState = allPlayState;
         QF_PUBLISH(&p->super, 0);
    }
}

static QState AllPlaySrv_Active(cAllPlaySrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
            p->allPlayState = ALLPLAY_STATE_ACTIVE;
            QF_PUBLISH(&p->super, 0);

            PersistantObj_RefreshTick((cPersistantObj*)me, ALLPLAY_SRV_TICK_TIME);
            break;
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            ASSERT(0);
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);

            AllPlayDrv_Xtor(&allPlayDrv);
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change

            UartDrv_Xtor(&aj_uart);
            RingBuf_Xtor(&txBuf);
            RingBuf_Xtor(&rxBuf);
            AllPlayDrv_freeCtx(&allPlayDrv);
            AllPlayDrv_assertReset(1);

            return Q_TRAN(&AllPlaySrv_DeActive);
        }
        case ALLPLAY_CMD_SIG:
        {
            const AllPlayCmdEvt* allplayCmdEvt = (const AllPlayCmdEvt*)e;
            if(allplayCmdEvt->allPlayCmd == ALLPLAY_CMD_SET_VOL)
            {
                changeVolTimer = ALLPLAY_VOLUME_CHANGE_TIMEOUT_IN_MS;
            }
            enum allplay_message_type msg_type = AllPlayDrv_cmd(&allPlayDrv, allplayCmdEvt);
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change
            AllPlaySrv_PublishAllPlayState(me, msg_type);
            break;
        }
        case ALLPLAY_TIMEOUT_SIG:
        {
            if(changeVolTimer)
            {
                changeVolTimer -= ALLPLAY_SRV_TICK_TIME;
                if(0 >= changeVolTimer)
                {
                    isChangingVol = FALSE;
                }
            }
            enum allplay_message_type msg_type = AllPlaySrv_Ticker(me);
            AllPlaySrv_PublishAllPlayState(me, msg_type);
            PersistantObj_RefreshTick((cPersistantObj*)me, ALLPLAY_SRV_TICK_TIME);
            return Q_HANDLED();
        }
        case ALLPLAY_UART_RX_SIG:
            return Q_HANDLED();

        case ALLPLAY_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            AllPlaySrv_Resp(pReq->sender, me);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
            QTimeEvt_disarm(TIME_EVT_OF(me));
            break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState AllPlaySrv_DeActive(cAllPlaySrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
            p->allPlayState = ALLPLAY_STATE_OFF;
            QF_PUBLISH(&p->super, 0);

            break;
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            ASSERT(0);
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);

            RingBuf_Ctor(&txBuf, uartTxBuf, ArraySize(uartTxBuf));
            RingBuf_Ctor(&rxBuf, uartRxBuf, ArraySize(uartRxBuf));
            UartDrv_Ctor(&aj_uart, (tUARTDevice*) getDevicebyId(ALLPLAY_DEV_ID, NULL), &txBuf, &rxBuf);
            UartDrv_RegisterRxCallback(&aj_uart, AllPlayDrv_RxIntCb);
           
            QTimeEvt_disarm(&me->resetAssertEvt);
            QTimeEvt_armX(&me->resetAssertEvt, ALLPLAY_ASSERT_RESET_WAIT_TIME, 0);

            AllPlayDrv_Ctor(&allPlayDrv, /* set to 1 such that SAM has the reset line asserted */1);
            AllPlaySrv_SaveInfo(me); //Save allplay info when (allplayDrv) have any change

            AllPlayDrv_newCtx(&allPlayDrv);
            AllPlayStateIndEvt *p = Q_NEW(AllPlayStateIndEvt, ALLPLAY_STATE_SIG);
            p->allPlayState = ALLPLAY_STATE_PREPARATION;
            QF_PUBLISH(&p->super, 0);
        }
        case ALLPLAY_RESET_ASSERT_SIG:
            AllPlayDrv_assertReset(0);
            return Q_TRAN(&AllPlaySrv_Active);
            break;
        case Q_EXIT_SIG:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

void AllPlaySrv_netReset(void)
{
    AllPlaySrv_SendCmd(ALLPLAY_CMD_NET_RESET);
}

void AllPlaySrv_enableDirectMode(bool bEnable)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_DIRECT_MODE_ENABLE;
    e->payload.bEnableDirect = bEnable;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_resetToFactory(void)
{
    AllPlaySrv_SendCmd(ALLPLAY_CMD_RESET_TO_FACTORY);
}

void AllPlaySrv_SendCmd(eAllPlayCmdEvt allplayCmd)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = allplayCmd;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_IncVol(int8 volStep)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_VOL_INC;
    e->payload.volStep = volStep;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_DecVol(int8 volStep)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_VOL_DEC;
    e->payload.volStep = volStep;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_SetVol(const uint8 setVol)
{
    isChangingVol = TRUE;
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->sender = NULL;
    e->allPlayCmd = ALLPLAY_CMD_SET_VOL;
    e->payload.setVol = setVol;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_SetMcuIdle(const bool bIsIdle)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_SET_MCU_IDLE;
    e->payload.bIsIdle = bIsIdle;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_SetBatteryState(const tBatteryState batteryState)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_SET_BATTERY_STATE;
    e->payload.batteryState = batteryState;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_SetExternalSource(const tExternalSourceInfo externalSourceInfo)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_SET_EXTERNAL_SOURCE;
    e->payload.externalSourceInfo = externalSourceInfo;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

#ifdef HAS_ALLPLAY_BT
void AllPlaySrv_BluetoothEnable(const bool bBtEnable)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_BT_ENABLE;
    e->payload.bBtEnable = bBtEnable;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}

void AllPlaySrv_BluetoothPairable(const bool bBtPairable)
{
    AllPlayCmdEvt *e = (AllPlayCmdEvt*)Q_NEW(AllPlayCmdEvt, ALLPLAY_CMD_SIG);
    e->allPlayCmd = ALLPLAY_CMD_BT_PAIRABLE;
    e->payload.bBtPairable= bBtPairable;
    SendToServer(ALLPLAY_SRV_ID, (QEvt*)e);
}
#endif /* HAS_ALLPLAY_BT */


/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Ase_tk Server
                  -------------------------
                  SW Module Document




@file        AseTkSrv.c
@brief       it's the server to control the ase_tk module
@author      Johnny Fan
@date        2014-05-11
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-8     Johnny Fan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "stm32f0xx.h"
#include "product.config"
#include "AseTkSrv_priv.h"
#include "AsetkSrv.h"
#include "bsp.h"
#include "controller.h"
#include "SettingSrv.h"
#include "trace.h"
#include "ringbuf.h"
#include "UartDrv.h"
#include "yahdlc.h"
#include "bl_common.h"
#include "fep_addr.h"

#define CAST_ME cAseTkSrv * AseTkSrv = (cAseTkSrv *) me;


/********************************************/
/*************Definition*********************/
/********************************************/
/* To avoid send too many log to ASE-TK, this file print to UART only
 */
#undef TP_PRINTF
#if defined(ASE_TK_DEBUG_ENABLE) && !defined(NDEBUG)
    #define TP_PRINTF(...)  ProjBsp_Printf(/*toAsetk:*/FALSE, __FILE__, __LINE__, __VA_ARGS__)
#else    
    #define TP_PRINTF(...)
#endif  // NDEBUG


/********************************************/
/***************CONFIG***********************/
/********************************************/
#define ASE_UART_TX_BUF_SIZE     (0x416 * 4)
#define ASE_UART_RX_BUF_SIZE     (0x416)

/* the time (ms) per timeout signal */
#define ASETK_SRV_PER_TICK_TIME_MS  (10)
#define ASETK_SRV_COM_WDG_TIME_MS (10*1000) // 10 seconds,  the value must be mutiple of ASETK_SRV_PER_TICK_TIME_MS

#define ASETK_SRV_MAX_ALIVE_REQ (3)

/* the buffer size used to decode the message, change it according to message size */
#define ASETK_SRV_DECODE_BUFFER_SIZE (300)

#define YAHDLC_SEQ_NO_MAX           (7)

#define ASE_TK_MODULE_GPIO_DELAY    (100)
#define ASE_TK_MODULE_OFF_DELAY     ASETK_SRV_PER_TICK_TIME_MS

/********************************************/
/***************variables***********************/
/********************************************/

static uint8        uartTxBuf[ASE_UART_TX_BUF_SIZE];
static uint8        uartRxBuf[ASE_UART_RX_BUF_SIZE];
static cRingBuf     txBuf;
static cRingBuf     rxBuf;
cUartDrv            aseTk_uart;
/* Internal event queue */
static QEvt const *AseTkEvtQue[ASETK_SRV_EVENT_Q_SIZE];
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[3];

static AseFepMessage rMessage;

static uint8 glInputTunnelBuffer[ASETK_TUNNEL_BUFFER_SIZE];
static uint8 glOutputTunnelBuffer[ASETK_TUNNEL_BUFFER_SIZE];
static bool  glEnabledTpMonitorEmul = FALSE;

static InternalSpeaker glIntSpeaker[INT_SPK_TYPE_NUM][INT_SPK_POS_NUM];
static AsetkNetworkInfo glNetworkInfo;


enum InternalSignals
{
    ASETK_TIMEOUT_SIG = MAX_SIG,
};

//#ifdef __ICCARM__
//static const uint32 Fw_version@"FW_VERSION_SECT" =
//    (SW_MAJOR_VERSION << 24) | (SW_MINOR_VERSION1 << 16) |
//    (SW_MINOR_VERSION2 << 8) | (SW_MINOR_VERSION3);
//#endif


static tSeqSection AseTkModuleInitSection[] =
{
    {&AseTkSrv_moduleSysDis,    ASE_TK_MODULE_OFF_DELAY},
    {&AseTkSrv_moduleResetNDis, ASE_TK_MODULE_GPIO_DELAY},
    {&AseTkSrv_moduleSysEn,     ASE_TK_MODULE_GPIO_DELAY},
    {&AseTkSrv_moduleResetNEn,  0},
};

static tSeqSection AseTkModuleDestroySection[] =
{
    {&AseTkSrv_moduleSysDis,    ASE_TK_MODULE_OFF_DELAY},
    {&AseTkSrv_moduleResetNDis, ASE_TK_MODULE_OFF_DELAY},
    {&AseTkSrv_DeInitUart,       0},
};

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void AseTkSrv_initCallbackBuf(cAseTkSrv * const me)
{
    memset(glInputTunnelBuffer, 0, sizeof(glInputTunnelBuffer));
    memset(glOutputTunnelBuffer, 0, sizeof(glOutputTunnelBuffer));
    memset(glIntSpeaker, 0, sizeof(glIntSpeaker));    
    memset(&glNetworkInfo, 0, sizeof(glNetworkInfo));

    //ASE-TK v1.6.23 do not support quality, we temperature set to GOOD quality.
    glNetworkInfo.wifi_quality= WiFi_Quality_GOOD; 
}


static void AseTkSrv_updateStblStatus(cAseTkSrv * const me, uint32 stbl_status)
{
    cStorageDrv *pStorageDrv = me->pStorageDrv;
    uint32 stbl_content[] = 
    {
        stbl_status,
        *(uint32*)FEP_ADDR_UBL_CHECKSUM,
        *(uint32*)FEP_ADDR_FIRMWARE_CHECKSUM,
    };

    if(pStorageDrv->ErasePage)
    {
        pStorageDrv->ErasePage(pStorageDrv, FEP_ADDR_STBL_STATUS);
    }
    pStorageDrv->SetValue(pStorageDrv, FEP_ADDR_STBL_STATUS,
                                (uint8*)stbl_content, sizeof(stbl_content));
}

static bool AseTkSrv_isModulePowerUp(cAseTkSrv * const me)
{
    // check if the module enable pin and reset_n pin is configured before
    bool set_rstn  = GpioDrv_isBitSet(&me->gpio, GPIO_OUT_ASE_RST_N);
    bool set_sysEn = GpioDrv_isBitSet(&me->gpio, GPIO_OUT_ASE_SYS_EN);

    return (set_rstn && set_sysEn);
}

static void AseTkSrv_moduleSysDis(void *me)
{
    CAST_ME;
    GpioDrv_ClearBit(&AseTkSrv->gpio, GPIO_OUT_ASE_SYS_EN);
}

static void AseTkSrv_moduleResetNDis(void *me)
{
    CAST_ME;
    GpioDrv_ClearBit(&AseTkSrv->gpio, GPIO_OUT_ASE_RST_N);
}

static void AseTkSrv_DeInitUart(void *me)
{
    //Deinit driver
    UartDrv_Xtor(&aseTk_uart);
    RingBuf_Xtor(&txBuf);
    RingBuf_Xtor(&rxBuf);
}

static void AseTkSrv_moduleSysEn(void *me)
{
    cAseTkSrv *aseTkSrv = (cAseTkSrv*) me;
    GpioDrv_SetBit(&aseTkSrv->gpio, GPIO_OUT_ASE_SYS_EN);
}

static void AseTkSrv_moduleResetNEn(void *me)
{
    cAseTkSrv *aseTkSrv = (cAseTkSrv*) me;
    GpioDrv_SetBit(&aseTkSrv->gpio, GPIO_OUT_ASE_RST_N);
}

static void AseTkSrv_InitUart(void *me)
{
    //Init driver
    RingBuf_Ctor(&txBuf, uartTxBuf, ArraySize(uartTxBuf));
    RingBuf_Ctor(&rxBuf, uartRxBuf, ArraySize(uartRxBuf));
    UartDrv_Ctor(&aseTk_uart, (tUARTDevice*) getDevicebyIdAndType(ASETK_DEV_ID, UART_DEV_TYPE, NULL), &txBuf, &rxBuf);
    UartDrv_RegisterRxCallback(&aseTk_uart, AseTkSrv_OnReceive);
}

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AseTkSrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(AseTkSrv);
    QS_OBJ_DICTIONARY(AseTkSrv_PreActive);
    QS_OBJ_DICTIONARY(AseTkSrv_Active);
    QS_OBJ_DICTIONARY(AseTkSrv_DeActive);

    AseTkSrv->pStorageDrv = (cStorageDrv *)&AseTkSrv_storageDrv;
    StorageDrv_Ctor(AseTkSrv->pStorageDrv,
                    (tStorageDevice*)getDevicebyId(INT_FLASH_DEV_ID, NULL));
    //RingBuf_Ctor(&txBuf, uartTxBuf, ArraySize(uartTxBuf));
    //RingBuf_Ctor(&rxBuf, uartRxBuf, ArraySize(uartRxBuf));
    //UartDrv_Ctor(&aseTk_uart, (tUARTDevice*) getDevicebyIdAndType(ASETK_DEV_ID, UART_DEV_TYPE, NULL), &txBuf, &rxBuf);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&AseTkSrv_Initial), ASETK_TIMEOUT_SIG,
                AseTkEvtQue, Q_DIM(AseTkEvtQue), ASETK_SRV_ID);
    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
}

void AseTkSrv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */

QState AseTkSrv_Initial(cAseTkSrv * const me, QEvt const * const e)
{
    //bool moduleUp;
    me->gpio.gpioConfig = (tGPIODevice*) getDevicebyIdAndType(ASETK_DEV_ID, GPIO_DEV_TYPE, NULL);

    //moduleUp = AseTkSrv_isModulePowerUp(me);    // get status before initialize
    GpioDrv_Ctor(&me->gpio, me->gpio.gpioConfig);
    AseTkSrv_DisableComWdg(me);
    AseTkSrv_initCallbackBuf(me);

    /*Set default value */
    const bool connected = FALSE;
    Setting_Set(SETID_ASETK_CONNECTED, &connected);
    /*
    * We assumed ASETK module may already been power on in PIU.
    * But ASETK server should stay at deactive state before receive SYSTEM_ACTIVE_REQ_SIG.
    */
    return Q_TRAN(&AseTkSrv_DeActive);
}

/* This state is used to as wait state. Wait until power on */
QState AseTkSrv_PreActive(cAseTkSrv * const me, QEvt const * const e)
{
    switch(e->sig)
    {
        case Q_ENTRY_SIG:
        {   
            AseTkSrv_InitUart(me);
            /* First boot: ASE-TK was powered on by PIU
             * Wakeup from OFF: ASE-TK will power up here
             * Forst boot, use ST-Link online debug: because PIU is not appear, ASe-TK wil power up here
             * After upgrade UBL or Firmware: ASE-TK was powered on before upgrade.
             */
            eFepFirmwareStatus fw_status = bl_getFirmwareStatus();
            
            //Note here is early stage, can not print any message
            if (FEP_FIRMWARE_NEW == fw_status)
            {
                TP_PRINTF("ASE-TK has was booted up before upgrade\r\n");
                AseTkSrv_EnableComWdg(me);

                //ASE-TK Init operation
                AseTkSrv_QueryInternalSpeakerCompensation();                
                AseTkSrv_SendPowerStatus();
            }
            else if (FEP_FIRMWARE_POWERED_ASETK == fw_status)
            {
                TP_PRINTF(" ASE-TK has was powered on by PIU. \r\n");
                bl_setFirmwareStatus(FEP_FIRMWARE_NORMAL);  // avoid skipping ASE-TK boot-up for next power cycle.
            }
            else
            {
                TP_PRINTF(" Reset and power on ASE-TK!!! \r\n");
                Seq_Ctor(&me->seq, me, AseTkModuleInitSection, ArraySize(AseTkModuleInitSection));
            }

            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            return Q_HANDLED();
        }
        case ASETK_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            if (!Seq_isSeqFinished(&me->seq))
            {
                Seq_Refresh(&me->seq, ASETK_SRV_PER_TICK_TIME_MS);
            }
            else
            {
                CommonEvtResp((QActive*)me, me->pSender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
                return Q_TRAN(&AseTkSrv_Active);
            }
            return Q_HANDLED();
        }
        /* receive request from MainApp */
        case ASE_TK_REQ_SIG:
        {
            QActive_defer((QActive *)me, &deferredReqQue, e);
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            QActive_defer((QActive *)me, &deferredReqQue, e);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default:
            /* Not list all the QP signals here, so doesn't put a assert in the default*/
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*   Active state - first state where "normal" service begins  */
QState AseTkSrv_Active(cAseTkSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            QActive_recall((QActive*)me, &deferredReqQue);
            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            
            AseTkSrv_initCallbackBuf(me);
            
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            me->pSender = pReq->sender;
            return Q_TRAN(AseTkSrv_PreDeActive);
        }
#ifdef HAS_PRODUCTION_TEST_DISABLE_ASE_TK_UART
        case PT_ASE_DISABLE_UART_REQ_SIG:
        {
            return Q_TRAN(AseTkSrv_PreDeActive);
        }
#endif
        /* receive request from MainApp */
        case ASE_TK_REQ_SIG:
        {
            AseTkCmdEvt* evt = (AseTkCmdEvt*) e;
            FepAseMessage* pMsg = &(evt->fepAseCmd);
            AseTkSrv_SendMessage(pMsg);
            return Q_HANDLED();
        }
        case ASETK_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            AseTkSrv_CheckComWdgTimer(me);
            return Q_HANDLED();
        }
        /* receive commands from ASE_TK module */
        case ASETK_RECEIVE_COMMAND:
        {
            FepCmdEvt* evt = (FepCmdEvt*)e ;

#ifdef HAS_PRODUCTION_TEST_RECEIVE_ASE_TK_NOTICE
            {
                const bool connected = TRUE;
                Setting_Set(SETID_ASETK_CONNECTED, &connected);
                //TP_PRINTF("\r\n\r\n\r\n\r\n *** ASE-TK init = 1 ***\r\n\r\n\r\n\r\n");
            }
#endif
            AseTkSrv_HandleAseCommand(me, evt->aseFepCmd);
            AseTkSrv_FeedComWdg(me);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            AseTkSrv_DisableComWdg(me);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/* This state is used to as wait state. Wait until power off */
QState AseTkSrv_PreDeActive(cAseTkSrv * const me, QEvt const * const e)
{
    switch(e->sig)
    {
        case Q_ENTRY_SIG:
        {
            Seq_Ctor(&me->seq, me, AseTkModuleDestroySection, ArraySize(AseTkModuleDestroySection));
            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            
#ifdef HAS_PRODUCTION_TEST_RECEIVE_ASE_TK_NOTICE
            {
                const bool connected = FALSE;
                Setting_Set(SETID_ASETK_CONNECTED, &connected);
                //TP_PRINTF("\r\n\r\n\r\n\r\n *** ASE-TK init = 0 ***\r\n\r\n\r\n\r\n");
            }
#endif
            return Q_HANDLED();
        }
        case ASETK_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, ASETK_SRV_PER_TICK_TIME_MS);
            if (!Seq_isSeqFinished(&me->seq))
            {
                Seq_Refresh(&me->seq, ASETK_SRV_PER_TICK_TIME_MS);
            }
            else
            {
                CommonEvtResp((QActive*)me, me->pSender, RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
                return Q_TRAN(AseTkSrv_DeActive);
            }
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            QActive_defer((QActive *)me, &deferredReqQue, e);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default:
            /* Not list all the QP signals here, so doesn't put a assert in the default*/
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*   DeActive state - Use this state to ramp down the server  */
QState AseTkSrv_DeActive(cAseTkSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            QActive_recall((QActive*)me, &deferredReqQue);
            return Q_HANDLED();
        }
#ifdef HAS_PRODUCTION_TEST_DISABLE_ASE_TK_UART
        case SYSTEM_SLEEP_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
            return Q_HANDLED();
        }
#endif
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            me->pSender = pReq->sender;
            return Q_TRAN(&AseTkSrv_PreActive);
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}




/****************************************************
 * Public Function
 ****************************************************/
void AseTkSrv_SendFepAseCmd(FepAseCommand_Command msg)
{
    AseTkCmdEvt* evt = Q_NEW(AseTkCmdEvt, ASE_TK_REQ_SIG);

    evt->fepAseCmd.which_OneOf  = FepAseMessage_fepAseCommand_tag;

    evt->fepAseCmd.OneOf.fepAseCommand.has_command  = true;
    evt->fepAseCmd.OneOf.fepAseCommand.command      = msg;

    SendToServer(ASETK_SRV_ID,(QEvt*)evt);
}

void AseTkSrv_SendFepAseCmdRelativeVol(int32_t relativeVolume)
{
    AseTkCmdEvt* evt = Q_NEW(AseTkCmdEvt, ASE_TK_REQ_SIG);

    evt->fepAseCmd.which_OneOf  = FepAseMessage_fepAseRelativeVolumeCommand_tag;

    evt->fepAseCmd.OneOf.fepAseRelativeVolumeCommand.has_volume= true;
    evt->fepAseCmd.OneOf.fepAseRelativeVolumeCommand.volume= relativeVolume;

    SendToServer(ASETK_SRV_ID,(QEvt*)evt);
}

void AseTkSrv_SendFepAseCmdAbsoluteVol(int32_t absoluteVolume)
{
    AseTkCmdEvt* evt = Q_NEW(AseTkCmdEvt, ASE_TK_REQ_SIG);

    evt->fepAseCmd.which_OneOf  = FepAseMessage_fepAseAbsoluteVolumeCommand_tag;

    evt->fepAseCmd.OneOf.fepAseAbsoluteVolumeCommand.has_volume= true;
    evt->fepAseCmd.OneOf.fepAseRelativeVolumeCommand.volume= absoluteVolume;

    SendToServer(ASETK_SRV_ID,(QEvt*)evt);
}

void AseTkSrv_SendFepAseEvent(FepAseEvent_Event event)
{
    AseTkCmdEvt* evt = Q_NEW(AseTkCmdEvt, ASE_TK_REQ_SIG);

    evt->fepAseCmd.which_OneOf  = FepAseMessage_fepAseEvent_tag;
    evt->fepAseCmd.OneOf.fepAseEvent.has_event= true;
    evt->fepAseCmd.OneOf.fepAseEvent.event  = event;
    
    SendToServer(ASETK_SRV_ID,(QEvt*)evt);
}


static bool AseTkSrv_encodeVersionInfoDetails(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    //FepAseMessage const *pMsg = (FepAseMessage const *)arg;
    
    static uint8 product_name[]  = TP_PRODUCT;
    char *bootloader_version     = bl_readVersion( (void*)FEP_ADDR_UBL_VER );

#ifndef NDEBUG
    static uint8 application_version[]   = PRODUCT_VERSION_MCU "d";
#else
    static uint8 application_version[]   = PRODUCT_VERSION_MCU;
#endif

    static char *configuration_version= "unknown";
    configuration_version= (char*)Setting_GetEx(SETID_DSP_VER, configuration_version);
    
    const uint8 *hardware_version = " ";
    hardware_version= Setting_GetEx(SETID_HW_VER, hardware_version);
    
    TP_PRINTF("\r\n\r\nSend Version to ASE-TK: name=%s, ubl=%s, fw=%s, dsp=%s, hw=%s\r\n\r\n\r\n", 
              product_name, bootloader_version, application_version, configuration_version, hardware_version);

    return pb_encode_tag(stream, PB_WT_STRING, 1) &&
           pb_encode_string(stream, product_name, sizeof(product_name) - 1) &&
           pb_encode_tag(stream, PB_WT_STRING, 2) &&
           pb_encode_string(stream, hardware_version, strlen((char*)hardware_version)) &&
           pb_encode_tag(stream, PB_WT_STRING, 3) &&
           pb_encode_string(stream, (const uint8*)bootloader_version, strlen(bootloader_version) ) &&
           pb_encode_tag(stream, PB_WT_STRING, 4) &&
           pb_encode_string(stream, application_version, sizeof(application_version) - 1) &&
           pb_encode_tag(stream, PB_WT_STRING, 5) &&
           pb_encode_string(stream, (const uint8*)configuration_version, strlen(configuration_version));
}

static bool AseTkSrv_encodeVersionInfo(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    FepAseVersionInfo msg;

    msg.module.funcs.encode = AseTkSrv_encodeVersionInfoDetails;
    msg.module.arg = NULL;

    return pb_encode_tag_for_field(stream, FepAseVersionInfo_fields) &&
        pb_encode_submessage(stream, FepAseVersionInfo_fields, &msg);
}

void AseTkSrv_SendVersion()
{
    FepAseMessage msg;

    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseVersionInfo_tag;
    msg.OneOf.fepAseVersionInfo.module.funcs.encode = AseTkSrv_encodeVersionInfo;
    msg.OneOf.fepAseVersionInfo.module.arg  = NULL;
    AseTkSrv_SendMessage(&msg);
}

static bool AseTkSrv_encodeLogText(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    return pb_encode_tag_for_field(stream, field) &&
           pb_encode_string(stream, *arg, strlen(*arg));
}

static bool AseTkSrv_encodeLogFile(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    return pb_encode_tag_for_field(stream, field) &&
           pb_encode_string(stream, *arg, strlen(*arg));
}

AsetkNetworkInfo* AseTkSrv_GetDecodedNetworkInfo()
{
    return &glNetworkInfo;
}


void AseTkSrv_QueryInternalSpeakerCompensation()
{
    if( !Setting_IsReady(SETID_ASETK_CONNECTED) || !(*(bool*)Setting_Get(SETID_ASETK_CONNECTED)) ) 
    {
        TP_PRINTF("AseTkSrv_QueryInternalSpeakerCompensation: ignore because ASE-TK was not ready \r\n");
        return;
    }
    
    TP_PRINTF("AseTkSrv_QueryInternalSpeakerCompensation \r\n");
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseReq_tag;
    msg.OneOf.fepAseReq.request= FepAseReq_Request_GET_INTERNAL_SPEAKER_COMPENSATION;
    AseTkSrv_SendMessage(&msg); 
}


void AseTkSrv_SendLog(const char * str, const char * file, uint32 line)
{
    if( !Setting_IsReady(SETID_ASETK_CONNECTED) || !(*(bool*)Setting_Get(SETID_ASETK_CONNECTED)) ) 
    {
        return;
    }    

    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseProductLog_tag;
    msg.OneOf.fepAseProductLog.text.funcs.encode = AseTkSrv_encodeLogText;
    msg.OneOf.fepAseProductLog.text.arg = (void*) str;
    msg.OneOf.fepAseProductLog.file.funcs.encode = AseTkSrv_encodeLogFile;
    msg.OneOf.fepAseProductLog.file.arg = (void*) file;
    msg.OneOf.fepAseProductLog.has_line = TRUE;
    msg.OneOf.fepAseProductLog.line     = line;
    AseTkSrv_SendMessage(&msg);
}


void AseTkSrv_PlayComfortTone(char* tone_name)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAsePlayComfortToneCmd_tag;    
    msg.OneOf.fepAsePlayComfortToneCmd.tone.funcs.encode = AseTkSrv_encodeLogText;
    msg.OneOf.fepAsePlayComfortToneCmd.tone.arg = (void*) tone_name;
    AseTkSrv_SendMessage(&msg);
}


void AseTkSrv_SendProductInfo(const char *prod_name, FepAseProductInfo_ProductId prod_id)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseProductInfo_tag;
    msg.OneOf.fepAseProductInfo.productName.funcs.encode = AseTkSrv_encodeLogText;
    msg.OneOf.fepAseProductInfo.productName.arg = (void*) prod_name;
    msg.OneOf.fepAseProductInfo.productId = prod_id;
    AseTkSrv_SendMessage(&msg);
}


void AseTkSrv_ReplyVolumeFade(uint8 vol)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseVolumeFadeComplete_tag;
    msg.OneOf.fepAseVolumeFadeComplete.volume = vol;
    AseTkSrv_SendMessage(&msg);
}


__weak bool AseTkSrv_encodeInternalSpeakerCompensationDetails(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    return 1;
}

void AseTkSrv_SendInternalSpeakerCompensation()
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseInternalSpeakerCompensationResp_tag;
    msg.OneOf.fepAseInternalSpeakerCompensationResp.error= FepAseInternalSpeakerCompensationResp_Error_NO_ERROR;    
    msg.OneOf.fepAseInternalSpeakerCompensationResp.internalSpeaker.funcs.encode = AseTkSrv_encodeInternalSpeakerCompensationDetails;    
    msg.OneOf.fepAseInternalSpeakerCompensationResp.internalSpeaker.arg = NULL;
    
    AseTkSrv_SendMessage(&msg);
}



void AseTkSrv_ReplySetAudioInput(bool success)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseSetAudioInputResp_tag;

    /* We do not record which source is, thus alwasy feedback has_success=FALSE */
    msg.OneOf.fepAseSetAudioInputResp.has_success= FALSE;    
    msg.OneOf.fepAseSetAudioInputResp.success= success;
    AseTkSrv_SendMessage(&msg);
}


void AseTkSrv_ReplySetPositionSoundMode(FepAsePositionSoundModeResp soundModeResp)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAsePositionSoundModeResp_tag;
    msg.OneOf.fepAsePositionSoundModeResp = soundModeResp;
    AseTkSrv_SendMessage(&msg);
}

void AseTkSrv_ReplyAudioPcmFormatCommand(bool success)
{
    //TODO
    //FepAseMessage msg;
    //msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseSetAudioPcmFormatCommandResp_tag;
}


static bool AseTkSrv_encodeTunnelStream(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
{
    sOutPutTunnelMessage *pOutPutTunnelMessage = *arg;

    return pb_encode_tag_for_field(stream, field) &&
           pb_encode_string(stream, pOutPutTunnelMessage->OutputTunnelBuffer, pOutPutTunnelMessage->MessageSize);
}

void AseTkSrv_SendTunnel(const uint8 * stream, size_t size)
{
    FepAseMessage msg;
    sOutPutTunnelMessage glOutPutTunnelMessage;

    glOutPutTunnelMessage.MessageSize = size;
    memcpy(glOutPutTunnelMessage.OutputTunnelBuffer, stream, glOutPutTunnelMessage.MessageSize);

    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseTunnel_tag;
    msg.OneOf.fepAseTunnel.data.funcs.encode = AseTkSrv_encodeTunnelStream;
    msg.OneOf.fepAseTunnel.data.arg = (void*) &glOutPutTunnelMessage;
    AseTkSrv_SendMessage(&msg);
}

bool AseTkSrv_TunnelInputCb(pb_istream_t *stream, const pb_field_t *field, void **arg)
{
    memset(glInputTunnelBuffer, 0x00, ASETK_TUNNEL_BUFFER_SIZE);

    if (stream->bytes_left > sizeof(glInputTunnelBuffer))
    {
        return false;
    }
    if (!pb_read(stream, glInputTunnelBuffer, stream->bytes_left))
    {
        return false;
    }
    return true;
}

bool AseTkSrv_NetworkInfoInputCb(pb_istream_t *stream, const pb_field_t *field, void **arg)
{
    NetworkInfo networkInfo;
    memset(&networkInfo, 0x00, sizeof(networkInfo));

    if (!pb_decode_noinit(stream, NetworkInfo_fields, &networkInfo))
    {
        return false;
    }

    //Network type
    TP_PRINTF("AseTkSrv_NetworkInfoInputCb: " );
    if (networkInfo.has_type)
    {
        if(networkInfo.type==NetworkInfo_Type_WIFI) {
            TP_PRINTF("wifi=%d", networkInfo.state );
            glNetworkInfo.wifi_state= networkInfo.state;
        }
        else if(networkInfo.type==NetworkInfo_Type_ETHERNET) {
            TP_PRINTF("ethernet=%d", networkInfo.state );
            glNetworkInfo.ethernet_state= networkInfo.state;
        }
        else if(networkInfo.type==NetworkInfo_Type_SOFT_AP) {
            TP_PRINTF("softAp=%d", networkInfo.state );
            glNetworkInfo.soft_ap_state= networkInfo.state;
        }
        else {
            TP_PRINTF("unknown network type (%d) state = %d", networkInfo.has_type, networkInfo.state );
        }
    }

    //Wifi information
    if (networkInfo.has_wifi)
    {
        if(networkInfo.wifi.has_Configured)
        {
            glNetworkInfo.wifi_configured= networkInfo.wifi.Configured;
            TP_PRINTF(", wifi_configured=%d", networkInfo.wifi.Configured);
        }
        if(networkInfo.wifi.has_quality)
        {
            glNetworkInfo.wifi_quality= networkInfo.wifi.quality;
            TP_PRINTF(", wifi_quality=%d", networkInfo.wifi.quality);
        }
    }
    TP_PRINTF("\r\n");

    return true;
}


__weak bool AseTkSrv_DspParameterCmd_WriteValue(DspParameter *dspParam)
{
    //Should implement on MainApp
}


bool AseTkSrv_DspParameterCmdCb(pb_istream_t *stream, const pb_field_t *field, void **arg)
{
    //Write DSP parameters
    DspParameter dspParam;
    memset(&dspParam, 0x00, sizeof(dspParam));

    if (!pb_decode_noinit(stream, DspParameter_fields, &dspParam))
    {
        return false;
    }

    bool ret= AseTkSrv_DspParameterCmd_WriteValue(&dspParam);
    
    //Reply
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseDspParameterResponse_tag;
    msg.OneOf.fepAseDspParameterResponse.has_error= TRUE;
    
    if(ret)
    {
        msg.OneOf.fepAseDspParameterResponse.error= FepAseDspParameterResponse_Error_NO_ERROR;    
    }
    else
    {
        msg.OneOf.fepAseDspParameterResponse.error= FepAseDspParameterResponse_Error_ERROR;          
    }
    
    //msg.OneOf.fepAseDspParameterResponse.parameter.funcs.encode= AseTkSrv_encodeDspParametersReplyDetails;    
    msg.OneOf.fepAseDspParameterResponse.parameter.funcs.encode= NULL;    
    msg.OneOf.fepAseDspParameterResponse.parameter.arg = NULL;    
    AseTkSrv_SendMessage(&msg);
    
    return true;
}


__weak FepAseInternalSpeakerCompensationResp_Error AseTkSrv_Callback_SetInternalSpeakerCompensation(InternalSpeaker_Position position, InternalSpeaker_Type type, double gain) 
{
    return FepAseInternalSpeakerCompensationResp_Error_NO_ERROR;
}
bool AseTkSrv_SetInternalSpeakerCompensationCb(pb_istream_t *stream, const pb_field_t *field, void **arg)
{
    InternalSpeaker intSpk;
    memset(&intSpk, 0x00, sizeof(intSpk));

    if (!pb_decode_noinit(stream, InternalSpeaker_fields, &intSpk))
    {
        return false;
    }

    if (intSpk.has_compensation)
    {
        AseTkSrv_Callback_SetInternalSpeakerCompensation(intSpk.position, intSpk.type, intSpk.compensation);
    }
    //TP_PRINTF("AseTkSrv_SetInternalSpeakerCompensationCb: pos=%d, type=%d, gain=%f\r\n", intSpk.position, intSpk.type, intSpk.compensation);
    
    AseTkSrv_SendInternalSpeakerCompensation();

    return true;
}

static void AseTkSrv_AseFepTunnelHandler(cAseTkSrv * const me)
{
#ifdef HAS_ASE_TK_SERVICE_TOOL
    switch(glInputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID])
    {
        case ASETK_TUNNEL_COMMAND_ECHO_REQ:
        {
            glInputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_ECHO_RESP;
            AseTkSrv_SendTunnel(glInputTunnelBuffer, glInputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] + 2);
            break;
        }
#ifdef BnO_fs1
        case ASETK_TUNNEL_COMMAND_BI_REQ:
        {
            volatile uint16 tempValue;

            glInputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_BI_RESP;
            glInputTunnelBuffer[ASETK_TUNNEL_MO_SIZE]       = 20;

            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_CAPACITY_RSOC_USER) )
            {
                tempValue = (uint16) *(uint8*)Setting_Get(SETID_BATTERY_CAPACITY_RSOC_USER);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 0]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 1]  = (uint8)((tempValue)     & 0xFF);

            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_CAPACITY_RSOC) )
            {
                tempValue = (uint16) *(uint8*)Setting_Get(SETID_BATTERY_CAPACITY_RSOC);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 2]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 3]  = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_HEALTH_SOH) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_HEALTH_SOH);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 4]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 5]  = (uint8)((tempValue)     & 0xFF);

            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_CYCLE) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_CYCLE);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 6]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 7]  = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_TEMP) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_TEMP);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 8]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 9]  = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_HW) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_HW);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 10]  = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 11]  = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_SW) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_SW);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 12] = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 13] = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_TOTAL_VOL) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_TOTAL_VOL);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 14] = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 15] = (uint8)((tempValue)     & 0xFF);
            
            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_CURRENT) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_CURRENT);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 16] = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 17] = (uint8)((tempValue)     & 0xFF);

            tempValue = 0;
            if( Setting_IsReady(SETID_BATTERY_SAFETY_STATUS) )
            {
                tempValue = *(uint16*)Setting_Get(SETID_BATTERY_SAFETY_STATUS);
            }
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 18] = (uint8)((tempValue>> 8) & 0xFF);
            glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA + 19] = (uint8)((tempValue)     & 0xFF);

            AseTkSrv_SendTunnel(glInputTunnelBuffer, 20 + 2);
            break;
        }
#endif
        case ASETK_TUNNEL_COMMAND_SETT_REQ:
        {
            eSettingId id = (eSettingId)glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA];
            uint8 size = glInputTunnelBuffer[ASETK_TUNNEL_MO_SIZE];

            //prepare reply data
            memset(glOutputTunnelBuffer, 0x00, ASETK_TUNNEL_BUFFER_SIZE);
            glOutputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_SETT_RESP;

            if(id>=SETID_MAX)
            {
                TP_PRINTF("\r\n\r\nERROR: AseTkSrv_AseFepTunnelHandler: sett_id(=%d) is out of range\r\n\r\n", id);
                glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = 0;
            }
            else if(!Setting_IsReady(id))
            {
                TP_PRINTF("\r\n\r\nWARNING: AseTkSrv_AseFepTunnelHandler: sett_id(=%d) is not ready\r\n\r\n", id);
                glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = 0;
            }
            else if (Setting_GetSize(id)!=size)
            {
                TP_PRINTF("\r\n\r\nWARNING: AseTkSrv_AseFepTunnelHandler: sett_id(=%d) should have size=%dbytes, but reuqired size=%d\r\n\r\n", id, Setting_GetSize(id), size);
                glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = 0;
            }
            else if (size+2 > ASETK_TUNNEL_BUFFER_SIZE)
            {
                TP_PRINTF("\r\n\r\nWARNING: AseTkSrv_AseFepTunnelHandler: sett_id(=%d) have large size(=%dbytes), buffer is not large enough\r\n\r\n", id, size);
                glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = 0;
            }
            else
            {
                uint8 *pSettVal= (uint8*)Setting_Get(id);
                glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = size;
                memcpy(&glOutputTunnelBuffer[ASETK_TUNNEL_MO_DATA],pSettVal,size);
                //printf("read-sett(id=%d,size=%d) => reply , ", id, size);
                //int i;
                //for(i=2 ; i<size+2 ; i++)
                //{
                //    printf("%02x ", glOutputTunnelBuffer[i]);
                //}
                //printf("\r\n");
            }
            AseTkSrv_SendTunnel(glOutputTunnelBuffer, size+2);
            
            break;
        }
#ifdef TP_MONITOR_OVER_TUNNEL
        case ASETK_TUNNEL_COMMAND_TP_MONITOR_START_REQ:
        {
            glEnabledTpMonitorEmul = TRUE;
            glInputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_TP_MONITOR_START_RESP;
            AseTkSrv_SendTunnel(glInputTunnelBuffer, glInputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] + 2);
            break;
        }

        case ASETK_TUNNEL_COMMAND_TP_MONITOR_REQ:
        {
            uint8 size = glInputTunnelBuffer[ASETK_TUNNEL_MO_SIZE];
            DebugSSrv_UartRxCallbackEmulator(&glInputTunnelBuffer[ASETK_TUNNEL_MO_DATA], size);
            break;
        }
#endif
        default:
            break;
    }
#endif /* #ifdef HAS_ASE_TK_SERVICE_TOOL */
}

#ifdef TP_MONITOR_OVER_TUNNEL
void AseTkSrv_FepAseTpMonitorEmulSend(uint8* data, uint16 size)
{
    if (TRUE == glEnabledTpMonitorEmul)
    {
        glOutputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_TP_MONITOR_RESP;
        glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] = size;

        memcpy(&glOutputTunnelBuffer[ASETK_TUNNEL_MO_DATA], data, (size <= ASETK_TUNNEL_BUFFER_SIZE) ? size : ASETK_TUNNEL_BUFFER_SIZE);

        glOutputTunnelBuffer[ASETK_TUNNEL_MO_MESSAGE_ID] = ASETK_TUNNEL_COMMAND_SETT_RESP;

        AseTkSrv_SendTunnel(glOutputTunnelBuffer, glOutputTunnelBuffer[ASETK_TUNNEL_MO_SIZE] + 2);
    }
}
#endif
void AseTkSrv_SendPowerStatus()
{
    const uint8 battery_level_unknown = 0;
    FepAseMessage msg;
    

    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAsePowerStatus_tag;

    msg.OneOf.fepAsePowerStatus.acLineStatus = FepAsePowerStatus_ACLineStatus_PLUGGED;
    msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_NO_BATTERY;
    msg.OneOf.fepAsePowerStatus.has_batteryLevel = false;
    msg.OneOf.fepAsePowerStatus.batteryLevel = battery_level_unknown;
    msg.OneOf.fepAsePowerStatus.healthStatus = FepAsePowerStatus_BatteryHealthStatus_UNKNOWN;

#ifdef HAS_BATTERY
    if (Setting_IsReady(SETID_IS_DC_PLUG_IN))
    {
        msg.OneOf.fepAsePowerStatus.acLineStatus = (FepAsePowerStatus_ACLineStatus)*(bool*)Setting_Get(SETID_IS_DC_PLUG_IN);
    }

    if (Setting_IsReady(SETID_BATTERY_CAPACITY_LEVEL))
    {
        BatteryStatus batteryLevel = (BatteryStatus)*(uint8*)Setting_Get(SETID_BATTERY_CAPACITY_LEVEL);
        switch(batteryLevel)
        {
        case BatteryStatus_NO_BATTERY:
            msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_NO_BATTERY;
            break;
        case BatteryStatus_LEVEL_CRITICAL:
            msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_LEVEL_CRITICAL;
            break;
        case BatteryStatus_LEVEL_LOW:
            msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_LEVEL_LOW;
            break;
        case BatteryStatus_LEVEL_MID:
            msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_LEVEL_MIDDLE;
            break;
        case BatteryStatus_LEVEL_EXTRA:
        case BatteryStatus_LEVEL_HIGH:
            msg.OneOf.fepAsePowerStatus.batteryStatus = FepAsePowerStatus_BatteryStatus_LEVEL_HIGH;
            break;
        default:
            ASSERT(0);
            break;
        }
    }
  
    if (Setting_IsReady(SETID_BATTERY_CAPACITY_RSOC_USER))
    {
        msg.OneOf.fepAsePowerStatus.has_batteryLevel = true;
        msg.OneOf.fepAsePowerStatus.batteryLevel = *(uint8*)Setting_Get(SETID_BATTERY_CAPACITY_RSOC_USER);
    }

    if (Setting_IsReady(SETID_BATTERY_HEALTH_LEVEL))
    {
        uint8 batteryHealthLevel = *(uint8*)Setting_Get(SETID_BATTERY_HEALTH_LEVEL);
        switch(batteryHealthLevel)
        {
        case BATT_HEALTH_CRITICAL: //power off system
        case BATT_HEALTH_POOR: //suggest service center to replace battery
            msg.OneOf.fepAsePowerStatus.healthStatus = FepAsePowerStatus_BatteryHealthStatus_POOR;
            break;
        case BATT_HEALTH_GOOD:
            msg.OneOf.fepAsePowerStatus.healthStatus = FepAsePowerStatus_BatteryHealthStatus_GOOD;
            break;
        case BATT_HEALTH_UNKNOWN:
        default:
            break;
        }
    }
#endif

    if( !Setting_IsReady(SETID_ASETK_CONNECTED) || !(*(bool*)Setting_Get(SETID_ASETK_CONNECTED)) )
        TP_PRINTF("AseTkSrv_SendPowerStatus: ignore because ASE-TK is not ready\r\n");
    else    
        TP_PRINTF("AseTkSrv_SendPowerStatus: DC=%d, batt-cap=%d%%, batt-level=%d, batt-health=%d\r\n", 
                    msg.OneOf.fepAsePowerStatus.acLineStatus, msg.OneOf.fepAsePowerStatus.batteryLevel, msg.OneOf.fepAsePowerStatus.batteryStatus, msg.OneOf.fepAsePowerStatus.healthStatus);
    
    AseTkSrv_SendMessage(&msg);
}

static void AseTkSrv_AseFepEventHandler(cAseTkSrv * const me, AseFepEvent aseFepEvent)
{
#ifdef ASE_TK_DEBUG_SHOW_RX_DATA
    TP_PRINTF("    AseFepEvent: %d %d\r\n", aseFepEvent.has_event, aseFepEvent.event);
#endif
    switch (aseFepEvent.event)
    {
    case AseFepEvent_Event_SW_UPDATE_STARTED:
        AseTkSrv_DisableComWdg(me);
        break;
    case AseFepEvent_Event_SW_UPDATE_FINISHED:
        AseTkSrv_EnableComWdg(me);
        break;
    case AseFepEvent_Event_SW_UPDATE_FAILED:
        AseTkSrv_EnableComWdg(me);
        break;
    case AseFepEvent_Event_BT_PAIRING_ENABLED:
        break;
    case AseFepEvent_Event_BT_PAIRING_DISABLED:
        break;
    case AseFepEvent_Event_BT_PAIRING_FAILED:
        break;
    case AseFepEvent_Event_BT_PAIRING_SUCCEEDED:
        break;
    case AseFepEvent_Event_BTLE_PAIRING_ENABLED:
        break;
    case AseFepEvent_Event_BTLE_PAIRING_DISABLED:
        break;
    case AseFepEvent_Event_BTLE_PAIRING_FAILED:
        break;
    case AseFepEvent_Event_BTLE_PAIRING_SUCCEEDED:
        break;
    case AseFepEvent_Event_PLAYER_PLAYING:
        break;
    case AseFepEvent_Event_PLAYER_PAUSED:
        break;
    case AseFepEvent_Event_PLAYER_STOPPED:
        break;
    case AseFepEvent_Event_PLAYER_MUTED:
        break;
    case AseFepEvent_Event_PLAYER_UNMUTED:
        break;
    case AseFepEvent_Event_SOFTAP_STARTED:
        break;
    case AseFepEvent_Event_SOFTAP_STOPPED:
        break;
    case AseFepEvent_Event_APPLE_WAC_STARTED:
        break;
    case AseFepEvent_Event_APPLE_WAC_STOPPED:
        break;
    case AseFepEvent_Event_APPLE_WAC_TIMEOUT:
        break;
    case AseFepEvent_Event_ASE_BOOTED:
        AseTkSrv_EnableComWdg(me);
        
        //ASE-TK Init operation
        AseTkSrv_QueryInternalSpeakerCompensation();               
        AseTkSrv_SendPowerStatus();
        break;
    case AseFepEvent_Event_ASE_OVERHEAT_ALERT:
        break;
    case AseFepEvent_Event_SW_UPDATE_FEP_BOOTLOADER:
        TP_PRINTF("\r\n*** AseTkSrv_AseFepEventHandler: jump to bootaloder (AseFepEvent_Event_SW_UPDATE_FEP_BOOTLOADER) ***\r\n\r\n");
#ifdef ASE_TK_OTA        
        AseTkSrv_updateStblStatus(me, FEP_STBL_UPGRADE_UBL);
        
        /* Kick dog before jump, to ensure firmware upgrade have enough time */
#ifdef HAS_IWDG
        IWDG_ReloadCounter();
#endif
        /* ASETK-298 
         * Delay here to ensure FEP have enough time to reply ACK before jump */
        BSP_BlockingDelayMs(200);

        bl_jumpAddr(FEP_ADDR_UBL);
#endif        
        break;
    case AseFepEvent_Event_SW_UPDATE_FEP_APPLICATION:
        TP_PRINTF("\r\n*** AseTkSrv_AseFepEventHandler: jump to bootaloder (AseFepEvent_Event_SW_UPDATE_FEP_APPLICATION) ***\r\n\r\n");
#ifdef ASE_TK_OTA        
        AseTkSrv_updateStblStatus(me, FEP_STBL_UPGRADE_FIRMWARE);
        
        /* Kick dog before jump, to ensure firmware upgrade have enough time */
#ifdef HAS_IWDG
        IWDG_ReloadCounter();
#endif

        /* ASETK-298 
         * Delay here to ensure FEP have enough time to reply ACK before jump */
        BSP_BlockingDelayMs(200);

        bl_jumpAddr(FEP_ADDR_UBL);
#endif        
        break;
    case AseFepEvent_Event_SYSTEM_STATUS_STORAGE:
        break;
    case AseFepEvent_Event_SYSTEM_STATUS_STANDBY:
        break;
    case AseFepEvent_Event_SYSTEM_STATUS_ON:
        break;
    case AseFepEvent_Event_SYSTEM_STATUS_OFF:
        break;
    case AseFepEvent_Event_FACTORY_RESET_START:
        AseTkSrv_DisableComWdg(me);
        break;
    case AseFepEvent_Event_FACTORY_RESET_DONE:
        AseTkSrv_EnableComWdg(me);
        break;
    case AseFepEvent_Event_SYSTEM_STATUS_ASE_RESTART:
    {
        AseTkSrv_DisableComWdg(me);
        break;
    }
    case AseFepEvent_Event_SYSTEM_STATUS_RESTART:
    {
        AseTkSrv_DisableComWdg(me);
        break;
    }
    default:
        break;
    }

}

static void AseTkSrv_HandleAseCommand(cAseTkSrv * const me, AseFepMessage message)
{
#ifdef ASE_TK_DEBUG_SHOW_RX_DATA
    TP_PRINTF("    ASE:%d 0x%X ", message.which_OneOf, message.OneOf.aseFepNetworkInfo.networkInfo.arg);
#endif

    switch (message.which_OneOf)
    {
    case AseFepMessage_aseFepEvent_tag:
        AseTkSrv_AseFepEventHandler(me, message.OneOf.aseFepEvent);
        break;
    case AseFepMessage_aseFepVolumeChangedEvent_tag:
    {
#ifdef ASE_TK_DEBUG_SHOW_RX_DATA
        //TP_PRINTF("    Set Volume: %d\r\n", message.OneOf.aseFepVolumeChangedEvent.volume);
        TP_PRINTF("\r\n");
#endif
        break;
    }

    case AseFepMessage_aseFepVolumeFadeEvent_tag:
        break;
    case AseFepMessage_aseFepSetLineInSensitivity_tag:
        break;
    case AseFepMessage_aseFepTunnel_tag:
        //TP_PRINTF("\r\n ASE-TK Tunnel IN:[%s]\r\n",glInputTunnelBuffer);
        AseTkSrv_AseFepTunnelHandler(me);
        break;
    case AseFepMessage_aseFepSetAudioInputReq_tag:
        break;
    case AseFepMessage_aseFepSetAudioOutputReq_tag:
        break;
    case AseFepMessage_aseFepAliveResp_tag:
        if(me->aliveReqInProg > 0)
        {
            AseTkSrv_EnableComWdg(me);
        }
        break;
    case AseFepMessage_aseFepSetPositionSoundModeReq_tag:
        break;
    case AseFepMessage_aseFepGetPositionSoundModeReq_tag:
        break;
    case AseFepMessage_aseFepNetworkInfo_tag:
        break;
    case AseFepMessage_aseFepReq_tag:
    {
#ifdef ASE_TK_DEBUG_SHOW_RX_DATA
        TP_PRINTF("    aseFepReq: %04X\r\n", message.OneOf.aseFepReq.request);
#endif
        switch (message.OneOf.aseFepReq.request)
        {
        case AseFepReq_Request_PRODUCT_INFO:
            TP_PRINTF("    AseFepReq_Request_PRODUCT_INFO (not support)\r\n");
            break;
        case AseFepReq_Request_POWER_STATUS:
            AseTkSrv_SendPowerStatus();
            break;
        case AseFepReq_Request_VERSION_INFO:
            AseTkSrv_SendVersion();
            break;
        case AseFepReq_Request_STATISTICS:
            TP_PRINTF("    AseFepReq_Request_STATISTICS (not support)\r\n");
            break;
        case AseFepReq_Request_NETWORK_INFO:
            TP_PRINTF("    AseFepReq_Request_NETWORK_INFO (not support)\r\n");
            break;
        case AseFepReq_Request_INTERNAL_SPEAKER_COMPENSATION:
            TP_PRINTF("    AseFepReq_Request_INTERNAL_SPEAKER_COMPENSATION\r\n");
            AseTkSrv_SendInternalSpeakerCompensation();
            break;
        }
    }
    break;
        
    case AseFepMessage_aseFepSetAudioPcmFormatCommand_tag:
        break;
        
    case AseFepMessage_aseFepSetInternalSpeakerCompensationCommand_tag:
        break;

    case AseFepMessage_aseFepDspParameterCmd_tag:
        break;        

    default:
        break;
    }

    /* publish ASE cmd */
    AseTkStateIndEvt* pAseTkStateEvt = Q_NEW(AseTkStateIndEvt, ASE_TK_STATE_SIG);
    pAseTkStateEvt->aseFepCmd = message;
    QF_PUBLISH(&pAseTkStateEvt->super, me);

}

/***************************************************/
/************send/receive func with ASE_TK*************/
/**************************************************/
/* time out handler function, re-send the package */
static void AseTkSrv_TimeOutHandler(uint8* data, uint8 size)
{
    TP_PRINTF("time out and re_send\r\n");
    FepAseMessage* pMessage = (FepAseMessage*)data;
    AseTkSrv_SendMessage(pMessage);
}


/* send the message to ase module by uart */
static void AseTkSrv_SendMessage(FepAseMessage* pMessage)
{
    if( !Setting_IsReady(SETID_ASETK_CONNECTED) || !(*(bool*)Setting_Get(SETID_ASETK_CONNECTED)) ) 
    {
        return;
    }

    //Sometime Uart is xtor but SETID_ASETK_CONNECTED=TRUE, here is workaround to avoid problem
    ASSERT(aseTk_uart.pConfig);
    if( !aseTk_uart.pConfig ) 
    {
        return;
    }
    
    static int seq = 0;
    static uint8_t buffer[ASETK_SRV_DECODE_BUFFER_SIZE];
    memset(buffer, 0, sizeof(buffer));
    size_t message_length = message_to_data(pMessage, (char*)buffer, sizeof(buffer));
    /* if data encode successfully */
    if(message_length>0)
    {
        /* Do not print ProductLog message, becuase it have too many events */
        if( pMessage->which_OneOf != (pb_size_t)FepAseMessage_fepAseProductLog_tag ) {
            TP_PRINTF("AseTkSrv_SendMessage: which_OneOf=%d\r\n", pMessage->which_OneOf);
        }
        
        static uint8 dest_buff[ASETK_SRV_DECODE_BUFFER_SIZE];
        uint32 size = 0;
        yahdlc_control_t control;
        /* framing the data streaming */
        control.frame = YAHDLC_FRAME_DATA;
        control.seq_no = seq;
        seq = yahdlc_seq_advance(seq);
        yahdlc_frame_data(&control, (char*)buffer, message_length, (char*)dest_buff, (unsigned int*)&size);
        UartDrv_Write(&aseTk_uart, (uint8* )dest_buff, size);
    }
}

static inline void AseTkSrv_ACK(uint8 seq_no)
{
    yahdlc_control_t control;
    uint32 size = 0;
    uint8 dest_buff[ASETK_SRV_DECODE_BUFFER_SIZE];
    uint8* fake_src = dest_buff;    // fake src pointer as yahdlc does not accept src to be null

    control.frame = YAHDLC_FRAME_ACK;
    if (seq_no >= YAHDLC_SEQ_NO_MAX)
    {
        control.seq_no = 0;
    }
    else
    {
        control.seq_no= seq_no + 1;
    }
    yahdlc_frame_data(&control, (char*)fake_src, 1, (char*)dest_buff, (unsigned int*)&size);
    UartDrv_Write(&aseTk_uart, (uint8* )dest_buff, size);
}

static inline void AseTkSrv_NACK(uint8 seq_no)
{
    yahdlc_control_t control;
    uint32 size = 0;
    uint8 dest_buff[ASETK_SRV_DECODE_BUFFER_SIZE];
    uint8* fake_src = dest_buff;    // fake src pointer as yahdlc does not accept src to be null

    control.frame = YAHDLC_FRAME_NACK;
    control.seq_no= seq_no;
    yahdlc_frame_data(&control, (char*)fake_src, 1, (char*)dest_buff, (unsigned int*)&size);
    UartDrv_Write(&aseTk_uart, (uint8* )dest_buff, size);
}

/* Call back function receiving message from ase module */
/* After decode the commands, this function will send the message to AseTkSrv to handle the command */
static void AseTkSrv_OnReceive(void* p)
{
    static bool critical_section= FALSE;
    static uint8 buff[ASETK_SRV_DECODE_BUFFER_SIZE];
    static uint32 write_len = 0;
    static yahdlc_control_t control;
    tUartRxData *uartData = (tUartRxData *)p;
    
    if( critical_section )
    {
        printf("\r\n\r\r\n*** AseTkSrv_OnReceive: re-enter error ***\r\n\r\n\r\n\n");
        ASSERT(0);
        return;
    }
    critical_section= TRUE;
      

    // ToDo: discard un-used data, i.e. data without enclosure of DLC start/end flag sequence @ uartRxBuf
    // ToDo: house-keeping for uartRxBuf, an approach is set a timer here, after timeout, clear the buffer

    int ret = yahdlc_get_data(&control, (char*)&uartData->data, sizeof(uint8), (char*)buff, (unsigned int*)&write_len);
    if(ret >= 0)
    {
#ifdef ASE_TK_DEBUG_SHOW_RX_DATA
        //Because we send log ASE-TK, if print control:, there is too many message
        //TP_PRINTF("\r\ncontrol: %d %d ", control.frame, control.seq_no);
#endif
        /* do not handle the command here as it's still in interrupt call back function, send a signal instead */
        if(data_to_message(&rMessage, (char*)buff, write_len)
            && (control.frame == YAHDLC_FRAME_DATA))
        {
            FepCmdEvt* evt = Q_NEW(FepCmdEvt, ASETK_RECEIVE_COMMAND);
            memcpy(&evt->aseFepCmd, &rMessage, sizeof(AseFepMessage));
            SendToServer(ASETK_SRV_ID,(QEvt*)evt);
            AseTkSrv_ACK(control.seq_no);
        }
        RingBuf_Reset(&rxBuf);
    }
    else if (ret == -EIO)
    {
        AseTkSrv_NACK(control.seq_no);
        /* throw the package if the CRC is not correct */
        RingBuf_Reset(&rxBuf);
    }
    else if (ret == -ENOMSG)
    {
    }
    else
    {
        ASSERT(0);
    }
    
    
    critical_section= FALSE;
}

static void AseTkSrv_EnableComWdg(cAseTkSrv * const me)
{
    /* Setup communication Watchdog timer */
    if( me->comWdgTimer==INVALID_VALUE) {
        TP_PRINTF("\r\n AseTk Server communication watchdog is enabled. \r\n");
    }
    me->comWdgTimer = ASETK_SRV_COM_WDG_TIME_MS;
    me->aliveReqInProg = 0;
}

static void AseTkSrv_DisableComWdg(cAseTkSrv * const me)
{
    /* Setup communication Watchdog timer */
    TP_PRINTF("\r\n AseTk Server communication watchdog is disabled. \r\n");
    me->comWdgTimer = INVALID_VALUE;
    me->aliveReqInProg = INVALID_VALUE;
}

static void AseTkSrv_FeedComWdg(cAseTkSrv * const me)
{
    if(me->aliveReqInProg == 0)
    {
        /* Restart Communication Watchdog Timer*/
        me->comWdgTimer = ASETK_SRV_COM_WDG_TIME_MS;
    }
}

static void AseTkSrv_CheckComWdgTimer(cAseTkSrv * const me)
{
    if(me->comWdgTimer > 0)
    {
        me->comWdgTimer -= ASETK_SRV_PER_TICK_TIME_MS;
        if(me->comWdgTimer <= 0)
        {/* communication watchdog timeis timeout */
            if(me->aliveReqInProg < ASETK_SRV_MAX_ALIVE_REQ)
            {
                me->comWdgTimer = ASETK_SRV_COM_WDG_TIME_MS;
                AseTkSrv_SendAliveReq();
                me->aliveReqInProg++;
            }
            else
            {
                /* If fail to get respondse from ASE-TK after 3 attempts,then publish ASE-TK
                  * communication watchdog timeout event. */
                TP_PRINTF("\r\n AseTk Server communication watchdog timeout!!\r\n");
                AseTkStateIndEvt* pAseTkStateEvt = Q_NEW(AseTkStateIndEvt, ASE_TK_STATE_SIG);
                pAseTkStateEvt->bIsComWdgTimeOut = TRUE;
                QF_PUBLISH(&pAseTkStateEvt->super, me);
            }
        }
    }
}

static void AseTkSrv_SendAliveReq(void)
{
    FepAseMessage msg;
    msg.which_OneOf = (pb_size_t)FepAseMessage_fepAseAliveReq_tag;
    msg.OneOf.fepAseAliveReq.dummy_field = NULL;
    AseTkSrv_SendMessage(&msg);
}

/***************************************************/
/********Protocol buffer Encode Decode func *************/
/**************************************************/
const pb_field_t* decode_unionmessage_type(pb_istream_t *stream)
{
    pb_wire_type_t wire_type;
    uint32_t tag;
    bool eof;
    while (pb_decode_tag(stream, &wire_type, &tag, &eof))
    {
        if (wire_type == PB_WT_STRING)
        {
            const pb_field_t *field;
            for (field = AseFepMessage_fields; field->tag != 0; field++)
            {
                if (field->tag == tag && (field->type & PB_LTYPE_SUBMESSAGE))
                {
                    /* Found our field. */
                    return field->ptr;
                }
            }
        }

        /* Wasn't our field.. */
        pb_skip_field(stream, wire_type);
    }

    return NULL;
}

bool decode_unionmessage_contents(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
{
    pb_istream_t substream;
    bool status;
    if (!pb_make_string_substream(stream, &substream))
    {
        return false;
    }
    status = pb_decode(&substream, fields, dest_struct);
    pb_close_string_substream(stream, &substream);
    return status;
}

static bool data_to_message(AseFepMessage* p_message, char* buff, uint32 size)
{
    bool status = false;

    /* Create a stream that reads from the buffer. */
    pb_istream_t stream = pb_istream_from_buffer((uint8*)buff, size);

    const pb_field_t *type = decode_unionmessage_type(&stream);

    if(AseFepTunnel_fields == type)
    {
        memset(p_message, 0x00, sizeof(AseFepMessage));

        p_message->which_OneOf = AseFepMessage_aseFepTunnel_tag;
        p_message->OneOf.aseFepTunnel.data.funcs.decode = &AseTkSrv_TunnelInputCb;
        status = decode_unionmessage_contents(&stream, AseFepTunnel_fields, &(p_message->OneOf.aseFepTunnel));
    }
    else if(AseFepSetInternalSpeakerCompensationCommand_fields == type)
    {
        memset(p_message, 0x00, sizeof(AseFepMessage));

        p_message->which_OneOf = AseFepMessage_aseFepSetInternalSpeakerCompensationCommand_tag;
        p_message->OneOf.aseFepSetInternalSpeakerCompensationCommand.internalSpeaker.funcs.decode = &AseTkSrv_SetInternalSpeakerCompensationCb;
        status = decode_unionmessage_contents(&stream, AseFepSetInternalSpeakerCompensationCommand_fields, &(p_message->OneOf.aseFepSetInternalSpeakerCompensationCommand));    
    }
    else if(AseFepNetworkInfo_fields == type)
    {
        memset(p_message, 0x00, sizeof(AseFepMessage));
        p_message->which_OneOf = AseFepMessage_aseFepNetworkInfo_tag;
        p_message->OneOf.aseFepNetworkInfo.networkInfo.funcs.decode = &AseTkSrv_NetworkInfoInputCb;
        status = decode_unionmessage_contents(&stream, AseFepNetworkInfo_fields, &(p_message->OneOf.aseFepNetworkInfo));
    }
    else if(AseFepDspParameterCmd_fields == type)
    {
        memset(p_message, 0x00, sizeof(AseFepMessage));
        p_message->which_OneOf = AseFepMessage_aseFepDspParameterCmd_tag;
        p_message->OneOf.aseFepDspParameterCmd.parameter.funcs.decode = &AseTkSrv_DspParameterCmdCb;
        status = decode_unionmessage_contents(&stream, AseFepDspParameterCmd_fields, &(p_message->OneOf.aseFepDspParameterCmd));
    }    
    else
    {
        /* Create a stream that reads from the buffer. */
        pb_istream_t stream = pb_istream_from_buffer((uint8*)buff, size);

        /* Now we are ready to decode the message. */
        status = pb_decode(&stream, AseFepMessage_fields, p_message);
    }

    /* Check for errors... */
    if (!status)
    {
        TP_PRINTF("Protocol_buffer: Can not analyze the protocol buffer\r\n");
        return FALSE;
    }
    return TRUE;
}


static uint32 message_to_data(FepAseMessage* p_message, char* buff, uint32 size_of_buff)
{
    /* On FS1 v4.0.6, when send ASETK version, this function need
     *  472 (0x1D8) bytes on call stack
     */
    /* Create a stream that will write to our buffer. */
    pb_ostream_t stream = pb_ostream_from_buffer((uint8*)buff, size_of_buff);

    bool status = pb_encode(&stream, FepAseMessage_fields, p_message);

    uint32 message_length = stream.bytes_written;

    /* Then just check for any errors.. */
    if (!status)
    {
        TP_PRINTF("Protocol_buffer: Encoding failed\r\n");
        return 0;
    }
    return message_length;
}

static int yahdlc_seq_advance(int seq)
{
    const int yahdlc_seq_max = 7;   // yahdlc_control_t.seq_no with length of 3 bits

    if (yahdlc_seq_max <= seq)
    {
        seq = 0;
    }
    else
    {
        ++seq;
    }

    return seq;
}

/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Server
                  -------------------------

                  SW Module Document




@file        AudioSrv
@brief       Audio Control Server
@author      Wesley Lee
@date        2014-02-17
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-02-17     Wesley Lee
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :

Change History:
VERSION    : 2    DRAFT      2014-09-10     Johnny Fan
DESCRIPTION: Refactor audio sever, to add BT tone support
SCO/ERROR  :

Change History:
VERSION    : 3    Revision      2014-Sept-30     Christopher Alexander
DESCRIPTION: Refactor audio sever and add the update signal
SCO/ERROR  : n/a

-------------------------------------------------------------------------------
*/
#include "product.config"
#include "AudioSrv_priv.h"
#include "bsp.h"    // for BSP_TICKS_PER_SEC
#include "controller.h"
#include "DspDrv.h"
#include "AudioDrv.h"
#ifdef USE_DEBUG_SETTING_SERVER // USE_DEBUG_SETTING_SERVER is defined in IAR preprocesser
#include "DebugSettSrv.h"
#else
#include "SettingSrv.h"
#endif
#include "trace.h"
#ifdef AUDIOSRV_DEBUG
#include "tym_qp_lib.h"
#endif
#include "BluetoothDrv.h"
#include "AudioSrv.Config"
#ifdef HAS_AMPLIFY_MUTE
#include "AudioDrv.h"
#endif

#include "I2CDrv.h"
#ifdef HAS_AUDIO_ADC
#include "AudioAdcDrv.h"
#endif
#ifdef HAS_AUDIO_SRC // SRC: sample rate converter
#include "AudioSRCDrv.h"
#endif
/*****************************************************************************
 * Definition
 *****************************************************************************/
#ifdef AUDIOSRV_DEBUG
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...) TymQP_DumpQueue_WithLog((QActive *)(me), __func__, __VA_ARGS__)
    #define AUDIOSRV_DEBUG_MSG TP_PRINTF
#else
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...)
    #define AUDIOSRV_DEBUG_MSG(...)
    #undef   TP_PRINTF
    #define  TP_PRINTF(...)
#endif

//Q_DEFINE_THIS_FILE

#define CAST_ME cAudioSrv * audioSrv = (cAudioSrv *) me;


/* internal signals */
enum InternalSignals
{
    TIMEOUT_SIG = MAX_SIG,

};
/*****************************************************************
 * Global Variable
 *****************************************************************/
/* Private functions / variables. Declare and drivers here */
static bool AudioSrv_DSPInitAndTick(cAudioSrv * const me);
/* Internal event queue - Size as needed */
static QEvt const *AudioEvtBuf[AUDIO_SRV_EVENT_Q_SIZE];
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[3];

static QActive* pRequestor;

#ifdef MUTIPLE_SOURCE_MUSIC_DETECTION
    #ifdef AUDIO_MULTI_SOURCE
        static uint8 muteDelayCounter[ArraySize(AudioMusicDetect)];
        static BOOL isChangingChannel = FALSE;
    #endif
#else
    #ifdef AUDIO_MULTI_SOURCE
        static uint8 muteDelayCounter;
        static BOOL isChangingChannel = FALSE;
    #endif
#endif



#define MUTE_DELAY_TIME  10 /*5sec delay*/

// TODO: move to Audio Driver
cDSPDrv dspDrv;

extern cI2CDrv dspI2c; // Share the same i2c driver with other audio chipsets, like audio ADC chip, audio SRC chip.
#ifdef HAS_AUDIO_ADC
cAudioAdcDrv audioAdcDrv;
#endif
#ifdef HAS_AUDIO_SRC // SRC: sample rate converter
cAudioSRCDrv audioSRCDrv;
#endif
// end of TODO: move to audio driver

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioSrv_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(audioSrv);
    QS_OBJ_DICTIONARY(AudioSrv_DeActive);
    QS_OBJ_DICTIONARY(AudioSrv_PreActive);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&AudioSrv_Initial), TIMEOUT_SIG,
                                AudioEvtBuf, Q_DIM(AudioEvtBuf),AUDIO_SRV_ID);
    
    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
    /* Subscribe */
#ifdef AUDIO_DSP_AUTO_UPDATE
     QActive_subscribe((QActive*)me, SETTING_UPDATE_SIG);
#endif
}

void AudioSrv_ShutDown(cPersistantObj *me)
{
    /* Destruct DSP driver */
    DSPDrv_Xtor(&dspDrv);
    /* Clean memory and shut-down.*/
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
QState AudioSrv_Initial(cAudioSrv * const me)
{
#if defined(HAS_AMPLIFY_MUTE)||defined(HAS_SPDIF_SIGNAL_SENSE)||defined(HAS_ANALOG_SIGNAL_SENSE)
    AudioDrv_Ctor();
#endif
#ifdef AUDIO_I2S_CLK_CTRL
    AudioDrv_EnI2sClk(FALSE);
#endif
#ifdef HAS_GPIO_JACK_IN_DETECT
    bool defaultSetting = FALSE;
#ifdef REMEMBER_AUXIN_STATUS
    if((!Setting_IsReady(SETID_IS_AUXIN_PLUG_IN)) ||
        (JACK_IN_INVALID == *(uint8 *)Setting_Get(SETID_IS_AUXIN_PLUG_IN)))
    {/*if AUXIN jack status is not set, set it for the first time*/
        Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultSetting);
    }
#else
    Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultSetting);
#endif
    Setting_Set(SETID_MUSIC_DET, &defaultSetting);
#endif

#ifdef AUDIO_ADC_BEFORE_DSP
    audioAdcDrv.pI2CConfig = (tI2CDevice *) getDevicebyId(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
    audioAdcDrv.pAudioAdcI2c = &dspI2c; // audio adc share the same I2C driver object with dsp.
    audioAdcDrv.deviceI2cAddr = AUDIO_ADC_I2C_ADDR;
    AudioAdcDrv_Ctor(&audioAdcDrv);
#endif

    return Q_TRAN(&AudioSrv_DeActive);
}

QState AudioSrv_DeActive(cAudioSrv * const me, QEvt const * const e)
{
    static bool bInitDSP=0;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TP_PRINTF("Enter %s\r\n", __FUNCTION__);
            me->JackScanTimer=AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME*4;
            me->musicDetectTimer=AUDIO_ACTIVE_MUSIC_DETECT_TIME*4;
            //QTimeEvt_disarm(TIME_EVT_OF(me));
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
#ifdef HAS_GPIO_JACK_IN_DETECT
            me->audioJackIn = &AudioJackIn[0];
#endif
#ifdef MUTIPLE_SOURCE_MUSIC_DETECTION
            me->audioMusicDet = &AudioMusicDetect[0];
            Setting_Set(SETID_MUSIC_DET, &me->audioMusicDet);
#endif
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
#ifdef AUDIO_I2S_CLK_CTRL
            AudioDrv_EnI2sClk(TRUE);
#endif
            pRequestor=((CommonReqEvt*)e)->sender;
            DSPDrv_Ctor(&dspDrv);
            AudioSrv_DSPInitAndTick(me);
            bInitDSP = 1;
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
#if (defined MUSIC_DETECTION_WHEN_STANDBY) || (defined JACK_DETECTION_WHEN_STANDBY)
            AudioSrv_DeactivePeriodicTask(me, AUDIO_SRV_TIMEOUT_IN_MS);
#endif
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            if (bInitDSP)
            {
                if(TRUE == AudioSrv_DSPInitAndTick(me))
                {
                    bInitDSP=0;
                    bool hasMusicStream = DSPDrv_HasMusicStream(&dspDrv);
                    Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
#ifdef AUDIO_ADC_AFTER_DSP
                    audioAdcDrv.pI2CConfig = (tI2CDevice *) getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
                    audioAdcDrv.pAudioAdcI2c = &dspI2c; // audio adc share the same I2C driver object with dsp.
                    audioAdcDrv.deviceI2cAddr = AUDIO_ADC_I2C_ADDR;
                    AudioAdcDrv_Ctor(&audioAdcDrv);
#endif
#ifdef HAS_AUDIO_SRC // SRC: sample rate converter
                    audioSRCDrv.pI2CConfig = (tI2CDevice *) getDevicebyIdAndType(DSP_DEV_ID, I2C_DEV_TYPE, NULL);
                    audioSRCDrv.pAudioSRCI2c = &dspI2c; // audio adc share the same I2C driver object with dsp.
                    audioSRCDrv.deviceI2cAddr = AUDIO_SRC_I2C_ADDR;
                    AudioSRCDrv_Ctor(&audioSRCDrv);
#endif
                    CommonEvtResp((QActive*)me, pRequestor,RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
                    return Q_TRAN(&AudioSrv_AudioMainHandler);
                }
            }
            return Q_HANDLED();
            
        }
        /*
         * Sometimes system have wrong sequence (ex. send continuous two SYSTEM_SLEEP_REQ_SIG to AudioSrv),
         * and cause potential issues. The ASSERT here could protect these problems.
         */
        case SYSTEM_SLEEP_REQ_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)SYSTEM_SLEEP_REQ_SIG", e->sig);
            ASSERT(0);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*\brief Super state
 * The super state of AudioSrv_SwitchChannel,AudioSrv_MainHandler,AudioSrv_PlayToneStat,AudioSrv_Mute
 */
QState AudioSrv_Active(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
        {
            TP_PRINTF("Enter %s\r\n", __FUNCTION__);
            return Q_HANDLED();
        }
    /* Sometimes system have wrong sequence (ex. send continuous two SYSTEM_ACTIVE_REQ_SIG to AudioSrv),
         * and cause potential issues. The ASSERT here could protect these problems. */
    case SYSTEM_ACTIVE_REQ_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)SYSTEM_ACTIVE_REQ_SIG", e->sig);
            ASSERT(0);
            return Q_HANDLED();
        }

    case SYSTEM_SLEEP_REQ_SIG:
        {
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(TRUE);
#endif
#ifdef HAS_AMPLIFY_RESET
            AudioDrv_ResetAmp(TRUE);
#endif
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
            DSPDrv_Xtor(&dspDrv);
            return Q_TRAN(AudioSrv_DeActive);
        }
    case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
    default:
          break;
    }
    return Q_SUPER(&QHsm_top);
}

/** \brief sub state to handle most of the audio events
 * Most actions occur here
 *
*/
QState AudioSrv_AudioMainHandler(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
        {
            TP_PRINTF("Enter %s\r\n", __FUNCTION__);
            me->JackScanTimer=AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
            me->musicDetectTimer=AUDIO_ACTIVE_MUSIC_DETECT_TIME;
#ifdef HAS_GPIO_JACK_IN_DETECT
            me->audioJackIn = &AudioJackIn[0];
#endif
#ifdef MUTIPLE_SOURCE_MUSIC_DETECTION
            me->audioMusicDet = &AudioMusicDetect[0];
#endif

#ifdef HAS_BT_TONE
            me->reqTone.isExcuting = FALSE;
#endif
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
    case TIMEOUT_SIG:
        {
            AudioSrv_PeriodicTask(me, AUDIO_SRV_TIMEOUT_IN_MS);//periodically check auxin and music stream
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);//trigger timer event every 10ms
            return Q_HANDLED();
        }
    case AUDIO_SET_SIG:
        {
            AudioSettEvt *pDspSett = (AudioSettEvt*)e;
            DSPDrv_SetAudio(&dspDrv, pDspSett->dspSettId, pDspSett->enable);
            return Q_HANDLED();
        }
#ifdef AUDIO_MULTI_SOURCE
    case AUDIO_SWITCH_CHANNEL_SIG:        // Analog input
        {
            AudioChannelSwitchReqEvt* ChannelSwitchReqEvt = (AudioChannelSwitchReqEvt*) e;
            /*store the requestor for response */
            pRequestor = ChannelSwitchReqEvt->sender;
            if (isChangingChannel)
            {
                AudioSrv_RespSwitchChannelReq(me->channel, RET_BUSY);
                return Q_HANDLED();
            }
            if (ChannelSwitchReqEvt->channel == me->channel)
            {
                AudioSrv_RespSwitchChannelReq(me->channel, RET_SUCCESS);
                return Q_HANDLED();
            }
            else
            {
#ifdef HAS_BT_TONE
                if(ChannelSwitchReqEvt->channel == BT_TONE_CHANNEL)
                {
                    /* switch to play BT tone */
                    AudioSrv_InitialTone(me, ChannelSwitchReqEvt);
                    return Q_TRAN(&AudioSrv_PlayToneState);
                }
                else
                { /* normal switching channel */
                    me->channel = ChannelSwitchReqEvt->channel;
                }
#else
                me->channel = ChannelSwitchReqEvt->channel;
#endif
                /* Mute the sytem before change the channel */
#ifdef HAS_AMPLIFY_MUTE
                AudioDrv_Mute(TRUE);
#endif
                /* The channel will be changed afte this time gap */
                me->changeChannelTimer = AUDIO_SWITCH_CHANNEL_DELAY_TIME;
                isChangingChannel = TRUE;
            }
            return Q_HANDLED();
        }
#endif // AUDIO_MULTI_SOURCE
    case AUDIO_MUTE_SIG:
        {
            AudioMuteReqEvt* MuteReqEvt = (AudioMuteReqEvt*)e;
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(MuteReqEvt->mute);
#endif
            if(MuteReqEvt->mute)
            {
                DSPDrv_MuteDACOut(&dspDrv);
            }
            else
            {
                DSPDrv_UnMuteDACOut(&dspDrv);
            }
            CommonEvtResp((QActive*)me, MuteReqEvt->sender ,RET_SUCCESS, AUDIO_MUTE_RESP_SIG);
            return Q_HANDLED();
        }
#ifdef AUDIO_DSP_AUTO_UPDATE
    case SETTING_UPDATE_SIG:
        {
            SettingUpdateEvt* pEvt = (SettingUpdateEvt*)e;
            if ((SETID_DSP_INIT_DATA == pEvt->setting_id) || (SETID_DSP_TUNABLE_PART == pEvt->setting_id))
            {
              return Q_TRAN(&AudioSrv_DSPInit);
            }
            else
            {
              return Q_HANDLED();
            }
        }
#endif
#ifdef GAIN_ADJUSTMENT_FOR_DIFF_BATTLEVEL
    case AUDIO_SET_POWER_LEVEL_GAIN_SIG:
    {
        AudioSetPowerLevelGainEvt* pEvt = (AudioSetPowerLevelGainEvt*)e;
        if (pEvt->powerLevelGain < AUDIO_INVALID_BATTERY_GAIN_LEVEL)
        {
            DSPDrv_SetGain(&dspDrv, pEvt->powerLevelGain);
        }
        return Q_HANDLED();
    }
#endif

#ifdef AUDIO_LIMITER_FOR_LOW_POWER
    case AUDIO_SET_POWER_LEVEL_DRC_SIG:
    {
        static eAudioPowerDrcLevel currentPowerDrcLevel = AUDIO_MAX_DRC_LEVEL;
        AudioSetPowerLevelDrcEvt* pEvt = (AudioSetPowerLevelDrcEvt*)e;
        if(currentPowerDrcLevel!= pEvt->powerLevelDrc)
        {/* if the DRC is change */
            if(pEvt->powerLevelDrc == AUDIO_ADAPTER_DRC_LEVEL)
            {
                DSPDrv_SetDrcForAdaptorMode(&dspDrv);
            }
            if(pEvt->powerLevelDrc == AUDIO_NORMAL_BATTERY_DRC_LEVEL)
            {
                DSPDrv_SetDrcForNormalPower(&dspDrv);
            }
            else if (pEvt->powerLevelDrc == AUDIO_LOW_POWER_DRC_LEVEL)
            {
                DSPDrv_SetDrcForLowPower(&dspDrv);
            }
            currentPowerDrcLevel = pEvt->powerLevelDrc;
        }
        return Q_HANDLED();
    }
#endif
    case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
    default:
          break;
    }
    /*
     * Return to super state in case other signals such as SYSTEM_ACTIVE/SLEEP_REQ_SIG coming
     */
    return Q_SUPER(&AudioSrv_Active);
}

#ifdef HAS_BT_TONE
/** \brief sub state to audio tones / cues stored on a BT module
 * Once switched we return back to AudioSrv_AudioMainHandler state.
 *
*/
QState AudioSrv_PlayToneState(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TP_PRINTF("Enter %s\r\n", __FUNCTION__);
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(FALSE);
#endif
            me->reqTone.calTimer = AudioSrv_PlayTone(me);
            PersistantObj_RefreshTick((cPersistantObj*)me,AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case AUDIO_SWITCH_CHANNEL_SIG:
        { /*receive new tone request, directly replace the current tone */
            AudioChannelSwitchReqEvt* req = (AudioChannelSwitchReqEvt*) e;
            if(req->channel == BT_TONE_CHANNEL)
            {
                if(me->reqTone.isExcuting)
                {
                    QActive_defer((QActive*)me, &deferredReqQue, e);
                    TP_PRINTF("save the request %d\r\n", req->btTone);
                }
                else
                {
                    pRequestor = req->sender;
                    AudioSrv_InitialTone(me, req);
                }
            }
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
            if(AudioSrv_IsTimeToPlayTone(me))
            {
                me->reqTone.calTimer = AudioSrv_PlayTone(me);
                if(me->reqTone.step > MUTE_VOL_STEP)
                { /* if the tone has been play, no need for restore volume, directly recall the tone in queue, if there's*/
                    me->reqTone.isExcuting = FALSE;
                    if(QActive_recall((QActive*)me, &deferredReqQue))
                    {
                        TP_PRINTF("recall a request\r\n");
                    }
                }
                if(me->reqTone.calTimer ==0)
                { /* tone is done*/
                    AudioSrv_RespSwitchChannelReq(BT_TONE_CHANNEL, RET_SUCCESS);
                    return Q_TRAN(&AudioSrv_AudioMainHandler);
                }
            }
            AudioSrv_CheckAuxinStatus(me, &dspDrv);
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
        }
        default:
          break;
    }
    /*
     * Return to super state in case other signals such as SYSTEM_ACTIVE/SLEEP_REQ_SIG coming
     */
    return Q_SUPER(&AudioSrv_Active);
}
#endif //HAS_BT_TONE

#ifdef AUDIO_DSP_AUTO_UPDATE
/** \brief sub state to dsp update
 * Once switched we return back to AudioSrv_AudioMainHandler state.
 *
*/
QState AudioSrv_DSPInit(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            AudioSrv_DSPInitAndTick(me);
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
            if(TRUE == AudioSrv_DSPInitAndTick(me))
            {
                return Q_TRAN(&AudioSrv_AudioMainHandler);
            }
            return Q_HANDLED();
        }
    }
    /*
     * Return to super state in case other signals such as SYSTEM_ACTIVE/SLEEP_REQ_SIG coming
     */
    return Q_SUPER(&AudioSrv_Active);
}
#endif //AUDIO_DSP_AUTO_UPDATE


/*****************************************************************************************************************
 *
 * public interface functions
 *
 *****************************************************************************************************************/
#ifdef AUDIO_MULTI_SOURCE
void AudioSrv_SendSwitchChannelReq(QActive * sender, eAudioChannel channel)
{
    AudioChannelSwitchReqEvt* SwitchReqEvt = Q_NEW(AudioChannelSwitchReqEvt, AUDIO_SWITCH_CHANNEL_SIG);
    SwitchReqEvt->channel = channel;
    SwitchReqEvt->sender = sender;
    SendToServer(AUDIO_SRV_ID, (QEvt*)SwitchReqEvt);
}
#endif /* AUDIO_MULTI_SOURCE */

void AudioSrv_SendMuteReq(QActive* sender, const bool mute)
{
    AudioMuteReqEvt* MuteReqEvt = Q_NEW(AudioMuteReqEvt, AUDIO_MUTE_SIG);
    MuteReqEvt->mute = mute;
    MuteReqEvt->sender = sender;
    SendToServer(AUDIO_SRV_ID,(QEvt*)MuteReqEvt);
}

void AudioSrv_Set(eDspSettId dspSettId, BOOL enable)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     pAudioSettEvt->dspSettId = dspSettId;
     pAudioSettEvt->enable = enable;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}

void AudioSrv_SetVolume(uint8 volLevel)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     Setting_Set(SETID_VOLUME, &volLevel);
     pAudioSettEvt->dspSettId = DSP_VOLUME_SETT_ID;
     pAudioSettEvt->enable = TRUE;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}
#ifdef HAS_BASS
void AudioSrv_SetBass(int8 bassLevel)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     Setting_Set(SETID_BASS, &bassLevel);
     pAudioSettEvt->dspSettId = DSP_BASS_SETT_ID;
     pAudioSettEvt->enable = TRUE;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}
#endif
#ifdef HAS_TREBLE
void AudioSrv_SetTreble(int8 trebleLevel)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     Setting_Set(SETID_TREBLE, &trebleLevel);
     pAudioSettEvt->dspSettId = DSP_TREBLE_SETT_ID;
     pAudioSettEvt->enable = TRUE;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}
#endif
#ifdef HAS_BT_TONE
void AudioSrv_SendAudioSrvToneCmd(QActive* sender, eBtCmd cmd)
{

    if((cmd<BT_FIRST_TONE) || (cmd>=BT_COMMON_MAX_CMD))
    { /*check if the btCmd is tone command */
        ASSERT(0);
    }
    DSPDrv_SetVol(&dspDrv, DEFAULT_VOLUME);
    AudioChannelSwitchReqEvt* req = Q_NEW(AudioChannelSwitchReqEvt, AUDIO_SWITCH_CHANNEL_SIG);
    req->channel = BT_TONE_CHANNEL;
    req->btTone = cmd;
    req->sender = (QActive*)sender;
    SendToServer(AUDIO_SRV_ID, (QEvt*)req);
}
#endif


#ifdef AUDIO_LIMITER_FOR_LOW_POWER
void AudioSrc_SetDrcRange(QActive* sender, eAudioPowerDrcLevel drcLevel)
{
    AudioSetPowerLevelDrcEvt* req = Q_NEW(AudioSetPowerLevelDrcEvt, AUDIO_SET_POWER_LEVEL_DRC_SIG);
    req->sender = (QActive*)sender;
    req->powerLevelDrc = drcLevel;
    SendToServer(AUDIO_SRV_ID, (QEvt*)req);
}
#endif

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
#ifdef AUDIO_MULTI_SOURCE

#ifdef HAS_GPIO_JACK_IN_DETECT
static void AudioSrv_CheckJackInStatus(cAudioSrv * const me, cDSPDrv* DSPDrv)
{
    uint8 i = 0;

    for( i = 0; i < ArraySize(AudioJackIn); i++)
    {
        uint8 isJackIn = (me->audioJackIn[i].isJackInFunc)();
        uint8 preJackStatus = *((bool*)Setting_Get(SETID_IS_AUXIN_PLUG_IN));
        preJackStatus   = (preJackStatus>>(uint8)(me->audioJackIn[i].audioJackInSourceId))&0x01;
        if (isJackIn != preJackStatus)
        {
            AudioStateEvt* pAudioStateEvt = Q_NEW(AudioStateEvt, AUDIO_STATE_SIG);
            pAudioStateEvt->jackId = me->audioJackIn[i].audioJackInSourceId;
            if (isJackIn)
            {
                isJackIn=(0x01 << (uint8)(me->audioJackIn[i].audioJackInSourceId))|(*(bool*)Setting_Get(SETID_IS_AUXIN_PLUG_IN));
                pAudioStateEvt->IsJackIn = TRUE;
#ifdef HAS_AUDIO_ADC
                if((me->channel == AUDIO_CHANNEL_I2S_3) && (me->audioJackIn[i].audioJackInSourceId == AUXIN_JACK)) /* the current source is auxin*/
                {
                    AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_AUXIN_PGA);
                    AudioAdcDrv_enableMute(&audioAdcDrv, FALSE); // Unmute audio adc output when plug-in the audio jack.
                }
                if((me->channel == AUDIO_CHANNEL_RCA) && (me->audioJackIn[i].audioJackInSourceId == RCA_IN_JACK)) /* the current source is RCA in*/
                {
                    AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_RCA_IN_PGA);
                    AudioAdcDrv_enableMute(&audioAdcDrv, FALSE); // Mute audio adc output when unplug the audio jack
                }
#endif
            }
            else
            {
                isJackIn=~(0x01<<(uint8)(me->audioJackIn[i].audioJackInSourceId))&(*(bool*)Setting_Get(SETID_IS_AUXIN_PLUG_IN));
                pAudioStateEvt->IsJackIn = FALSE;
#ifdef HAS_AUDIO_ADC
                if(((me->channel == AUDIO_CHANNEL_I2S_3) && (me->audioJackIn[i].audioJackInSourceId == AUXIN_JACK)) /* the current source is auxin*/
                ||((me->channel == AUDIO_CHANNEL_RCA) && (me->audioJackIn[i].audioJackInSourceId == RCA_IN_JACK))) /* the current source is RCA in*/
                {
                    AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_PGA_DEFAULT);
                    AudioAdcDrv_enableMute(&audioAdcDrv, TRUE); // Mute audio adc output when unplug the audio jack
                }
#endif
            }
            Setting_Set(SETID_IS_AUXIN_PLUG_IN, &isJackIn);
            QF_PUBLISH(&pAudioStateEvt->super, me);
            TP_PRINTF("Jack Detect channel %d is %d\r\n", me->audioJackIn[i].audioJackInSourceId, pAudioStateEvt->IsJackIn);
        }
    }

}
#else
static void AudioSrv_CheckAuxinStatus(cAudioSrv * const me, cDSPDrv* DSPDrv)
{
    bool isAuxin = DSPDrv_IsAuxin(DSPDrv);
    bool preAuxinStatus = *(bool*)Setting_Get(SETID_IS_AUXIN_PLUG_IN);
    if (isAuxin != preAuxinStatus)
    {
        AudioStateEvt* pAudioStateEvt = Q_NEW(AudioStateEvt, AUDIO_STATE_SIG);
        if (isAuxin)
        {
            pAudioStateEvt->IsJackIn = TRUE;
        }
        else
        {
            pAudioStateEvt->IsJackIn = FALSE;
        }
        bool hasMusicStream = DSPDrv_HasMusicStream(DSPDrv);
        if(!hasMusicStream)
        {
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(TRUE);
#endif
        }
        Setting_Set(SETID_IS_AUXIN_PLUG_IN, &isAuxin);
        QF_PUBLISH(&pAudioStateEvt->super, me);
    }
}

#endif

#ifdef MUTIPLE_SOURCE_MUSIC_DETECTION

void AudioSrv_muteDAC(bool mute)
{
    if (mute)
        DSPDrv_MuteDACOut(&dspDrv);
    else
        DSPDrv_UnMuteDACOut(&dspDrv);
}

bool AudioSrv_IsDigitalPCM()
{
    return DSPDrv_IsPCM(&dspDrv); 
}

static void AudioSrv_CheckMusicStream(cAudioSrv * const me, cDSPDrv* DSPDrv)
{
    uint8 preStatus;
    for(uint8 i = 0; i < ArraySize(AudioMusicDetect); i++)
    {
        uint8 hasMusicStream = (me->audioMusicDet[i].isMusicDetectedFunc)();
         preStatus   = *((bool*)Setting_Get(SETID_MUSIC_DET));
         preStatus   = (preStatus>>i)&0x01;
        if ((preStatus != hasMusicStream) ||
            (hasMusicStream && (muteDelayCounter[i] < MUTE_DELAY_TIME)))
        {
            if (hasMusicStream)
            {
#ifdef HAS_AMPLIFY_MUTE
                AudioDrv_Mute(FALSE);
#endif
                muteDelayCounter[i] = MUTE_DELAY_TIME;
                AudioMusicDetectStateEvt* pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->jackId = AudioJackIn[i].audioJackInSourceId;
                pAudioMusicStateEvt->hasMusicStream = TRUE;
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("music channel %d is %d\r\n", AudioJackIn[i].audioJackInSourceId, pAudioMusicStateEvt->hasMusicStream);
                hasMusicStream=(0x01<<i)|(*(bool*)Setting_Get(me->audioMusicDet[i].settingId));
                Setting_Set(me->audioMusicDet[i].settingId, &hasMusicStream);
            }
            else
            {
                if(muteDelayCounter[i]>0) /*Wait a while to make sure the music is really stopped*/
                {
                    muteDelayCounter[i]--;
                }
                else
                {
#ifdef HAS_AMPLIFY_MUTE
                    AudioDrv_Mute(TRUE);
#endif
                    AudioMusicDetectStateEvt* pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                    pAudioMusicStateEvt->jackId = AudioJackIn[i].audioJackInSourceId;
                    pAudioMusicStateEvt->hasMusicStream = FALSE;
                    QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                    TP_PRINTF("music channel %d is %d\r\n", AudioJackIn[i].audioJackInSourceId, pAudioMusicStateEvt->hasMusicStream);
                    hasMusicStream=(~(0x01<<i))&(*(bool*)Setting_Get(me->audioMusicDet[i].settingId));
                    Setting_Set(me->audioMusicDet[i].settingId, &hasMusicStream);
                }
            }

        }
    }
}


#else
static void AudioSrv_CheckMusicStream(cAudioSrv * const me, cDSPDrv* DSPDrv)
{
    bool hasMusicStream = FALSE;
    bool preStatus = *(bool*)Setting_Get(SETID_MUSIC_DET);

    /* check if dsp driver is created. */
    if(DSPDrv->isCreated == TRUE)
    {
        hasMusicStream = DSPDrv_HasMusicStream(DSPDrv);
    }
    if ((preStatus != hasMusicStream) ||
        (hasMusicStream && (muteDelayCounter < MUTE_DELAY_TIME)))
    {
        if (hasMusicStream)
        {
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(FALSE);
#endif
            AudioMusicDetectStateEvt* pAudioMusicStateEvt;
            pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
            muteDelayCounter = MUTE_DELAY_TIME;
            pAudioMusicStateEvt->hasMusicStream = TRUE;
            Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
            QF_PUBLISH(&pAudioMusicStateEvt->super, me);
            TP_PRINTF("music states is %d\r\n", pAudioMusicStateEvt->hasMusicStream);
        }
        else
        {
            if(muteDelayCounter>0) /*Wait a while to make sure the music is really stopped*/
            {
                muteDelayCounter--;
            }
            else
            {
                AudioMusicDetectStateEvt* pAudioMusicStateEvt = Q_NEW(AudioMusicDetectStateEvt, AUDIO_MUSIC_STREAM_STATE_SIG);
                pAudioMusicStateEvt->hasMusicStream = FALSE;
#ifdef HAS_AMPLIFY_MUTE
                AudioDrv_Mute(TRUE);
#endif
                Setting_Set(SETID_MUSIC_DET, &hasMusicStream);
                QF_PUBLISH(&pAudioMusicStateEvt->super, me);
                TP_PRINTF("music states is %d\r\n", pAudioMusicStateEvt->hasMusicStream);
            }
        }
    }
}
#endif

static void AudioSrv_SetChannel(eAudioChannel audioChannel)
{
#ifndef HAS_I2S_INPUT
    if (audioChannel==AUDIO_CHANNEL_1)
    {  // AUx-in Channel
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_ANALOG_3);
	#ifdef BT_CODEC_STATUS_CHECK
    	BluetoothDrv_EnableCodecStatus(FALSE);
	#endif
    }
    else if (audioChannel==AUDIO_CHANNEL_2)
    {  // Bluetooth Channel
#ifdef BT_CODEC_STATUS_CHECK
        BluetoothDrv_EnableCodecStatus(TRUE);
#endif
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_ANALOG_1_2);
    }
    else if (audioChannel==AUDIO_CHANNEL_SPDIF_0)     // SPDIF
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_SPDIF_0);
    }
    else if (audioChannel==AUDIO_CHANNEL_SPDIF_1)     // SPDIF
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_SPDIF_1);
    }

#else
    if (audioChannel==AUDIO_CHANNEL_0)      // I2S
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_1);
        DSPDrv_setStereoMux(&dspDrv, DSP_MUX_CH1);  /* switch to i2s source using the mux */
    }
    else if (audioChannel==AUDIO_CHANNEL_1)     // ANALOG
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_ANALOG_3);
        DSPDrv_setStereoMux(&dspDrv, DSP_MUX_CH2);   /* switch to analog source using the mux */
#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT2); // aux
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_AUXIN_PGA); // todo: check if we need this
#endif
    }
    else if (audioChannel==AUDIO_CHANNEL_2)     // ANALOG
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_ANALOG_1_2);
#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, (AUDIO_ADC_ANALOG_DIFF_INPUT1 | AUDIO_ADC_ANALOG_DIFF_INPUT2)); // bt works

        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_BT_PGA); // todo: check if we need this
#endif


    }
    else if (audioChannel==AUDIO_CHANNEL_SPDIF_0)     // SPDIF
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_SPDIF_0);
    }
    else if (audioChannel==AUDIO_CHANNEL_SPDIF_1)     // SPDIF
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_SPDIF_1);
    }
/*__________________________________________________________________*/
    else if (audioChannel==AUDIO_CHANNEL_RCA)     // RCA
    {
#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT1); // rca
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_RCA_IN_PGA); // todo: check if we need this
#endif
    }
/*__________________________________________________________________*/
    else if (audioChannel == AUDIO_CHANNEL_I2S_2)
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_2);
#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_NO_INPUT);
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_RCA_IN_PGA);
#endif
    }
    else if (audioChannel == AUDIO_CHANNEL_I2S_3)
    {
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_3);
    }
#ifdef HAS_MULTIROOM_FEATURE
    else if ((audioChannel == AUDIO_CHANNEL_AUXIN_DIRECT) || (audioChannel == AUDIO_CHANNEL_AUXIN_MULTIROOM))
    {
        /* There are two source select block in DSP for multiroom feature.
         * So when switching source, set the two source select accordingly.
         */
        /* set the first source select */
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_3);
        /* set the second source select */
        if (audioChannel == AUDIO_CHANNEL_AUXIN_DIRECT)
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_4);
        }
        else
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_2);
        }

#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT1);
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_AUXIN_PGA);
#endif
    }
    else if ((audioChannel == AUDIO_CHANNEL_RCA_IN_DIRECT) || (audioChannel == AUDIO_CHANNEL_RCA_IN_MULTIROOM))
    {
        /* There are two source select block in DSP for multiroom feature.
         * So when switching source, set the two source select accordingly.
         */
        /* set the first source select */
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_3);
        /* set the second source select */
        if (audioChannel == AUDIO_CHANNEL_RCA_IN_DIRECT)
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_4);
        }
        else
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_2);
        }

#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_INPUT3);
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_RCA_IN_PGA);
#endif //#ifdef HAS_AUDIO_ADC
    }
    else if ((audioChannel == AUDIO_CHANNEL_OPT_IN_DIRECT) || (audioChannel == AUDIO_CHANNEL_OPT_IN_MULTIROOM))
    {
        /* There are two source select block in DSP for multiroom feature.
         * So when switching source, set the two source select accordingly.
         */
        /* set the first source select */
        DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_1);
        /* set the second source select */
        if (audioChannel == AUDIO_CHANNEL_OPT_IN_DIRECT)
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_4);
        }
        else
        {
            DSPDrv_set_Input(&dspDrv, AUDIOCTRL_DRIVER_INPUT_I2S_2);
        }
#ifdef HAS_AUDIO_ADC
        AudioAdcDrv_setInput(&audioAdcDrv, AUDIO_ADC_ANALOG_NO_INPUT);
        AudioAdcDrv_setPGA(&audioAdcDrv, AUDIO_ADC_PGA_DEFAULT);
#endif
    }
#endif //#ifdef HAS_MULTIROOM_FEATURE
#endif
}

static void AudioSrv_RespSwitchChannelReq(eAudioChannel channel, eEvtReturn result)
{
    /*asser here for debug purpose*/
    ASSERT(pRequestor);
    AudioChannelSwitchRespEvt* resp = Q_NEW(AudioChannelSwitchRespEvt, AUDIO_SWITCH_CHANNEL_RESP_SIG);
    resp->channel = channel;
    resp->evtReturn = result;
    QACTIVE_POST((QActive*)pRequestor,(QEvt*)resp , 0);
}


static void AudioSrv_ScanChannelState(cAudioSrv * const me, uint16 TickTimeInterval)
{
#ifdef HAS_SPDIF_SIGNAL_SENSE
    AudioDrv_OpticalReading();
#endif
#ifdef HAS_ANALOG_SIGNAL_SENSE
    AudioDrv_AnalogReading();
#endif
    if (me->JackScanTimer > 0)
    {
        if ((me->JackScanTimer-=TickTimeInterval) <= 0)
        {
#ifdef HAS_GPIO_JACK_IN_DETECT
            AudioSrv_CheckJackInStatus(me, &dspDrv);
#else
            AudioSrv_CheckAuxinStatus(me, &dspDrv);
#endif
            /* scan the Jack every 1s */
            me->JackScanTimer = AUDIO_ACTIVE_LINE_IN_JACK_SCAN_TIME;
        }
    }
    if (me->musicDetectTimer > 0)
    {
        if ((me->musicDetectTimer -= TickTimeInterval) <= 0)
        {
            AudioSrv_CheckMusicStream(me, &dspDrv);
            me->musicDetectTimer=AUDIO_ACTIVE_MUSIC_DETECT_TIME;
        }
    }
}
#endif // AUDIO_MULTI_SOURCE

static void AudioSrv_PeriodicTask(cAudioSrv * const me, uint16 TickTimeInterval)
{
#ifdef AUDIO_MULTI_SOURCE

    AudioSrv_ScanChannelState(me, TickTimeInterval);

    if(me->changeChannelTimer > 0)
    {
        if ((me->changeChannelTimer-=TickTimeInterval) <= 0)
        {
            AudioSrv_SetChannel(me->channel);
            Setting_Set(SETID_CHANNEL, &me->channel);
            AudioSrv_RespSwitchChannelReq(me->channel, RET_SUCCESS);
#ifdef HAS_AMPLIFY_MUTE
            AudioDrv_Mute(FALSE); // added unmuting after haved switched channel, as we did mute before doing switch
#endif
#ifdef HAS_AMPLIFY_RESET
            AudioDrv_ResetAmp(FALSE);
#endif
            isChangingChannel = FALSE;
        }
    }
#endif //AUDIO_MULTI_SOURCE
}

#if (defined MUSIC_DETECTION_WHEN_STANDBY) || (defined JACK_DETECTION_WHEN_STANDBY)
static void AudioSrv_DeactivePeriodicTask(cAudioSrv * const me, uint16 TickTimeInterval)
{
#ifdef AUDIO_MULTI_SOURCE
    AudioSrv_ScanChannelState(me, TickTimeInterval);
#endif
}
#endif //#if (defined MUSIC_DETECTION_WHEN_STANDBY) || (defined JACK_DETECTION_WHEN_STANDBY)

#ifdef HAS_BT_TONE

static void AudioSrv_InitialTone(cAudioSrv * const me, AudioChannelSwitchReqEvt* req)
{
    me->reqTone.toneId = req->btTone;
    me->reqTone.isExcuting = TRUE;
    if(me->channel == BT_CHANNEL)
    { /* if channel is already BT channel, skip DSP channel switching and go to play tone state directly*/
        me->reqTone.step =  SEND_TONE_CMD_STEP;

    }
    else
    {
        me->reqTone.step =  CHANGE_CHANNEL_STEP;
    }
}
static int16 AudioSrv_PlayTone(cAudioSrv * const me)
{
    int16 delayTime;
    static uint8 vol = 0;;
    if(me->reqTone.step  >=MAX_STEP)
    {
        delayTime = 0;
    }
    else if(me->reqTone.step  == PLAY_TONE_STEP)
    { /*different tone has different playing time */
        delayTime = AUDIO_BT_TONE_TIME_MS[me->reqTone.toneId - BT_FIRST_TONE];
    }
    else
    {
        delayTime = AUDIO_BT_TONE_PROCESS_DELAY_MS[me->reqTone.step ];
    }
    switch(me->reqTone.step )
    {
        case CHANGE_CHANNEL_STEP:
        {
            AudioSrv_SetChannel(BT_CHANNEL);
            me->reqTone.step ++;
            break;
        }
#if (defined(HAS_BT_TONE) && defined(HAS_BLUETOOTH))
        case SEND_TONE_CMD_STEP:
        {
            BluetoothSrv_SendBtCmd((QActive*)me,me->reqTone.toneId);
            me->reqTone.step ++;
            break;
        }
#endif
        case CHANGE_VOL_STEP:
        {
            DSPDrv_SetVol(&dspDrv, BT_TONE_DEFALUT_VOLUME);
            me->reqTone.step ++;
            break;
        }
        case PLAY_TONE_STEP:
        {
            me->reqTone.step ++;
            break;
        }
        case MUTE_VOL_STEP:
        {
            vol = 0;
            DSPDrv_SetVol(&dspDrv, vol);
            if(me->reqTone.toneId == BT_TONE_POWER_OFF_CMD)
            {
                /* Set the channel to BT after power off tone*/
                me->channel= BT_CHANNEL;
                AudioSrv_SetChannel(BT_CHANNEL);
                Setting_Set(SETID_CHANNEL, &me->channel);
                me->reqTone.step  = MAX_STEP;
            }
            else
            {
                if(me->channel == BT_CHANNEL)
                { /*no need to switch channel back to line in */
                    me->reqTone.step  = RESTORE_VOL_STEP;
                }
                else
                {
                    me->reqTone.step ++;
                }
            }
            break;
        }
        case RESTORE_CHANNEL_STEP:
        {
            AudioSrv_SetChannel(me->channel);
            me->reqTone.step ++;
            break;
        }
        case RESTORE_VOL_STEP:
        {
            vol+=BT_TONE_RESTORE_VOL_STEP;
            uint8 originalVol = *(uint8*)Setting_Get(SETID_VOLUME);
            if(originalVol> vol)
            {
                DSPDrv_SetVol(&dspDrv, vol);
            }
            else
            {
                DSPDrv_SetVol(&dspDrv, originalVol);
                me->reqTone.step ++;
            }
            break;
        }
        default:
            break;
    }
    return delayTime;
}


static bool AudioSrv_IsTimeToPlayTone(cAudioSrv * const me)
{
    bool ret = FALSE;
    if(me->reqTone.calTimer>0)
    {
        me->reqTone.calTimer-= AUDIO_SRV_TIMEOUT_IN_MS;
    }
    else
    {
        ret = TRUE;
    }
    return ret;
}
#endif

static bool AudioSrv_DSPInitAndTick(cAudioSrv * const me)
{
    bool ret = FALSE;
    if(!dspDrv.isCreated)
    {
        /*
         * DspDrv object does not exist, this means the timer event may be
         * left over from the last state handler, we should ignore it.
        */
        return ret;
    }
    uint16 delaytime = DSPDrv_Init(&dspDrv);
    if (0 == delaytime)
    {
        ret = TRUE;
        bool defaultSetting = FALSE;
#ifdef HAS_AMPLIFY_MUTE
        AudioDrv_Mute(TRUE);
#endif
        DSPDrv_MuteDACOut(&dspDrv);
#ifdef REMEMBER_AUXIN_STATUS
        if(!Setting_IsReady(SETID_IS_AUXIN_PLUG_IN))
        {/*if AUXIN jack status is not set, set it for the first time*/
            Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultSetting);
        }
#else
        Setting_Set(SETID_IS_AUXIN_PLUG_IN, &defaultSetting);
#endif
#ifdef HAS_GPIO_JACK_IN_DETECT
#ifdef HAS_RCA_IN
        Setting_Set(SETID_IS_RCA_PLUG_IN, &defaultSetting);
#endif

#endif
        Setting_Set(SETID_MUSIC_DET, &defaultSetting);

#ifndef DO_NOT_SET_DEFAULT_AUDIO_CHANNEL
        /* Set the default channel */
#ifdef AUDIO_MULTI_SOURCE
        me->channel= AUDIO_DEFAULT_CHANNEL;
        Setting_Set(SETID_CHANNEL, &me->channel);
        AudioSrv_SetChannel(AUDIO_DEFAULT_CHANNEL);
#else
        me->channel= AUDIO_CHANNEL_INVALID;
        Setting_Set(SETID_CHANNEL, &me->channel);
#endif
#endif // end of #ifndef NO_SET_DEFAULT_AUDIO_CHANNEL
#ifdef REMEMBER_VOLUME
        if(!Setting_IsReady(SETID_VOLUME))
        {/*if volume is not set, set it for the first time*/
            DSPDrv_SetVol(&dspDrv, dspDrv.default_vol);
            Setting_Set(SETID_VOLUME, &dspDrv.default_vol);
        }
#else
        /* Set the default volume level every time boot up the audioSrv*/
        DSPDrv_SetVol(&dspDrv, (dspDrv.default_vol));
        Setting_Set(SETID_VOLUME, &(dspDrv.default_vol));
#endif
    }
    else
    {
        PersistantObj_RefreshTick((cPersistantObj*)me, delaytime);
    }
    return ret;
}

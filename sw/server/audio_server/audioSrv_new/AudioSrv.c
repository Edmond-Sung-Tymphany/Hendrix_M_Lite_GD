/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Audio Server
                  -------------------------

                  SW Module Document




@file        AudioSrv.c
@brief       This file implements the audio service provider
@author      Bob.Xu 
@date        2015-06-12
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2015-06-12     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "./AudioSrv_priv.h"
#include "trace.h"
#include "controller.h"
#include "AudioSrv.Config"
#include "AudioDrv.h"
#include "SettingSrv.h"
#include "tym_qp_lib.h"


#ifdef AUDIOSRV_DEBUG
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...) TymQP_DumpQueue_WithLog((QActive *)(me), __func__, __VA_ARGS__)
    #define AUDIOSRV_DEBUG_MSG TP_PRINTF
#else
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...)
    #define AUDIOSRV_DEBUG_MSG(...)
    #undef   TP_PRINTF
    #define  TP_PRINTF(...)
#endif


/* Private functions / variables. Declare and drivers here */
/* Internal event queue - Size as needed */
static QEvt const *AudioEvtQue[AUDIO_SRV_EVENT_Q_SIZE];
#define CAST_ME cAudioSrv * audioSrv = (cAudioSrv *) me;
static QActive* pRequestor;

static cAudioDrv audioDrvObj;

/* internal signals */
enum InternalSignals
{
    TIMEOUT_SIG = MAX_SIG,

};

/* State function definitions */
static QState AudioSrv_Initial(cAudioSrv * const me);
static QState AudioSrv_PreActive(cAudioSrv * const me, QEvt const * const e);
static QState AudioSrv_Active(cAudioSrv * const me, QEvt const * const e);
static QState AudioSrv_DeActive(cAudioSrv * const me, QEvt const * const e);

/*****************************************************************************************************************
 *
 * Public functions
 *
 *****************************************************************************************************************/
void AudioSrv_SetVolume(int8 volLevel)
{
     AudioSrv_SetAudio(DSP_VOLUME_SETT_ID, TRUE, (uint32)volLevel, /*not-used*/0);
}

void AudioSrv_SetChannel(QActive * sender, eAudioChannel channel)
{
    AudioChannelSwitchReqEvt* SwitchReqEvt = Q_NEW(AudioChannelSwitchReqEvt, AUDIO_SWITCH_CHANNEL_SIG);
    SwitchReqEvt->channel = channel;
    SwitchReqEvt->sender = sender;
    SendToServer(AUDIO_SRV_ID, (QEvt*)SwitchReqEvt);
}

void AudioSrv_SendMuteReq(QActive* sender, eAudioMuteType muteType, const bool mute)
{
    AudioMuteReqEvt* pMuteReqEvt = Q_NEW(AudioMuteReqEvt, AUDIO_MUTE_SIG);
    pMuteReqEvt->mute = mute;
    pMuteReqEvt->audioMuteType = muteType;
    pMuteReqEvt->sender = sender;
    SendToServer(AUDIO_SRV_ID,(QEvt*)pMuteReqEvt);
}

void AudioSrv_SetEq(eAudioSettId dspSettId, BOOL enable)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     pAudioSettEvt->aduioSettId = dspSettId;
     pAudioSettEvt->enable = enable;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}

void AudioSrv_SystemTuning(eAudioSettId sysTuneId, BOOL enable)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     pAudioSettEvt->aduioSettId = sysTuneId;
     pAudioSettEvt->enable = enable;
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}

#ifdef HAS_DSP_CALIBRATION_GAIN
void AudioSrv_SetDspCalGain(eAudioSettId dspCalGainId, float fGainDb)
{
    AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
    if(dspCalGainId<DSP_CAL_GAIN1_ID || dspCalGainId>DSP_CAL_GAIN_MAX)
    {
        ASSERT(0);
        return;
    }
    
    pAudioSettEvt->aduioSettId = dspCalGainId;
    pAudioSettEvt->enable = TRUE; 
    pAudioSettEvt->param= *((uint32*)&fGainDb);    
    SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}
#endif /* HAS_DSP_CALIBRATION_GAIN */

/* Ideally, the API should be enough for setting all the audio settings with the parameter size
 * not more than sizeof(uint32) . So when add more audio setting requests, we should not need to
 * impement more APIs for setting and just need to add your audio setting ID in eAudioSettId.
 * Then implement your handling code for the audio setting in audio driver by project.
 */
void AudioSrv_SetAudio(eAudioSettId audioSettId, BOOL enable, uint32 param, uint32 param2)
{
     AudioSettEvt* pAudioSettEvt= Q_NEW(AudioSettEvt, AUDIO_SET_SIG);
     pAudioSettEvt->aduioSettId = audioSettId;
     pAudioSettEvt->enable = enable;
     pAudioSettEvt->param= *((uint32*)&param);
     pAudioSettEvt->param2= *((uint32*)&param2);
     SendToServer(AUDIO_SRV_ID, (QEvt*)pAudioSettEvt);
}


/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void AudioSrv_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(audioSrv);
    QS_OBJ_DICTIONARY(AudioSrv_DeActive);
    QS_OBJ_DICTIONARY(AudioSrv_PreActive);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&AudioSrv_Initial), TIMEOUT_SIG,
                                AudioEvtQue, Q_DIM(AudioEvtQue),AUDIO_SRV_ID);

    /* Subscribe */
}

void AudioSrv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState AudioSrv_Initial(cAudioSrv * const me)
{
    return Q_TRAN(&AudioSrv_DeActive);
}

/*   Active state - first state where "normal" service begins  */
static QState AudioSrv_Active(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
        {
            TP_PRINTF("Enter %s\r\n", __FUNCTION__);
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        /* Sometimes system have wrong sequence (ex. send continuous two SYSTEM_ACTIVE_REQ_SIG to AudioSrv),
         * and cause potential issues. The ASSERT here could protect these problems. */
    case SYSTEM_ACTIVE_REQ_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)SYSTEM_ACTIVE_REQ_SIG", e->sig);
            ASSERT(0);
            return Q_HANDLED();
        }
    case AUDIO_SET_SIG:
        {
            AudioSettEvt * evt = (AudioSettEvt*)e;
            AudioDrv_SetAudio(&audioDrvObj, evt->aduioSettId, evt->enable, evt->param, evt->param2);
            return Q_HANDLED();
        }
    case AUDIO_SWITCH_CHANNEL_SIG:
        {
            AudioChannelSwitchReqEvt *pReq = (AudioChannelSwitchReqEvt*)e;
            AudioDrv_SetChannel(pReq->channel);
            return Q_HANDLED();
        }
    case AUDIO_MUTE_SIG:
        {
            AudioMuteReqEvt* pMuteReqEvt = (AudioMuteReqEvt*)e;
            AudioDrv_Mute(pMuteReqEvt->audioMuteType, pMuteReqEvt->mute);
            CommonEvtResp((QActive*)me, pMuteReqEvt->sender, RET_SUCCESS, AUDIO_MUTE_RESP_SIG);
            return Q_HANDLED();
        }
#ifdef HAS_AUDIO_MUTE_CHANNEL
     case AUDIO_MUTE_CHANNEL_REQ_SIG:
        {
            AudioMuteChannelReqEvt* pMuteReqEvt = (AudioMuteChannelReqEvt*)e;
            AudioDrv_MuteChannel(pMuteReqEvt->channel_mask);
            return Q_HANDLED();
        }
#endif
     case TIMEOUT_SIG:
        {
           /* Note:
              * All the project spicific status chacking and updating code should be implemented
              * in API: AudioDrv_UpdateStatus in file
              * sw\project_files\xxx\portingLayer\AudioPorting\AudioDrv.c
              */
            AudioDrv_UpdateStatus(&audioDrvObj);
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
#ifdef AUDIO_DSP_AUTO_UPDATE
    case SETTING_UPDATE_SIG:
        {
            SettingUpdateEvt* pEvt = (SettingUpdateEvt*)e;
            if ((SETID_DSP_INIT_DATA == pEvt->setting_id) || (SETID_DSP_TUNABLE_PART == pEvt->setting_id))
            {
                AudioDrv_Reset(&audioDrvObj);
                return Q_TRAN(&AudioSrv_ReInit);
            }
            else
            {
              return Q_HANDLED();
            }
        }
#endif
    case SYSTEM_SLEEP_REQ_SIG:
        {
            /**
             *  If it is necessary to mute the system before going to sleep, please
             *  send a mute event to audio server before sending SYSTEM_SLEEP_REQ_SIG
             */
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
            AudioDrv_Xtor(&audioDrvObj);
            return Q_TRAN(AudioSrv_DeActive);
        }
    case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
    default:
          break;
    }
    return Q_SUPER(&QHsm_top);
}

/* PreActive state - Use this state to ramp down the server  */
static QState AudioSrv_PreActive(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        /* fill me in */
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
            if(audioDrvObj.drvIsReady)
            {
                CommonEvtResp((QActive*)me, pRequestor, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
                return Q_TRAN(&AudioSrv_Active);
            }
            else
            {
                AudioDrv_Init(&audioDrvObj);
                if(0 != audioDrvObj.nextDelayTime)
                {
                    PersistantObj_RefreshTick((cPersistantObj*)me, audioDrvObj.nextDelayTime);
                }
                else
                {
                    PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
                }
            }
            return Q_HANDLED();
        }
        /*
         * Sometimes system have wrong sequence (ex. send continuous two SYSTEM_SLEEP_REQ_SIG to AudioSrv),
         * and cause potential issues. The ASSERT here could protect these problems.
         */
        case SYSTEM_SLEEP_REQ_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)SYSTEM_SLEEP_REQ_SIG", e->sig);
            ASSERT(0);
            return Q_HANDLED();
        }

        /* Normal we ensure AudioSrv Active then send request
         * if get request on DeActive, means system have potention problems
         */
        case AUDIO_MUTE_SIG:
        {
            //ASSERT(0);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


/* DeActive state - Use this state to ramp down the server  */
static QState AudioSrv_DeActive(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        /* fill me in */
        case Q_ENTRY_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            if(!audioDrvObj.drvIsReady)
            {
                AudioDrv_Ctor(&audioDrvObj);
            }
            pRequestor=((CommonReqEvt*)e)->sender;
            return Q_TRAN(&AudioSrv_PreActive);
        }
        case TIMEOUT_SIG:
        {
#ifndef PROJECT_BnO_SOUNDWALL   // sound wall need update status always
            if(audioDrvObj.drvIsReady)
#endif
            {
                /* Note:
                   * All the project spicific status chacking and updating code should be implemented
                   * in API: AudioDrv_UpdateStatus in file
                   * sw\project_files\xxx\portingLayer\AudioPorting\AudioDrv.c
                   */
                 AudioDrv_UpdateStatus(&audioDrvObj);
            }
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        /*
         * Sometimes system have wrong sequence (ex. send continuous two SYSTEM_SLEEP_REQ_SIG to AudioSrv),
         * and cause potential issues. The ASSERT here could protect these problems.
         */
        case SYSTEM_SLEEP_REQ_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)SYSTEM_SLEEP_REQ_SIG", e->sig);
            ASSERT(0);
            return Q_HANDLED();
        }

        /* Normal we ensure AudioSrv Active then send request
         * if get request on DeActive, means system have potention problems
         */
        case AUDIO_MUTE_SIG:
        {
            //ASSERT(0);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

#ifdef AUDIO_DSP_AUTO_UPDATE
/** \brief sub state to dsp update
 * Once switched we return back to AudioSrv_AudioMainHandler state.
 *
*/
QState AudioSrv_ReInit(cAudioSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            /* This will triger the timer and start the init procedures.*/
            
            PersistantObj_RefreshTick((cPersistantObj*)me, AUDIO_SRV_TIMEOUT_IN_MS);
            return Q_HANDLED();
        }
        case TIMEOUT_SIG:
        {
            if(TRUE == AudioDrv_Init(me))
            {
                return Q_TRAN(&AudioSrv_Active);
            }
            return Q_HANDLED();
        }
    }
    /*
     * Return to super state in case other signals such as SYSTEM_ACTIVE/SLEEP_REQ_SIG coming
     */
    return Q_SUPER(&AudioSrv_Active);
}
#endif //AUDIO_DSP_AUTO_UPDATE

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/

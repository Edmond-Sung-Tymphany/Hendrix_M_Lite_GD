/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Bluetooth Server
                  -------------------------

                  SW Module Document




@file        BluetoothSrv.c
@brief       it's the server to control the BT module
@author      Johnny Fan
@date        2014-05-11
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-05-11     Johnny Fan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/
#include "BluetoothSrv_priv.h"


#define CAST_ME cBluetoothSrv * BluetoothSrv = (cBluetoothSrv *) me;

#ifndef BT_DEBUG_ENABLE
#undef  TP_PRINTF
#define TP_PRINTF(...)
#endif

/* Private functions / variables. Declare and drivers here */
/* Internal event queue - Size as needed */
static QEvt const *BluetoothEvtQue[BT_SRV_EVENT_Q_SIZE];
static QEQueue deferredReqQue;
static QEvt const *pDeferredReqQueSto[3];

enum InternalSignals
{
    BT_TIMEOUT_SIG = MAX_SIG,
};

/* the time (ms) per timeout signal */
#define BT_SRV_PER_TICK_TIME_MS  3

static cBluetoothDrv bluetoothDrv;

QActive * cmdRequester = NULL;

static bool codecStatus;
static bool isBtCodedStateChanged;

eBtCmd toexe = BT_MAX_CMD;

static uint8 ampOnOffDelay;

#define AMP_ON_OFF_DELAY_TIME  5

#define NFC_DEBOUNCE_TIME_MS  200

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void BluetoothSrv_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(BluetoothSrv);
    QS_OBJ_DICTIONARY(BluetoothSrv_PreActive);
    QS_OBJ_DICTIONARY(BluetoothSrv_Active);
    QS_OBJ_DICTIONARY(BluetoothSrv_DeActive);

    BluetoothDrv_Ctor(&bluetoothDrv);
    BluetoothDrv_RegisterReportCallback(&bluetoothDrv, BluetoothSrv_DriverReportCallback);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&BluetoothSrv_Initial), BT_TIMEOUT_SIG,
                  BluetoothEvtQue, Q_DIM(BluetoothEvtQue), BT_SRV_ID);

    QEQueue_init(&deferredReqQue, pDeferredReqQueSto, Q_DIM(pDeferredReqQueSto));
}

void BluetoothSrv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

void BluetoothSrv_SendBtCmd(QActive* me, eBtCmd cmd)
{
    BtCmdEvt* req = Q_NEW(BtCmdEvt,BT_REQ_SIG);
    req->btCmd = cmd;
    req->sender = (QActive*)me;
    SendToServer(BT_SRV_ID, (QEvt*)req);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */

QState BluetoothSrv_Initial(cBluetoothSrv * const me, QEvt const * const e)
{
    return Q_TRAN(&BluetoothSrv_DeActive);
}

/* This state is used to as wait state. Wait until power  */
QState BluetoothSrv_PreActive(cBluetoothSrv * const me, QEvt const * const e)
{
    CAST_ME;
    switch(e->sig)
    {
        case Q_ENTRY_SIG:
        {
            isBtCodedStateChanged = FALSE;
            me->timeCount = BT_START_UP_DELAY_MS;
            PersistantObj_RefreshTick((cPersistantObj*)BluetoothSrv, BT_SRV_PER_TICK_TIME_MS);
            return Q_HANDLED();
        }
        case BT_TIMEOUT_SIG:
        {
            me->timeCount -= BT_SRV_PER_TICK_TIME_MS;
            if (me->timeCount <= 0)
            {
                return Q_TRAN(&BluetoothSrv_Active);
            }
            else
            {
                PersistantObj_RefreshTick((cPersistantObj*)BluetoothSrv, BT_SRV_PER_TICK_TIME_MS);
            }
            return Q_HANDLED();
        }
        case BT_REQ_SIG:
        {
            QActive_defer((QActive*)me, &deferredReqQue, e);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
        /* Not list all the QP signals here, so doesn't put a assert in the default*/
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*   Active state - first state where "normal" service begins  */
QState BluetoothSrv_Active(cBluetoothSrv * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
#ifndef     HAS_NO_AUTO_BT_STARTUP
            BluetoothDrv_TurnOnBT(&bluetoothDrv);
#endif
            PersistantObj_RefreshTick((cPersistantObj*)BluetoothSrv, BT_SRV_PER_TICK_TIME_MS);
            return Q_HANDLED();
        }
        case BT_TIMEOUT_SIG:
        {
            /* Update the timer calculation*/
            /* check event queue and recall the command event*/
            BluetoothSrv_CheckQueueAndRecallCmdEvt(me);
            PersistantObj_RefreshTick((cPersistantObj*)BluetoothSrv, BT_SRV_PER_TICK_TIME_MS);
            return Q_HANDLED();
        }
        case BT_REQ_SIG:
        {
            if (FALSE == BluetoothDrv_IsBusy(&bluetoothDrv))
            {
                BluetoothSrv_ExecuteCmd((BtCmdEvt*) e);
                TP_PRINTF("excute BT request %d\r\n", evt->btCmd);
            }
            else
            {
                QActive_defer((QActive*)me, &deferredReqQue, e);
            }
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
            return Q_TRAN(BluetoothSrv_DeActive);
        }
        case Q_EXIT_SIG:
        {
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


/*   DeActive state - Use this state to ramp down the server  */
QState BluetoothSrv_DeActive(cBluetoothSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            me->btStatus = BT_MAX_STA;
            /*un-regester to get more BT status before power down, avoid noise*/
            BluetoothSrv_SendBtCmd((QActive*)me, BT_PWR_OFF_CMD);
            return Q_HANDLED();
        }
        /* fill me in */
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
            return Q_TRAN(&BluetoothSrv_PreActive);
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        /* fill me in */
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

bool BluetoothSrv_IsBusy(QActive* me)
{
    return BluetoothDrv_IsBusy(&bluetoothDrv);
}

eBtStatus BluetoothSrv_GetBtStatus(QActive* me)
{
    return BluetoothDrv_GetBtStatus(&bluetoothDrv);
}


/*****************************************************************************************************************
 *BluetoothSrv_DriverReportCallback
 * private functions
 *
 *****************************************************************************************************************/

static void BluetoothSrv_DriverReportCallback(eBtReportType type, uint32 reportData)
{
    switch (type)
    {
        case BT_REPORT_TYPE_STATUS_IND:
        {
            Setting_Set(SETID_BT_STATUS, &reportData);

            BtStatusEvt *pe = Q_NEW(BtStatusEvt, BT_STATE_SIG);
            pe->btStatus = (eBtStatus)reportData;
            QF_PUBLISH(&pe->super, me);
            break;
        }
        case BT_REPORT_TYPE_COMMAND_RESP:
        {
            BtCmdRespEvt *pe = Q_NEW(BtCmdRespEvt, BT_RESP_SIG);
            pe->btCmd = (eBtCmd)reportData;
            if (NULL != cmdRequester)
            {
                QACTIVE_POST((QActive*)cmdRequester, (QEvt*)pe, 0);
            }
            break;
        }
        default:
            ASSERT(0);
            break;
    }
}

static void BluetoothSrv_ExecuteCmd(BtCmdEvt* pEvt)
{
    cmdRequester = pEvt->sender;

    switch (pEvt->btCmd)
    {
        case BT_ENTER_PAIRING_CMD:
            BluetoothDrv_BtCmd_GoDiscoverable(&bluetoothDrv);
            break;
        case BT_ENTER_CONNECTABLE_CMD:
            BluetoothDrv_BtCmd_GoConnectable(&bluetoothDrv);
            break;
        case BT_CONNECT_CMD:
            BluetoothDrv_BtCmd_GoReconnect(&bluetoothDrv);
            break;
        case BT_RESET_PAIR_LIST_CMD:
            BluetoothDrv_BtCmd_ResetPDL(&bluetoothDrv);
            break;
        case BT_PWR_ON_CMD:
            BluetoothDrv_BtCmd_PowerOn(&bluetoothDrv);
            break;
        case BT_PWR_OFF_CMD:
            BluetoothDrv_BtCmd_PowerOff(&bluetoothDrv);
            break;
        default:
            break;
    }
}

static void BluetoothSrv_CheckQueueAndRecallCmdEvt(cBluetoothSrv * const me)
{
    QActive_recall((QActive*)me, &deferredReqQue);
}


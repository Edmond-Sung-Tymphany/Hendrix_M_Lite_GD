/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Comm Server
                  -------------------------

                  SW Module Document




@file        CommSrv.c
@brief       It's the server to communicate with SoC
@author      Eason Huang 
@date        2016-06-02
@Copyright (c) <2015> Tymphany HK Ltd. All rights reserved.

DESCRIPTION: Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/

#include "CommSrv_priv.h"
#include "bsp.h"
#include "trace.h"
#include "controller.h"
#include "CommSrv.Config"
#include "CommSrv.h"
#include "CommDrv.h"

#define CAST_ME cCommSrv * CommSrv = (cCommSrv *) me;

/* Internal event queue */
static QEvt const *CommEvtQue[COMM_SRV_EVENT_Q_SIZE];

/* internal signals */
enum InternalSignals
{
    COMM_TIMEOUT_SIG = MAX_SIG
};

/* Private functions */

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void CommSrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    /* Add to QSPY directory - only does so if QSPY enabled. 
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(CommSrv);
    QS_OBJ_DICTIONARY(CommSrv_PreActive);
    QS_OBJ_DICTIONARY(CommSrv_Active);
    QS_OBJ_DICTIONARY(CommSrv_DeActive);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&CommSrv_Initial), COMM_TIMEOUT_SIG,
                      CommEvtQue, Q_DIM(CommEvtQue), COMM_SRV_ID);
}

void CommSrv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState CommSrv_Initial(cCommSrv * const me, QEvt const * const e)
{

    return Q_TRAN(&CommSrv_PreActive);
}


/* This state is used to as wait state. Wait until power  */
static QState CommSrv_PreActive(cCommSrv * const me, QEvt const * const e)
{
    switch(e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            //CommDrv_Ctor(me->pCommDrvObj);
            CommSrv_CtorDrvObjs(me);
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);     
            return Q_TRAN(&CommSrv_Active);
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


/*   Active state - first state where "normal" service begins  */
static QState CommSrv_Active(cCommSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            CommDrv_SelSOCUsbFunc(USB2USB);
            CommDrv_SetSOCPower(ON);
            PersistantObj_RefreshTick((cPersistantObj*)me, COMM_SERVER_TICK_MS);
            return Q_HANDLED();
        }
        case COMM_TIMEOUT_SIG:
        {
            PersistantObj_RefreshTick((cPersistantObj*)me, COMM_SERVER_TICK_MS);
            return Q_HANDLED();
        }
        /* receive request from MainApp */
        case COMM_REQ_SIG:
        {
            CommSrv_SendReq((commSendCmdEvt*) e);
            return Q_HANDLED();
        }
        /* receive commands from SOC */
        case COMM_RECEIVE_COMMAND:
        {
            CommSrv_HandleCommand(me, e);
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            return Q_TRAN(CommSrv_DeActive);
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*   DeActive state - Use this state to ramp down the server  */
static QState CommSrv_DeActive(cCommSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            CommonReqEvt* pReq = (CommonReqEvt*)e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
            return Q_TRAN(&CommSrv_Active);
        }
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}

/*****************************************************************************************************************
 *
 * public functions
 *
 *****************************************************************************************************************/
void CommSrv_SendCmd(QActive* me, eCommCmd cmd)
{
    commSendCmdEvt* req = Q_NEW(commSendCmdEvt, COMM_REQ_SIG);
    req->commCmd = cmd;
    req->sender = (QActive*)me;
    SendToServer(COMM_SRV_ID, (QEvt*)req);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void CommSrv_CtorDrvObjs(cCommSrv *const me)
{
    if(me->isReady)
    {
        /* if driver obj has been created, simply return*/
        return;
    }

    CommDrv_Ctor(me->pCommDrvObj);
    me->isReady = TRUE;
}

static void CommSrv_XtorDrvObjs(cCommSrv *const me)
{
    CommDrv_Xtor(me->pCommDrvObj);
    me->isReady = FALSE;
}

static void CommSrv_SendReq(commSendCmdEvt* pEvt)
{
    QActive * cmdRequester = NULL;
    uint8 cmd[2];

    cmdRequester = pEvt->sender;

    switch (pEvt->commCmd)
    {
        case COMM_BT_PAIRING_CMD:
            cmd[0] = MCU_CMD_KEY_BT_PAIRING;
            cmd[1] = '\0';
            CommDrv_WriteCommand(cmd);
            break;
        case COMM_BT_DISCONNECT_CMD:
            break;
        default:
            break;
    }    
}

static void CommSrv_SendCommEvt(eSocEvt evtId, uint32 param)
{
    CommStateEvt *pte = Q_NEW(CommStateEvt, COMM_STATE_SIG);

    pte->evtId = evtId;
    pte->param = param;

    QF_PUBLISH(&pte->super, 0);
}

static void CommSrv_HandleCommand(cCommSrv *const me, QEvt const * const e)
{
    uint8 cmd[MAX_COMM_CMD_LEN+1];
    uint8 cmdLen;
    uint8 volStr[MAX_COMM_CMD_LEN+1];
    uint8 volLen;
    uint32 volume;
    eSocEvt evtId;
    uint32 param = 0;

    CommCmdEvt* evt = (CommCmdEvt*)e;
    cmdLen = strlen(evt->cmd);
    memcpy(cmd, evt->cmd+1, cmdLen-2);
    cmd[cmdLen-2] = '\0';
    cmdLen = strlen(cmd);

    if (strcmp(cmd, COMMAND_STANDBY_MODE) == 0)
    {
        evtId = COMM_EVT_STANDBY;
    }
    else if (strcmp(cmd, COMMAND_SET_MUTE) == 0)
    {
        evtId = KEY_EVT_MUTE;
    }
    else if (strncmp(cmd, COMMAND_SET_VOLUME, strlen(COMMAND_SET_VOLUME)) == 0)
    {
        volLen = strlen(COMMAND_SET_VOLUME) + 1;
        memset(volStr, '\0', MAX_COMM_CMD_LEN+1);
        strncpy(volStr, cmd+volLen, cmdLen-volLen);
        volume = atoi(volStr);
        evtId = COMM_EVT_VOLUME;
        param = volume;
    }
    else if (cmd[0] == SOC_CMD_DSP_UPGRADE)
    {
        evtId = COMM_EVT_DSPUPGRADE;
    }

    if (evtId != COMM_EVT_INVALID)
    {
        CommSrv_SendCommEvt(evtId, param);
    }

    return;
}

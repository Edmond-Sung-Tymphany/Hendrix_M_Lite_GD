/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Debug S Server
                  -------------------------

                  SW Module Document




@file        DebugSSrv.c
@brief       Debug S server (with multi instance support)
@author      Dmitry.Abdulov
@date        2014-08-13
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-13     Dmitry.Abdulov
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :

Change History:
VERSION    : 2    revision  2014-10-08     Dmitry.Abdulov
DESCRIPTION: Refactor from DebugSett server
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "bsp.h"
#include "trace.h"
#include "DebugSSrv.h"
#include "./DebugSSrv_priv.h"
#include "controller.h"
#include "crc16.h"
#include "attachedDevices.h"
#include "ringbuf.h"

#include "trace.h"
#include "MainApp.h"

#ifdef GTEST
#include <string.h>
#endif

#ifdef HAS_KEYS
#include "KeySrv.h"
#endif
#ifdef HAS_ALLPLAY
#include "AllPlaySrv.h"
#endif
#ifdef HAS_LEDS
#include "LedSrv.h"
#endif
#ifdef HAS_BLUETOOTH
#include "BluetoothSrv.h"
#endif
#ifdef HAS_AUDIO_CONTROL
#include "AudioSrv.h"
#endif
#ifdef HAS_SETTING
#include "SettingSrv.h"
#endif

#ifdef HW_GPIO_DEBUG
#include "GpioDrv.h"
#endif
//Q_DEFINE_THIS_FILE
#ifdef HAS_APP_PRIVATE_SIG
#include "AppPrivSig.Config"
#endif
#ifdef PT_I2C_DEBUG
#include "I2CDrv.h"
#endif

#ifdef PT_ADC_DEBUG
#include "AdcDrv.h"
#define ADC_READ_FAIL   0xFFFF
#endif
//Q_DEFINE_THIS_FILE

#define CAST_ME cDebugSSrv * debugSSrv = (cDebugSSrv *) me;

/* private state functions */

#ifdef TP_MONITOR_ON_OFF_CONTROL
static bool tp_monitor_enable=FALSE;
// special control signal of TP monitor
#define TPMONITOR_ENABLE_SIG    199

REQ_EVT(TpMonitorCtlEvt)
    uint32_t enable;
END_REQ_EVT(TpMonitorCtlEvt)
#endif

/*____________________________________________________________________________*/
static void uartRxCallback(void* p);
static bool bIsStartByteReceived = FALSE;
#ifdef ENABLE_WAKEUP_BY_UART
static void uartWakeUpCallback();
/* wakeup flag for both uarts*/
static  bool bIsAllowToWakeUp = FALSE;
#endif
static void DebugSSrv_ParseAndRun(cDebugSSrv * const me);
static void DebugSSrv_ResetInBuf(cDebugSSrv * const me);
static void DebugSSrv_ResetOutBuf(cDebugSSrv * const me);
static void DebugSSrv_InputSourceCtor(cDebugSSrv * const me);
static void DebugSSrv_InputSourceXtor(cDebugSSrv * const me);
/*____________________________________________________________________________*/
static bool DebugSSrv_CheckCRC( const unsigned char *byte_stream, unsigned length );
static void DebugSSrv_HandleRespMsg(cDebugSSrv * const me, QEvt const * const e);
/*____________________________________________________________________________*/
/* server queue size,- define in product.config*/
static QEvt const *DebugEvtQue[DBG_SRV_EVENT_Q_SIZE];

#ifdef HAS_BLE_CTRL
static QEvt const *BLEEvtQue[DBG_SRV_EVENT_Q_SIZE];
#endif

#define MSG_POOL_NUM    3 // small, medium and large

static uint16 dbg_msg_size_map[MSG_POOL_NUM] = {SIZE_OF_SMALL_EVENTS, SIZE_OF_MEDIUM_EVENTS, SIZE_OF_LARGE_EVENTS};

/*============================================================================*/
static cDebugSSrv *meDebugSSrv[NUM_OF_UART] = {0};     // DSS server instances list

#ifdef PT_I2C_DEBUG
static cI2CDrv      dbgI2cObj1;
static cI2CDrv      dbgI2cObj2;
#endif

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
/*start up function for Debug Server, called when Debug Server object is created*/
void DebugSrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    debugSSrv->config.srv_id = DEBUG_SRV_ID;
    debugSSrv->config.source_device_id = DEBUG_DEV_ID;
    debugSSrv->config.bIsSubscribe = TRUE;
    debugSSrv->config.ppEvtQue = DebugEvtQue;
#ifdef PT_I2C_DEBUG
    const tDevice * tDev1 = NULL;
    const tDevice * tDev2 = NULL;
    tDev1 = getDevicebyIdAndType(DBG_I2C1_ID, I2C_DEV_TYPE, NULL);
    I2CDrv_Ctor(&dbgI2cObj1,(tI2CDevice*)tDev1);
    tDev2 = getDevicebyIdAndType(DBG_I2C2_ID, I2C_DEV_TYPE, NULL);
    I2CDrv_Ctor(&dbgI2cObj2,(tI2CDevice*)tDev2);
#endif

    DebugSSrv_StartUp(me);
}

#ifdef HAS_BLE_CTRL
/* start up function for BLE Control Server, called when BLE Server object is created */
void BLESrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    debugSSrv->config.srv_id = BLE_CTRL_SRV_ID;
    debugSSrv->config.source_device_id = BLE_DEV_ID;
    debugSSrv->config.bIsSubscribe = FALSE;
    debugSSrv->config.ppEvtQue = BLEEvtQue;
    DebugSSrv_StartUp(me);
}
#endif

/* base startup function, called when server object is created */
void DebugSSrv_StartUp(cPersistantObj *me)
{
    CAST_ME;
    DebugSSrv_InputSourceCtor(debugSSrv);
     /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&DebugSSrv_Initial), DEBUG_TIMEOUT_SIG,
                        debugSSrv->config.ppEvtQue, Q_DIM(DebugEvtQue), debugSSrv->config.srv_id);

}
/* shutdown function, called when server object is terminated*/
void DebugSSrv_ShutDown(cPersistantObj *me)
{
    CAST_ME;
	/* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
    DebugSSrv_InputSourceXtor(debugSSrv);
}
/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* initial state function , state to which server switch after ctor function been called
* @param me - pointer to server instance
* @param e - signal event
*/
QState DebugSSrv_Initial(cDebugSSrv * const me, QEvt const * const e)
{
    uint8 event_pool_idx = 0;
#if (NUM_OF_SMALL_EVENTS != 0 && SIZE_OF_SMALL_EVENTS != 0)
    dbg_msg_size_map[event_pool_idx++] = SIZE_OF_SMALL_EVENTS;
#endif
#if (NUM_OF_MEDIUM_EVENTS != 0 && SIZE_OF_MEDIUM_EVENTS != 0)
    dbg_msg_size_map[event_pool_idx++] = SIZE_OF_MEDIUM_EVENTS;
#endif
#if (NUM_OF_LARGE_EVENTS != 0 && SIZE_OF_LARGE_EVENTS != 0)
    dbg_msg_size_map[event_pool_idx++] = SIZE_OF_LARGE_EVENTS;
#endif

    /* Subscribe for need signals here */
  if (me->config.bIsSubscribe)
  {
    QActive_subscribe((QActive*) me, SYSTEM_STATE_SIG);
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG); // use the macros!
#endif
#ifdef HAS_ALLPLAY
    QActive_subscribe((QActive*) me, ALLPLAY_STATE_SIG);
#endif
#ifdef HAS_BLUETOOTH
    QActive_subscribe((QActive*) me, BT_STATE_SIG);
#endif
#ifdef HAS_AUDIO_CONTROL
    QActive_subscribe((QActive*) me, AUDIO_MUSIC_STREAM_STATE_SIG);
    QActive_subscribe((QActive*) me, AUDIO_STATE_SIG);
#endif
#if defined(ENABLE_SETTING_UPDATE_PUBLISH) || defined(SETTING_HAS_ROM_DATA)
    QActive_subscribe((QActive*) me, SETTING_UPDATE_SIG);
#endif
#if defined(HAS_ASE_TK) || defined(HAS_ASE_NG)
    /* Subscribe these two signals cause ASSERT on QActive_subscribe(), 
     * becuase subscribe signals should less than MAX_PUB_SIG
     * But move signals cause signal table signal, and cause SVS project have problem.
     * We should think solution later
     */
    //QActive_subscribe((QActive*) me, ASE_TK_REQ_SIG);
    //QActive_subscribe((QActive*) me, ASETK_RECEIVE_COMMAND);
#endif
  }
    return Q_TRAN(&DebugSSrv_DeActive);
}

/**
* active state function in which debug server stay while process all requests
* @param me - pointer to server instance
* @param e - signal event
*/
QState DebugSSrv_Ready(cDebugSSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        DebugSSrv_ResetInBuf(me);
        DebugSSrv_ResetOutBuf(me);
#ifdef PT_I2C_DEBUG
        /* I2C1/2 only Ctor on debug server, but not on ble server,
         * otherwise it will duplicate xtor
        */
        if(DEBUG_SRV_ID == me->config.srv_id)
        {
            I2CDrv_Ctor(&dbgI2cObj1,(tI2CDevice*)getDevicebyIdAndType(DBG_I2C1_ID, I2C_DEV_TYPE, NULL));
            I2CDrv_Ctor(&dbgI2cObj2,(tI2CDevice*)getDevicebyIdAndType(DBG_I2C2_ID, I2C_DEV_TYPE, NULL));
        }
#endif
        return Q_RET_HANDLED;
    }
    case CMD_START_READ_TIMEOUT_SIG:
    {
        QTimeEvt_disarm(TIME_EVT_OF(me)); // disarm befor arm
        QTimeEvt_armX(TIME_EVT_OF(me), GET_TICKS_IN_MS(READ_TIMEOUT_MS), 0);
        return Q_RET_HANDLED;
    }
    case DEBUG_TIMEOUT_SIG:
    {
        DebugSSrv_ResetInBuf(me);
        return Q_RET_HANDLED;
    }
#ifdef TP_MONITOR_ON_OFF_CONTROL
    case TPMONITOR_ENABLE_SIG:
    {
        TpMonitorCtlEvt *p_ctl_evt;
        p_ctl_evt = (TpMonitorCtlEvt *)e;
        tp_monitor_enable = (bool)(p_ctl_evt->enable);
        if( tp_monitor_enable )
        {   // let mainapp the show version to TP_Monitor tool.
            p_ctl_evt = Q_NEW(TpMonitorCtlEvt, DISPLAY_DEBUG_REQ_SIG);
            SendToServer(MAIN_APP_ID, (QEvt*)p_ctl_evt);
        }
        return Q_RET_HANDLED;
    }
#endif
    case CMD_READY_CALLBACK_SIG:
    { /*fill up meta-data from message which saved in input buffer */
        QTimeEvt_disarm(TIME_EVT_OF(me)); // disarm reading timeout timer
        me->dmsg.signal = (eSignal)me->uartRxBuf[SIG_IDX];
        me->dmsg.target_srv_id = (ePersistantObjID)me->uartRxBuf[SRVID_IDX];

        if (DebugSSrv_CheckCRC(&me->uartRxBuf[0], me->dmsg.msg_size))
        {
            DebugSSrv_ParseAndRun(me);
        }
        else
        { //TODO: send back system signal about crc error
          DebugSnkyResp* error_resp = Q_NEW(DebugSnkyResp, DEBUG_RESP_SIG);
          error_resp->evtReturn = RET_FAIL;
          SendToServer(me->config.srv_id, (QEvt*)error_resp);
        }
            DebugSSrv_ResetInBuf(me);
            DebugSSrv_ResetOutBuf(me);
        return Q_RET_HANDLED;
    }
    case SETTING_REQ_SIG:
      {
        SettingReqEvt* pReq = (SettingReqEvt*)e;
        uint32_t value;
        if (pReq->sender)
        {
            SettingRespEvt* pResp = Q_NEW(SettingRespEvt, SETTING_RESP_SIG);
            pResp->evtReturn = RET_SUCCESS;
#ifdef DEBUG_BATT_INFO
            tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
            pResp->batt_info.intBatteryVol = battInfo.voltage.intBatteryVol;
#ifdef EXTERNAL_BATTERY
            pResp->batt_info.extBatteryVol = battInfo.voltage.extBatteryVol;
#endif
            pResp->batt_info.dcPlugInVoltage = battInfo.inputSourceState.dcPlugInVoltage;
            pResp->batt_info.chargerState = battInfo.chargerState;
#endif
#ifdef HAS_BLUETOOTH
            value = *(uint32_t*)Setting_Get(SETID_BT_STATUS);
            pResp->btStatus = (eBtStatus)value;
#endif
#ifdef PRODUCT_VERSION_MCU
            char* mcuVersion = PRODUCT_VERSION_MCU;
            memset((uint8*)&pResp->mcuVer[0], 0, VERSTR_SIZE);
            memcpy((uint8*)&pResp->mcuVer[0], (uint8*)mcuVersion, strlen(mcuVersion));
#endif
#ifdef PRODUCT_VERSION_DSP
            char* dspVersion = PRODUCT_VERSION_DSP;
            memset((uint8*)&pResp->dspVer[0], 0, VERSTR_SIZE);
            memcpy((uint8*)&pResp->dspVer[0], (uint8*)dspVersion, strlen(dspVersion));
#endif
#ifdef HAS_GPIO_JACK_IN_DETECT
            bool jackInStatus = *(bool*)Setting_Get(SETID_IS_AUXIN_PLUG_IN);
            pResp->jackInStatus = jackInStatus;
#endif
#ifdef HAS_MUSIC_STATUS_INFO
            bool isMusicPlaying = *(bool*)Setting_Get(SETID_MUSIC_DET);
            pResp->isMusicPlaying = isMusicPlaying;
#endif
#ifdef HAS_AUDIO_SOURCE_INFO
            uint8 audioSource = *(uint8*)Setting_Get(SETID_AUDIO_SOURCE);
            pResp->audioSource = audioSource;
#endif
            QACTIVE_POST(pReq->sender, (QEvt*)pResp, me);
        }
        return Q_RET_HANDLED;
      }
#ifdef HW_GPIO_DEBUG
    case DEBUG_GPIO_REQ_SIG:
      {
          HwGpioDebugReqEvt* req = (HwGpioDebugReqEvt*)e;
          if (req->mode == IO_PORT_WRITE)
          {
              GpioDrv_DirectPinAccessSet(req->port, req->bit, req->action);
          }
          HwGpioDebugRespEvt* resp = Q_NEW(HwGpioDebugRespEvt, DEBUG_GPIO_RESP_SIG);
          resp->evtReturn = RET_SUCCESS;
          resp->value = GpioDrv_DirectPinAccessRead(req->port, req->bit, req->direction);
          req->sender = (QActive*)me;
          SendToServer(DEBUG_SRV_ID, (QEvt*)resp);
         return Q_RET_HANDLED;
      }
#endif
#ifdef PT_ADC_DEBUG
    case DEBUG_ADC_REQ_SIG:
      {
         int32 result = 0;
         DbgAdcReqEvt* req = (DbgAdcReqEvt*)e;
         DbgAdcRespEvt* resp = Q_NEW(DbgAdcRespEvt, DEBUG_ADC_RESP_SIG);

         resp->port = req->port;
         resp->bit = req->bit;
         result = ADCDrv_GetAdcRawDataByPortBit(req->port, req->bit);
         if (result >= 0)
         {
              resp->value = result;
              resp->evtReturn = RET_SUCCESS;
         }
         else
         {
              resp->value = ADC_READ_FAIL;
              resp->evtReturn = RET_FAIL;
         }
         SendToServer(DEBUG_SRV_ID, (QEvt*)resp);
         return Q_RET_HANDLED;
      }
#endif
#ifdef PT_I2C_DEBUG
    case DEBUG_I2C_REQ_SIG:
      {
         eTpRet ret;
         DbgI2CPTReqEvt* req = (DbgI2CPTReqEvt*)e;
         if (req->mode == I2C_READ)
         {
            DbgI2CPTRespEvt* resp = Q_NEW(DbgI2CPTRespEvt, DEBUG_I2C_RESP_SIG);

            resp->mode = I2C_READ;
            resp->devAddr = req->devAddr;
            resp->regAddr = req->regAddr;
            resp->regAddrLen = req->regAddrLen;
            resp->length = req->length;

            tI2CDevice  ti2cdev;
            ti2cdev.i2cMode = I2C_MASTER_MODE;
            ti2cdev.pvSlaveCallback = NULL;
            ti2cdev.devAddress = req->devAddr;
            ti2cdev.channel = req->channel;
            ti2cdev.regAddrLen = req->regAddrLen;

            /* Note this baudRate is dummy value, the following i2c code (read/write)
             * do not care about baudRate
             */
            ti2cdev.baudRate = 350;

            tI2CMsg i2cMsg =
            {
                .devAddr = req->devAddr,
                .regAddr = req->regAddr,
                .length  = req->length,
                .pMsg    = (uint8*)&(resp->data[0]),
            };
            if (req->channel == I2C_CHANNEL_ONE)
            {
                dbgI2cObj1.pConfig = &ti2cdev;
                ret = I2CDrv_MasterRead(&dbgI2cObj1, &i2cMsg);
                resp->channel = I2C_CHANNEL_ONE;
            }
            else
            {
                dbgI2cObj2.pConfig = &ti2cdev;
                ret = I2CDrv_MasterRead(&dbgI2cObj2, &i2cMsg);
                resp->channel = I2C_CHANNEL_TWO;
            }
            if (ret == TP_SUCCESS)
            {
                resp->evtReturn = RET_SUCCESS;
            }
            else
            {
                resp->evtReturn = RET_FAIL;
            }
            SendToServer(DEBUG_SRV_ID, (QEvt*)resp);
         }
         else
         {
            uint8 wdat[I2C_DATA_MAX_SIZE + 2];
            switch (req->regAddrLen)
            {
             case REG_LEN_8BITS:
                wdat[0] = (uint8)req->regAddr;
                memcpy(&wdat[1], &req->data[0], req->length);
                break;
             case REG_LEN_16BITS:
                wdat[0] = req->regAddr >> 8;
                wdat[1] = req->regAddr & 0x00FF;
                memcpy(&wdat[2], &req->data[0], req->length);
               break;
                default:
                ASSERT(0);
            }
            tI2CMsg i2cMsg =
            {
                .devAddr = req->devAddr,
                .regAddr = NULL,
                .length  = req->length + req->regAddrLen + 1,
                .pMsg    = &wdat[0],
            };
            if (req->channel == I2C_CHANNEL_ONE)
            {
                ret = I2CDrv_MasterWrite(&dbgI2cObj1, &i2cMsg);
            }
            else
            {
                ret = I2CDrv_MasterWrite(&dbgI2cObj2, &i2cMsg);
            }
            ASSERT(ret==TP_SUCCESS);
         }
         return Q_RET_HANDLED;
      }
#endif
	case SYSTEM_SLEEP_REQ_SIG:
    {
        CommonReqEvt* pReq = (CommonReqEvt*)e;
        CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
        return Q_TRAN(&DebugSSrv_DeActive);
    }
    case Q_EXIT_SIG:
    {
        return Q_RET_HANDLED;
    }
    default:/* all other signals, if they registered in dbg_sig_evt_size_map[],
               will be packed and forwarded out to debug tool*/
      if (e->sig > Q_USER_SIG)
      {
#ifdef TP_MONITOR_ON_OFF_CONTROL
          if( tp_monitor_enable )
#endif
          DebugSSrv_HandleRespMsg(me, e);
          return Q_RET_HANDLED;
      }
        break;
    }
    return Q_SUPER(&QHsm_top);
}
/**
* deactive state, debug server switch to this state when receive SYSTEM_SLEEP_RESP_SIG
* signal from Controller. server is not process any signals in this state, unless its:
* - SYSTEM_ACTIVE_RESP_SIG signal from Controller, which request server switch back to active state;
* - CMD_WAKEUP_SIG signal, sends by uartWakeUpCallback() function and initiate system wake up by simulation
*  pressing "POWER_KEY" button
* @param me - pointer to server instance
* @param e - signal event
*/
QState DebugSSrv_DeActive(cDebugSSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
#ifdef ENABLE_WAKEUP_BY_UART
        bIsAllowToWakeUp = TRUE;
        UartDrv_EnableWakeUp(&me->p_debug_dev);
#else
        /* shutdown uart to save power if enable_wakeUp_by_uart is not define */
        DebugSSrv_InputSourceXtor(me);
#endif
#ifdef PT_I2C_DEBUG
        /* I2C1/2 only Ctor on debug server, but not on ble server,
         * otherwise it will duplicate xtor
        */
        if(DEBUG_SRV_ID == me->config.srv_id)
        {
            I2CDrv_Xtor(&dbgI2cObj1);
            I2CDrv_Xtor(&dbgI2cObj2);
        }
#endif
        return Q_RET_HANDLED;
    }
#ifdef ENABLE_WAKEUP_BY_UART
    case CMD_WAKEUP_SIG:
    { /*simulate "POWER_KEY" pressing by publishing according KEY_STATE_SIG */
        KeyStateEvt* ke = Q_NEW(KeyStateEvt, KEY_STATE_SIG);
        ke->keyEvent = KEY_EVT_SHORT_PRESS;
        ke->keyId = POWER_KEY;
        QF_PUBLISH((QEvt*)ke, me);
        return Q_RET_HANDLED;
    }
#endif
    case SYSTEM_ACTIVE_REQ_SIG:
    {
#ifdef ENABLE_WAKEUP_BY_UART
        bIsAllowToWakeUp = FALSE;
#else
        DebugSSrv_InputSourceCtor(me);
#endif
        CommonReqEvt* pReq = (CommonReqEvt*) e;
        CommonEvtResp((QActive*) me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
        return Q_TRAN(&DebugSSrv_Ready);
    }
    default:
        break;
    }
    return Q_SUPER(&QHsm_top);
}


/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/**
 * debug server input source constructor - create uart driver instance
 * create tx,rx ringbuffer instance and register uart and wakeup (if need it)
 * callback functions
 * @param me - pointer to server instance
 */
static void DebugSSrv_InputSourceCtor(cDebugSSrv * const me)
{
    RingBuf_Ctor(&me->txBuf, me->uartTxBuf, DBG_UART_TX_BUF_SIZE);
    RingBuf_Ctor(&me->rxBuf, me->uartRxBuf, DBG_UART_RX_BUF_SIZE);
    tUARTDevice* ptrUartDevice = (tUARTDevice*)getDevicebyId(me->config.source_device_id, NULL);
    UartDrv_Ctor(&me->p_debug_dev, ptrUartDevice, &me->txBuf, &me->rxBuf);
    meDebugSSrv[ptrUartDevice->uartId] = me;

    UartDrv_RegisterRxCallback(&me->p_debug_dev, uartRxCallback);
#ifdef ENABLE_WAKEUP_BY_UART
    UartDrv_RegisterWakeUpCallback(&me->p_debug_dev, uartWakeUpCallback);
    bIsAllowToWakeUp = FALSE;
#endif
}
/**
 * debug server input source destructor destrot uart driver and ringbuffers objects
 * to save power, while switching into deactive state
 * @param me - pointer to server instance
 */
static void DebugSSrv_InputSourceXtor(cDebugSSrv * const me)
{
    UartDrv_Xtor(&me->p_debug_dev);
    RingBuf_Xtor(&me->txBuf);
    RingBuf_Xtor(&me->rxBuf);
}
/**
* function reset server buffer for outcoming data(where server build formated message
* for sending out to debug tool) and uart ring buffer for outcoming data
* @param me - pointer to server instance
*/
static void DebugSSrv_ResetOutBuf(cDebugSSrv * const me)
{
  memset( me->out_buf_byte_stream, 0, sizeof(me->out_buf_byte_stream) ); RingBuf_Reset(&me->txBuf);
}
/**
* call back function called from uart ISR function, every time we've got
* new byte in uart port
* @param p - pointer to tUartRxData structure
*/
static void uartRxCallback(void* p)
{
  cDebugSSrv* me = meDebugSSrv[((tUartRxData*)p)->uart_port];
  ASSERT(me);
  if(me->in_buf_bs_idx == START_SIGN_IDX)
    {
       uint8 startSignature = ((tUartRxData*)p)->data;
       if (START_SIGN == startSignature )
       { /* since we've got message signature and starts receiveing data,
          this function sends to server signal command to start reading timeout timer*/
          me->in_buf_bs_idx++;
          bIsStartByteReceived = TRUE;
          DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_START_READ_TIMEOUT_SIG);
          QACTIVE_POST((QActive*)me, (QEvt*)cmdEvt, me);
       }
       else
       {
          DebugSSrv_ResetInBuf(me);
       }
       return;
    }

  if (me->in_buf_bs_idx == (SIZEMSB_IDX + 1)) //update msg size asap as we read SIZEMSB_IDX bytes of msg
  {
     me->dmsg.msg_size = me->uartRxBuf[SIZEMSB_IDX] << 8;
     me->dmsg.msg_size |= me->uartRxBuf[SIZELSB_IDX];
  }
  if ((me->in_buf_bs_idx <= me->dmsg.msg_size) && bIsStartByteReceived)
  {
     me->in_buf_bs_idx++;
     if (me->in_buf_bs_idx == me->dmsg.msg_size)
     { /*we got dmsg.msg_size bytes of msg - ready to unpack and forward the payload*/
        bIsStartByteReceived = FALSE;
        DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_READY_CALLBACK_SIG);
        QACTIVE_POST((QActive*)me, (QEvt*)cmdEvt, me);
     }
  }
}
#ifdef TP_MONITOR_OVER_TUNNEL
void DebugSSrv_UartRxCallbackEmulator(uint8* p, uint16 length)
{
    cDebugSSrv* me = meDebugSSrv[TP_UART_DEV_2];

    memcpy(me->uartRxBuf, p, length);

    me->dmsg.msg_size = me->uartRxBuf[SIZEMSB_IDX] << 8;
    me->dmsg.msg_size |= me->uartRxBuf[SIZELSB_IDX];

    DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_READY_CALLBACK_SIG);
    QACTIVE_POST((QActive*)me, (QEvt*)cmdEvt, me);
}
#endif
#ifdef ENABLE_WAKEUP_BY_UART
/**
* if enable_wakeup_by_uart is define, this function will be register as callback function,
* which will be called, when wakeup byte will arrive in uart
*/
static void uartWakeUpCallback()
{
  cDebugSSrv* me = meDebugSSrv[0]; // we'll send to first instance
  ASSERT(me);
  if (bIsAllowToWakeUp)
  {
      DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_WAKEUP_SIG);
      SendToServer(me->config.srv_id, (QEvt*) cmdEvt);
      bIsAllowToWakeUp = FALSE;
  }
}
#endif

/*
function check signal type:
if signal < MAX_SIG:
check by signal group:
Q_USER_SIG..MAX_PUB_SIG : indication signal
MAX_PUB_SIG..MAX_RESP_SIG : response signal
MAX_RESP_SIG..MAX_SIG : request signal

if signal > MAX_SIG,- this is private signal
and signal type defined in mapping table in AppPrivSig.Config

*/
static eSignalType DebugSSrv_GetSignalType(cDebugSSrv * const me, uint8 sig)
{
    if (sig > MAX_SIG)
    {
#ifdef HAS_APP_PRIVATE_SIG
      {
        uint8 i;
        for (i = 0; i < APP_PRIV_SIG_NUM_MAX; i++)
        {
            if (app_priv_sig_map[i].appPrivSig == sig)
            {
                return app_priv_sig_map[i].sigType;
            }
        }
      }
#endif
#if defined(TP_MONITOR_HAS_PRIVATE_SIGNAL) || defined(TP_MONITOR_ON_OFF_CONTROL)
        // all > MAX_SIG set as REQ_SIG
        return REQ_EVT_SIG;
#else
        return INVALID_EVT_SIG;
#endif
    }
    else
    {
        if (MAX_PUB_SIG > sig) /*its indication signal, so publish it*/
        {
            return IND_EVT_SIG;
        }
        /*me->dmsg.signal will not be changed when response signal*/
        else if((MAX_PUB_SIG < sig) && (MAX_RESP_SIG > sig))
        {/* resp signal, directly send to target srv*/
            return RESP_EVT_SIG;
        }
        else /*req signal, directly send to target srv, with replacing sender field*/
        {
            return REQ_EVT_SIG;
        }
    }
}


/**
* function create QP signal from data, receive in uart ringbuffer
* and select deliver way according signal type(indication, response or request)
* @param me - pointer to server instance
*/
#ifdef HAS_STRIPPED_OUT_DBG_MSG
static void DebugSSrv_ParseAndRun(cDebugSSrv * const me)
{
    uint8* ptr_src;
    uint8* ptr_dest;
    QEvt* piratube;
    DebugSSrv_ResetOutBuf(me);

    ptr_src = (uint8*)&me->uartRxBuf[DATASTART_IDX];

    eSignalType sigType = DebugSSrv_GetSignalType(me, me->dmsg.signal);

    switch(sigType)
    {
    case REQ_EVT_SIG:
      {
          ASSERT((me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt) + sizeof(QActive*)) <= SIZE_OF_LARGE_EVENTS);

          piratube = (QEvt *)QF_newX_((QEvtSize)(me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt) + sizeof(QActive*)), (uint16_t)0,  me->dmsg.signal);
          ptr_dest = (uint8*)piratube;
          ptr_dest += sizeof(QEvt); // shift to avoid overwrite header

          memcpy (ptr_dest, (uint8*)&me, sizeof(QActive*)); //fill sender field with QActive pointer to DebugSrv
          ptr_dest += sizeof(QActive*);

          memcpy(ptr_dest, ptr_src, me->dmsg.msg_size - DMSG_MIN_SIZE ); // fill up data evt

          SendToServer(me->dmsg.target_srv_id, piratube);
        break;
    }
    case RESP_EVT_SIG:
      {
              ASSERT((me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt)) <= SIZE_OF_LARGE_EVENTS);

              piratube = (QEvt *)QF_newX_((QEvtSize)(me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt)), (uint16_t)0,  me->dmsg.signal);
              ptr_dest = (uint8*)piratube;
              ptr_dest += sizeof(QEvt); // shift to avoid overwrite header

              memcpy(ptr_dest, ptr_src, me->dmsg.msg_size - DMSG_MIN_SIZE ); // fill up data evt

              SendToServer(me->dmsg.target_srv_id, piratube);
        break;
        }
    case IND_EVT_SIG:
        {
          ASSERT((me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt)) <= SIZE_OF_LARGE_EVENTS);

          piratube = (QEvt *)QF_newX_((QEvtSize)(me->dmsg.msg_size - DMSG_MIN_SIZE + sizeof(QEvt)), (uint16_t)0,  me->dmsg.signal);
              ptr_dest = (uint8*)piratube;
              ptr_dest += sizeof(QEvt); // shift to avoid overwrite header

              memcpy(ptr_dest, ptr_src, me->dmsg.msg_size - DMSG_MIN_SIZE );

          QF_PUBLISH(piratube, me);  /* so publish it*/
        break;
      }
    case INVALID_EVT_SIG:
    default:
      {
         ASSERT(0);
         break;
      }
         }

    DebugSSrv_ResetInBuf(me);
}

#else
static void DebugSSrv_ParseAndRun(cDebugSSrv * const me)
{
    uint8* ptr_src;
    uint8* ptr_dest;
    QEvt* piratube;
    DebugSSrv_ResetOutBuf(me);

#ifdef TP_MONITOR_ON_OFF_CONTROL
    if( ! tp_monitor_enable )
    {
        if( (me->uartRxBuf[SIG_IDX] != TPMONITOR_ENABLE_SIG) || (me->uartRxBuf[SRVID_IDX] != DEBUG_SRV_ID) )
        {
            DebugSSrv_ResetInBuf(me);
            return ;
        }
    }
#endif

    ptr_src = (uint8*)&me->uartRxBuf[DATASTART_IDX];
    ptr_src += sizeof(QEvt); // shift to avoid copy useless header
    piratube = (QEvt *)QF_newX_((QEvtSize)(me->dmsg.msg_size - DMSG_MIN_SIZE), (uint16_t)0,  me->dmsg.signal);
    ptr_dest = (uint8*)piratube;
    ptr_dest += sizeof(QEvt); // shift to avoid overwrite header
    memcpy(ptr_dest, ptr_src, me->dmsg.msg_size - DMSG_MIN_SIZE - sizeof(QEvt)); // fill up data evt

    eSignalType sigType = DebugSSrv_GetSignalType(me, me->dmsg.signal);
    switch(sigType)
    {
    case REQ_EVT_SIG:
    {
        memcpy (ptr_dest, (uint8*)&me, sizeof(QActive*)); //fill sender field with QActive pointer to DebugSrv
        SendToServer(me->dmsg.target_srv_id, piratube);
#ifdef HAS_DEBUG_RESP
        CommonEvtResp((QActive*)me, (QActive*)me, RET_SUCCESS, DEBUG_RESP_SIG);
#endif
        break;
     }
    case RESP_EVT_SIG:
         {
            SendToServer(me->dmsg.target_srv_id, piratube);
        break;
      }
    case IND_EVT_SIG:
      {
        QF_PUBLISH(piratube, me);
        break;
      }
    case INVALID_EVT_SIG:
    default:
      {
         break;
         }
    }

    DebugSSrv_ResetInBuf(me);
}
#endif
/**
* function reset uart ring buffer for incoming data and incoming data counter
* and set min message size
* @param me - pointer to server instance
*/
static void DebugSSrv_ResetInBuf(cDebugSSrv * const me)
{
    me->in_buf_bs_idx = 0;
    me->dmsg.msg_size = DMSG_MIN_SIZE;
    RingBuf_Reset(&me->rxBuf);
    bIsStartByteReceived = FALSE;
}
/**
* check package crc, uses CRC-CCITT (used in Xmodem, Bluetooth etc.)
* @param byte_stream - pointer to byte stream
* @param length - byte stream size
* @return TRUE  - if crc correct
*         FALSE - if crc is incorrect
*/
static bool DebugSSrv_CheckCRC( const unsigned char *byte_stream, unsigned length )
{
    unsigned short calc_crc = crc16( byte_stream, length-2 );
    unsigned short rec_crc = (((unsigned short)byte_stream[length-1])<<8) | byte_stream[length-2] ;
    if( rec_crc==calc_crc )
    {
        return TRUE;
    }
    return FALSE;
}

/**
* function return most significant byte (MSB)
* @param x - param value
* @return MSB value
*/
static unsigned char get_msb( unsigned short x ){ return (x>>8)&0xFF; }

/**
* function return least significant byte (LSB)
* @param x - param value
* @return MSB value
*/
static unsigned char get_lsb( unsigned short x ){ return x&0xFF; }

/**
* function calculate crc and return msb and lsb part
* @param byte_stream - pointer to byte stream
* @param length - byte stream size
* @return msb - pointer to msb value
* @return lsb - pointer to lsb value
*/
static void calc_crc_msb_lsb( const unsigned char *byte_stream, unsigned length, unsigned char *msb, unsigned char *lsb )
{
    unsigned short crc = crc16( byte_stream, length );
    *msb = get_msb(crc);
    *lsb = get_lsb(crc);
}
/**
* function pack message with size and CRC before sending out
* @param me - pointer to server instance
* @param bytestream_size - size of whole package to be transfered
*/
static void seal_msg(cDebugSSrv * const me, uint16 bytestream_size)
{
    uint8 crc_msb, crc_lsb;
    me->out_buf_byte_stream[SIZEMSB_IDX] = (bytestream_size & 0xFF00) >> 8;
    me->out_buf_byte_stream[SIZELSB_IDX] = (bytestream_size & 0x00FF);

    calc_crc_msb_lsb( me->out_buf_byte_stream, bytestream_size-2, &crc_msb, &crc_lsb );

    me->out_buf_byte_stream[bytestream_size-2] = crc_lsb;
    me->out_buf_byte_stream[bytestream_size-1] = crc_msb;

}
/**
* function build signal message in outcoming buffer, according format
* (please reference http://jenkins.tymphany.com/job/Doxygen_Tym_Plat/doxygen/tpsneak.html#messageformat)
* to send out through uart to debug tool
* signal event paylod size have to be registered in dbg_sig_evt_size_map[]
* @param me - pointer to server instance
* @param e - pointer to event
*/
#ifdef HAS_STRIPPED_OUT_DBG_MSG

static void DebugSSrv_HandleRespMsg(cDebugSSrv * const me, QEvt const * const e)
{
    uint8* ptr_src = (uint8*)e;
    me->out_buf_byte_stream[START_SIGN_IDX] = START_SIGN;
    me->out_buf_byte_stream[SIG_IDX] = e->sig;
    me->out_buf_byte_stream[SRVID_IDX] = 0; //ignored in resp msg to pc client

    uint16 sizeOfStrippedEvt = dbg_msg_size_map[e->poolId_ - 1];
    eSignalType sigType = DebugSSrv_GetSignalType(me, e->sig);
    switch(sigType)
    {
    case REQ_EVT_SIG: 
      ptr_src += sizeof(QEvt);
      ptr_src += sizeof(QActive*);
      sizeOfStrippedEvt -= sizeof(QEvt);
      sizeOfStrippedEvt -= sizeof(QActive*);
      break;
    case RESP_EVT_SIG:
      ptr_src += sizeof(QEvt);
      sizeOfStrippedEvt -= sizeof(QEvt);
      break;
    case IND_EVT_SIG:
      ptr_src += sizeof(QEvt);
      sizeOfStrippedEvt -= sizeof(QEvt);
      break;
    default:
      break;
    }
    memcpy(&me->out_buf_byte_stream[DATASTART_IDX], ptr_src, sizeOfStrippedEvt);

    seal_msg(me, sizeOfStrippedEvt + DMSG_MIN_SIZE);

    UartDrv_Write(&me->p_debug_dev, &me->out_buf_byte_stream[0], sizeOfStrippedEvt + DMSG_MIN_SIZE);
#ifdef TP_MONITOR_OVER_TUNNEL
    uint16 size = ((me->out_buf_byte_stream[SIZEMSB_IDX] << 8) & 0xFF) | me->out_buf_byte_stream[SIZELSB_IDX];

     AseNgSrv_FepAseTpMonitorEmulSend(&me->out_buf_byte_stream[0], size);
#endif
}

#else
static void DebugSSrv_HandleRespMsg(cDebugSSrv * const me, QEvt const * const e)
{
    me->out_buf_byte_stream[START_SIGN_IDX] = START_SIGN;
    me->out_buf_byte_stream[SIG_IDX] = e->sig;
    me->out_buf_byte_stream[SRVID_IDX] = 0; //ignored in resp msg to pc client

    memcpy(&me->out_buf_byte_stream[DATASTART_IDX], (uint8*)e, dbg_msg_size_map[e->poolId_ - 1]);

    seal_msg(me, dbg_msg_size_map[e->poolId_ - 1] + DMSG_MIN_SIZE);

    UartDrv_Write(&me->p_debug_dev, &me->out_buf_byte_stream[0], dbg_msg_size_map[e->poolId_ - 1] + DMSG_MIN_SIZE);
#ifdef TP_MONITOR_OVER_TUNNEL
    uint16 size = ((me->out_buf_byte_stream[SIZEMSB_IDX] << 8) & 0xFF) | me->out_buf_byte_stream[SIZELSB_IDX];

    AseNgSrv_FepAseTpMonitorEmulSend(&me->out_buf_byte_stream[0], size);
#endif
}
#endif
/**
* Interface function for printing comment string to debug tool
* http://jenkins.tymphany.com/job/Doxygen_Tym_Plat/doxygen/DebugSSrv.html#DebugSrvPrintComment
* @param pMsg - pointer to string
*/
void DebugSSrv_PrintStr(char* pMsg)
{
    uint8 size = strlen(pMsg);
    if (size > MAX_PRINTSTR_SIZE) { size = MAX_PRINTSTR_SIZE;  }

    DebugPrintEvt* print_msg = Q_NEW(DebugPrintEvt, DEBUG_SIG);
    memset(&print_msg->msg[0], 0, MAX_PRINTSTR_SIZE);
    memcpy(&print_msg->msg[0], pMsg, size);
    print_msg->size = size;
    print_msg->sender = NULL;
    SendToServer(DEBUG_SRV_ID, (QEvt*)print_msg);
}

void DebugSSrv_Printf(char* pMsg)
{
    uint8_t size;

#ifdef TP_MONITOR_ON_OFF_CONTROL
    if( ! tp_monitor_enable )
        return ;
#endif

    size = strlen(pMsg);
    if (size > MAX_PRINTSTR_SIZE) { size = MAX_PRINTSTR_SIZE;  }

    DebugPrintEvt* print_msg = Q_NEW(DebugPrintEvt, DEBUG_SIG);
    memset(&print_msg->msg[0], 0, MAX_PRINTSTR_SIZE);
    memcpy(&print_msg->msg[0], pMsg, size);
    print_msg->size = size;
    print_msg->sender = NULL;
    SendToServer(DEBUG_SRV_ID, (QEvt*)print_msg);
}

void DebugSSrv_AssertPrintf(char* pMsg)
{
    uint8_t size;

#ifdef TP_MONITOR_ON_OFF_CONTROL
    tp_monitor_enable = TRUE;
#endif

    size = strlen(pMsg);
    if (size > MAX_PRINTSTR_SIZE) { size = MAX_PRINTSTR_SIZE;  }

    DebugPrintEvt* print_msg = Q_NEW(DebugPrintEvt, DEBUG_SIG);
    memset(&print_msg->msg[0], 0, MAX_PRINTSTR_SIZE);
    memcpy(&print_msg->msg[0], pMsg, size);
    print_msg->size = size;
    print_msg->sender = NULL;
    SendToServer(DEBUG_SRV_ID, (QEvt*)print_msg);
}



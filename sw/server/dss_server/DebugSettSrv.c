/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Debug Setting Server
                  -------------------------

                  SW Module Document




@file        DebugSettSrv.c
@brief       Debug Setting server
@author      Dmitry.Abdulov
@date        2014-08-13
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-08-13     Dmitry.Abdulov
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "bsp.h"
#include "trace.h"
#include "DebugSettSrv.h"
#include "./DebugSettSrv_priv.h"
#include "controller.h"
#include "crc16.h"
#include "attachedDevices.h"
#include "ringbuf.h"
#include "UartDrv.h"
#include "StorageDrv.h"
#include "NvmDrv.h"

#include "trace.h"
#include "MainApp.h"

#include "DebugSettSrv.config"


#ifdef HAS_KEYS
#include "KeySrv.h"
#endif

#ifdef HAS_ALLPLAY
#include "AllPlaySrv.h"
#endif

#ifdef HAS_LEDS
#include "LedSrv.h"
#endif

#ifdef HAS_BLUETOOTH
#include "BluetoothSrv.h"
#endif

#ifdef HAS_AUDIO_CONTROL
#include "AudioSrv.h"
#endif

//Q_DEFINE_THIS_FILE

#define CAST_ME cDebugSettSrv * debugSettSrv = (cDebugSettSrv *) me;

/* private state functions */
static QState DebugSettSrv_Initial(cDebugSettSrv * const me, QEvt const * const e);
static QState DebugSettSrv_Ready(cDebugSettSrv * const me, QEvt const * const e);
static QState DebugSettSrv_DeActive(cDebugSettSrv * const me, QEvt const * const e);

static QState DebugSettSrv_BusyWrite(cDebugSettSrv * const me, QEvt const * const e);
static QState DebugSettSrv_BusyRead(cDebugSettSrv * const me, QEvt const * const e);


/*____________________________________________________________________________*/
static void uartRxCallback(void* p);
#ifdef ENABLE_WAKEUP_BY_UART
static void uartWakeUpCallback();
#endif
static void DebugSettSrv_ParseAndRun(cDebugSettSrv * const me);
static void DebugSettSrv_ResetInBuf();
static void DebugSettSrv_ResetOutBuf();
static void DebugSettSrv_InputSourceCtor();
static void DebugSettSrv_InputSourceXtor();
/*____________________________________________________________________________*/
static bool DebugSettSrv_CheckCRC( const unsigned char *byte_stream, unsigned length );
static void DebugSettSrv_HandleRespMsg(eSignal sig, uint8* pmsg);
/*____________________________________________________________________________*/

/*______________________________________________________________________________________________________________*/
/*
 *  START SIGNATURE  | SIG   | SRV ID | SIZE_LSB | SIZE_MSB | DATA0 | ... | CRC16_LSB | CRC16_MSB |
 *       |       |        |          |          |       |     |           |           |
 * ?	START SIGNATURE: (1 byte), package signature "0xAA"
 * ?	SIG(1 byte):  signal ID (one of from ?typedef enum {?}eSignal;?  please reference to ?tymphany_platform\sw\include\signals.h?)
 * ?	SRV_ID(1 byte): Target AO(active object)id(one of from ?typedef enum {?}eServerID;?  please reference to?tymphany_platform\sw\include\object_ids.h? )
 * ?	SIZE(2 bytes):  message size(size of byte stream)
 * ?	DATA(?):  encapsulated specific (according SIG)data structure
 * ?	CRC16: (2 bytes) uses CRC-CCITT (used in Xmodem, Bluetooth etc.)
 * http://en.wikipedia.org/wiki/Cyclic_redundancy_check.
 * Check your CRC here:
 * http://depa.usst.edu.cn/chenjq/www2/SDesign/JavaScript/CRCcalculation.htm
 * ex: CRC(0x01,0x02,0x03) -> 0x6131
 */
typedef enum
{
    START_SIGN_IDX,
    SIG_IDX,
    SRVID_IDX,
    SIZELSB_IDX,
    SIZEMSB_IDX,
    DATASTART_IDX,
}eDbgSnkyMsgIndx;

#define DMSG_MIN_SIZE   0x07

/* Internal event queue - Size as needed */
static QEvt const *DebugEvtQue[DBG_SRV_EVENT_Q_SIZE];

#define DBG_UART_TX_BUF_SIZE ((SIZE_OF_LARGE_EVENTS + DMSG_MIN_SIZE)* DBG_SRV_EVENT_Q_SIZE) + 1
#define DBG_UART_RX_BUF_SIZE (SIZE_OF_LARGE_EVENTS + DMSG_MIN_SIZE) + 1
static uint8 uartTxBuf[DBG_UART_TX_BUF_SIZE];
static uint8 uartRxBuf[DBG_UART_RX_BUF_SIZE];
static cRingBuf txBuf;
static cRingBuf rxBuf;

cNvmDrv nvmDrv;
cUartDrv  p_debug_dev;
#define CLI_OUTPUT_BUFFER_SIZE (SIZE_OF_LARGE_EVENTS + DMSG_MIN_SIZE)

#ifdef ENABLE_WAKEUP_BY_UART
static bool bIsAllowToWakeUp = FALSE;
#endif

static uint8 in_buf_bs_idx = 0;
static uint8 out_buf_byte_stream[CLI_OUTPUT_BUFFER_SIZE];



static tDbgSnkyMsgEvt dmsg;

static const uint16 dbg_sig_evt_size_map[] = {
#ifdef HAS_KEYS
  [KEY_DEBUG_REQ_SIG]               = sizeof(KeyDebugReqEvt),
  [KEY_DEBUG_RESP_SIG]              = sizeof(KeyDebugRespEvt),
  [KEY_STATE_SIG]                   = sizeof(KeyStateEvt),
#endif
#ifdef HAS_LEDS
  [LED_REQ_SIG]                     = sizeof(LedReqEvt),
  [LED_RESP_SIG]                    = sizeof(LedRespEvt),
#endif
#ifdef HAS_POWER_CONTROL
  [POWER_DEBUG_REQ_SIG]             = sizeof(PowerSrvDebugReqEvt),
  [POWER_DEBUG_RESP_SIG]            = sizeof(PowerSrvDebugRespEvt),
#endif
#ifdef HAS_ALLPLAY
  [ALLPLAY_STATE_SIG]               = sizeof(AllPlayStateIndEvt),
#endif
#ifdef HAS_BLUETOOTH
  [BT_REQ_SIG]                      = sizeof(BtCmdEvt),
  [BT_STATE_SIG]                    = sizeof(BtStatusEvt),
#endif
#ifdef HAS_AUDIO_CONTROL
  [AUDIO_SET_SIG]                   = sizeof(AudioSettEvt),
#endif
#ifdef HAS_BATTERY
  [POWER_SET_RESP_SIG]              = sizeof(PowerSrvSetRespEvt),
#endif

  [DEBUG_SIG]                       = sizeof(DebugPrintEvt),
  [DEBUG_RESP_SIG]                  = sizeof(DebugSnkyResp),
  [SETTING_RESP_SIG]                = sizeof(SettingRespEvt),
  [SYSTEM_STATE_SIG]                = sizeof(SystemStatusEvt),
  [SETTING_START_REQ_SIG]           = sizeof(SettingStartReqEvt),
  [SETTING_START_RESP_SIG]          = sizeof(SettingStartRespEvt),
  [SETTING_DATA_REQ_SIG]            = sizeof(SettingDataReqEvt),
  [SETTING_DATA_RESP_SIG]           = sizeof(SettingDataRespEvt),
  [SETTING_END_REQ_SIG]             = sizeof(SettingEndReqEvt),
  [SETTING_END_RESP_SIG]            = sizeof(SettingEndRespEvt),
#ifdef BT_NFC_PAIR
  [BT_NFC_IND_SIG]                  = sizeof(BtNfcEvt),
#endif
};
/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/

void DebugSettSrv_StartUp(cPersistantObj *me)
{
    DebugSettSrv_InputSourceCtor();
    StorageDrv_Ctor((cStorageDrv*)&nvmDrv, (tStorageDevice*)getDevicebyId(INT_FLASH_DEV_ID, NULL));

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&DebugSettSrv_Initial), DEBUG_TIMEOUT_SIG,
                     DebugEvtQue, Q_DIM(DebugEvtQue), DSS_SRV_ID);
}

void DebugSettSrv_ShutDown(cPersistantObj *me)
{
	/* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
    DebugSettSrv_InputSourceXtor();
}
/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState DebugSettSrv_Initial(cDebugSettSrv * const me, QEvt const * const e)
{
    /* Subscribe for need signals here */
    QActive_subscribe((QActive*) me, SYSTEM_STATE_SIG);
#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG); // use the macros!
#endif
#ifdef HAS_ALLPLAY
    QActive_subscribe((QActive*) me, ALLPLAY_STATE_SIG);
#endif
#ifdef HAS_BLUETOOTH
    QActive_subscribe((QActive*) me, BT_STATE_SIG);
#endif
#ifdef HAS_AUDIO_CONTROL
    QActive_subscribe((QActive*) me, AUDIO_MUSIC_DETECT_STATE_SIG);
    QActive_subscribe((QActive*) me, AUDIO_STATE_SIG);
#endif
    return Q_TRAN(&DebugSettSrv_DeActive);
}


static QState DebugSettSrv_Ready(cDebugSettSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        DebugSettSrv_ResetInBuf();
        DebugSettSrv_ResetOutBuf();
        return Q_RET_HANDLED;
    }
    case CMD_START_READ_TIMEOUT_SIG:
    {
        QTimeEvt_armX(TIME_EVT_OF(me), GET_TICKS_IN_MS(READ_TIMEOUT_MS), 0);
        return Q_RET_HANDLED;
    }
    case DEBUG_TIMEOUT_SIG:
    {
        DebugSettSrv_ResetInBuf();
        return Q_RET_HANDLED;
    }
    case CMD_READY_CALLBACK_SIG:
    { /*fill up meta-data from message which saved in input buffer */
        QTimeEvt_disarm(TIME_EVT_OF(me)); // disarm reading timeout timer
        dmsg.seq =  uartRxBuf[START_SIGN_IDX];
        dmsg.signal = (eSignal)uartRxBuf[SIG_IDX];
        dmsg.target_srv_id = (ePersistantObjID)uartRxBuf[SRVID_IDX];
        if (DebugSettSrv_CheckCRC(&uartRxBuf[0], dmsg.msg_size))
        {
            DebugSettSrv_ParseAndRun(me);
        }
        else
        { //TODO: send back system signal about crc error
          DebugSnkyResp* error_resp = Q_NEW(DebugSnkyResp, DEBUG_RESP_SIG);
          error_resp->evtReturn = RET_FAIL;
          SendToServer(DSS_SRV_ID, (QEvt*)error_resp);
        }
            DebugSettSrv_ResetInBuf();
            DebugSettSrv_ResetOutBuf();
        return Q_RET_HANDLED;
    }
    case SETTING_REQ_SIG:
      {
        SettingReqEvt* pReq = (SettingReqEvt*)e;
            if (pReq->sender)
            {
                SettingRespEvt* pResp = Q_NEW(SettingRespEvt, SETTING_RESP_SIG);
#ifdef DEBUG_BATT_INFO
                tBatteryInfo battInfo = *(tBatteryInfo*)Setting_Get(SETID_BATT_INFO);
                pResp->batt_info.intBatteryVol = battInfo.voltage.intBatteryVol;
                pResp->batt_info.extBatteryVol = battInfo.voltage.extBatteryVol;
                pResp->batt_info.dcPlugInVoltage = battInfo.inputSourceState.dcPlugInVoltage;
                pResp->batt_info.chargerState = battInfo.chargerState;
#endif
#ifdef HAS_BLUETOOTH
                pResp->btStatus = *(eBtStatus*)Setting_Get(SETID_BT_STATUS);
#endif
#ifdef PRODUCT_VERSION_MCU
                char* mcuVersion = PRODUCT_VERSION_MCU;
                memcpy((uint8*)&pResp->mcuVer[0], (uint8*)mcuVersion, strlen(mcuVersion));
#endif
#ifdef PRODUCT_VERSION_DSP
                char* dspVersion = PRODUCT_VERSION_DSP;
                memcpy((uint8*)&pResp->dspVer[0], (uint8*)dspVersion, strlen(dspVersion));
#endif
                QACTIVE_POST(pReq->sender, (QEvt*)pResp, me);
            }
        return Q_RET_HANDLED;
      }
    case SETTING_START_REQ_SIG:
      {
        SettingStartReqEvt* pReq = (SettingStartReqEvt*) e;
        if (settingDB[pReq->settingId].attr & SETTING_ATTR_NVM)
        {
            nvmDrv.currAddr = (uint32)settingDB[pReq->settingId].p;
            me->pRequestor  = pReq->sender;
            me->currBuf     = 0;
            me->processed   = 0;
            me->resendCnt   = 0;

            // TODO: publish a signal to let everyone know setting server is busy

            // TODO: wait a timeout to make sure that everyone is agree to write something to flash
            // TODO: ask Miro for how to know the interaction between server if one is in special situation, wait, signal?
            // TODO: if it is in critical situation, don't save anything
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SETTING_START_RESP_SIG);
            if (pReq->direction == SETTING_DIRECTION_DOWNLOAD)
            {
                me->size = pReq->size;
                me->settingId = pReq->settingId;
                return Q_TRAN(&DebugSettSrv_BusyWrite);
            }
            else
            {
                me->size = settingDB[pReq->settingId].size;
                return Q_TRAN(&DebugSettSrv_BusyRead);
            }
        }
        return Q_RET_HANDLED;
      }
	case SYSTEM_SLEEP_REQ_SIG:
    {
        CommonReqEvt* pReq = (CommonReqEvt*)e;
        CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
        return Q_TRAN(&DebugSettSrv_DeActive);
    }
    case Q_EXIT_SIG:
    {
        return Q_RET_HANDLED;
    }
    default:
          if (e->sig > Q_USER_SIG)
          {
              DebugSettSrv_HandleRespMsg((eSignal)e->sig, (uint8*)e);
              return Q_RET_HANDLED;
          }
        break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState DebugSettSrv_DeActive(cDebugSettSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
#ifdef ENABLE_WAKEUP_BY_UART
        bIsAllowToWakeUp = TRUE;
        UartDrv_EnableWakeUp(&p_debug_dev);
#else
        DebugSettSrv_InputSourceXtor();
#endif
        return Q_RET_HANDLED;
    }
#ifdef ENABLE_WAKEUP_BY_UART
    case CMD_WAKEUP_SIG:
    {
        KeyStateEvt* ke = Q_NEW(KeyStateEvt, KEY_STATE_SIG);
        ke->keyEvent = KEY_EVT_SHORT_PRESS;
        ke->keyId = POWER_KEY;
        QF_PUBLISH((QEvt*)ke, me);
        return Q_RET_HANDLED;
    }
#endif
    case SYSTEM_ACTIVE_REQ_SIG:
    {
#ifdef ENABLE_WAKEUP_BY_UART
        bIsAllowToWakeUp = FALSE;
#else
        DebugSettSrv_InputSourceCtor();
#endif
        CommonReqEvt* pReq = (CommonReqEvt*) e;
        CommonEvtResp((QActive*) me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
        return Q_TRAN(&DebugSettSrv_Ready);
    }
    default:
        break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState DebugSettSrv_BusyWrite(cDebugSettSrv * const me, QEvt const * const e)
{
      switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;
        uint16 i    = 0;

        for (i=0; i <= me->size; i+=PAGE_SIZE)
        {
            nvmDrv.super_.ErasePage(pStorage, nvmDrv.currAddr + i);
        }
        return Q_RET_HANDLED;
    }
    case SETTING_START_REQ_SIG:
    {
        SettingDataReqEvt* pReq = (SettingDataReqEvt*) e;
        CommonEvtResp((QActive*)me, pReq->sender, RET_BUSY, SETTING_DATA_RESP_SIG);
        return Q_RET_HANDLED;
    }
    case SETTING_DATA_REQ_SIG:
    {
        SettingDataReqEvt* pReq = (SettingDataReqEvt*) e;
        cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;

        nvmDrv.super_.SetValue(pStorage, nvmDrv.currAddr,
                         pReq->data, SETTING_CHUNK_SIZE);
        nvmDrv.currAddr += SETTING_CHUNK_SIZE;
        me->processed   += SETTING_CHUNK_SIZE;
        CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SETTING_DATA_RESP_SIG);
        return Q_RET_HANDLED;
    }
    case SETTING_END_REQ_SIG:
    {
        SettingEndReqEvt* pReq = (SettingEndReqEvt*) e;
        cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;

        nvmDrv.super_.SetValue(pStorage, nvmDrv.currAddr,
                         pReq->data, pReq->rest_size);
        CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SETTING_END_RESP_SIG);

        SettingUpdateEvt* pUpdMsg = Q_NEW(SettingUpdateEvt, SETTING_UPDATE_SIG);
        pUpdMsg->setting_id = me->settingId;
        QF_PUBLISH((QEvt*)pUpdMsg, me);
        return Q_TRAN(&DebugSettSrv_Ready);
    }
    default:
        break;
    }
    return Q_SUPER(&DebugSettSrv_Ready);
}

static QState DebugSettSrv_BusyRead(cDebugSettSrv * const me, QEvt const * const e)
{
      switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;
        SettingDataReqEvt* pReq = Q_NEW(SettingDataReqEvt, SETTING_DATA_REQ_SIG);
        nvmDrv.super_.GetValue(pStorage, nvmDrv.currAddr,
                         pReq->data, SETTING_CHUNK_SIZE);
        QACTIVE_POST(me->pRequestor, (QEvt*)pReq, me);
        return Q_RET_HANDLED;
    }
    case SETTING_START_REQ_SIG:
    {
        SettingDataReqEvt* pReq = (SettingDataReqEvt*) e;
        CommonEvtResp((QActive*)me, pReq->sender, RET_BUSY, SETTING_DATA_RESP_SIG);
        return Q_RET_HANDLED;
    }
    case SETTING_DATA_RESP_SIG:
    {
        SettingDataRespEvt* pResp = (SettingDataRespEvt*) e;
        cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;

        if (pResp->evtReturn == RET_SUCCESS)
        {
            // if last data is success, iterate to send new packet of data
            nvmDrv.currAddr += SETTING_CHUNK_SIZE;
            me->processed   += SETTING_CHUNK_SIZE;
            me->resendCnt   = 0;
        }
        else
        {
            ++me->resendCnt;
            if (me->resendCnt > SETTING_RESEND_LIMIT)
            {
                // if reach the maximum number of resend
                return Q_TRAN(&DebugSettSrv_Ready);
            }
        }

        if (SETTING_CHUNK_SIZE <= me->size - me->processed)
        {
            SettingDataReqEvt* pReq = Q_NEW(SettingDataReqEvt, SETTING_DATA_REQ_SIG);
            nvmDrv.super_.GetValue(pStorage, nvmDrv.currAddr,
                                     pReq->data, SETTING_CHUNK_SIZE);
            QACTIVE_POST(me->pRequestor, (QEvt*)pReq, me);
        }
        else
        {
            SettingEndReqEvt* pReq = Q_NEW(SettingEndReqEvt, SETTING_END_REQ_SIG);
            pReq->rest_size = me->size - me->processed;
            nvmDrv.super_.GetValue(pStorage, nvmDrv.currAddr,
                                     pReq->data, pReq->rest_size);
            QACTIVE_POST(me->pRequestor, (QEvt*)pReq, me);
        }

        return Q_RET_HANDLED;
    }
    case SETTING_END_RESP_SIG:
    {
        SettingEndRespEvt* pResp = (SettingEndRespEvt*) e;

        if (pResp->evtReturn != RET_SUCCESS)
        {
            ++me->resendCnt;
            if (me->resendCnt > SETTING_RESEND_LIMIT)
            {
                // if reach the maximum number of resend
                return Q_TRAN(&DebugSettSrv_Ready);
            }

            // if last packet of data is not successfully sent
            // resend the last packet of data
            // wait for another SETTING_END_RESP_SIG
            SettingEndReqEvt* pReq = Q_NEW(SettingEndReqEvt, SETTING_END_REQ_SIG);
            cStorageDrv *pStorage = (cStorageDrv *)&nvmDrv;

            pReq->rest_size = me->size - me->processed;
            nvmDrv.super_.GetValue(pStorage, nvmDrv.currAddr,
                                     pReq->data, pReq->rest_size);
            QACTIVE_POST(me->pRequestor, (QEvt*)pReq, me);
            return Q_RET_HANDLED;
        }
        // TODO: publish a signal to let everyone know setting server is idle
        return Q_TRAN(&DebugSettSrv_Ready);
    }
    default:
        break;
    }
    return Q_SUPER(&DebugSettSrv_Ready);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/**
 * debug server input source constructor - create uart driver instance
 * create tx,rx ringbuffer instance and register uart callback function
 */
static void DebugSettSrv_InputSourceCtor()
{
    RingBuf_Ctor(&txBuf, uartTxBuf, DBG_UART_TX_BUF_SIZE);
    RingBuf_Ctor(&rxBuf, uartRxBuf, DBG_UART_RX_BUF_SIZE);
    UartDrv_Ctor(&p_debug_dev, (tUARTDevice*) getDevicebyId(DEBUG_DEV_ID, NULL), &txBuf, &rxBuf);
    UartDrv_RegisterRxCallback(&p_debug_dev, uartRxCallback);
#ifdef ENABLE_WAKEUP_BY_UART
    UartDrv_RegisterWakeUpCallback(&p_debug_dev, uartWakeUpCallback);
#endif
}
/**
 * debug server input source destructor destrot uart driver and ringbuffers objects
 * to save power, while switching into deactive state
 */
static void DebugSettSrv_InputSourceXtor()
{
    UartDrv_Xtor(&p_debug_dev);
    RingBuf_Xtor(&txBuf);
    RingBuf_Xtor(&rxBuf);
}

static void DebugSettSrv_ResetOutBuf()
{
  memset( out_buf_byte_stream, 0, sizeof(out_buf_byte_stream) ); RingBuf_Reset(&txBuf);
}

static void uartRxCallback(void* p)
{
    if(in_buf_bs_idx == START_SIGN_IDX)
    {
       uint8 startSignature = ((tUartRxData*)p)->data;
       if (START_SIGN == startSignature )
       {
         in_buf_bs_idx++;
         DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_START_READ_TIMEOUT_SIG);
         SendToServer(DSS_SRV_ID, (QEvt*) cmdEvt);
       }
       return;
    }
    if (in_buf_bs_idx == (SIZEMSB_IDX + 1)) //update msg size asap as we read SIZEMSB_IDX bytes of msg
    {
        dmsg.msg_size = uartRxBuf[SIZEMSB_IDX] << 8;
        dmsg.msg_size |= uartRxBuf[SIZELSB_IDX];
    }
    if (in_buf_bs_idx <= dmsg.msg_size)
    {
        in_buf_bs_idx++;
        if (in_buf_bs_idx == dmsg.msg_size)
        { /*we got dmsg.msg_size bytes of msg - ready to unpack and forward the payload*/
            DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_READY_CALLBACK_SIG);
            SendToServer(DSS_SRV_ID, (QEvt*) cmdEvt);
        }
    }
}
#ifdef ENABLE_WAKEUP_BY_UART
static void uartWakeUpCallback()
{
  if (bIsAllowToWakeUp)
  {
       DebugSettSrv_ResetInBuf();
       DebugSettSrv_ResetOutBuf();
       DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_WAKEUP_SIG);
       SendToServer(DSS_SRV_ID, (QEvt*) cmdEvt);
       bIsAllowToWakeUp = FALSE;
  }
}
#endif
static void DebugSettSrv_ParseAndRun(cDebugSettSrv * const me)
{
    uint8* ptr_src;
    uint8* ptr_dest;
    QEvt* piratube;
    DebugSettSrv_ResetOutBuf();

    ptr_src = (uint8*)&uartRxBuf[DATASTART_IDX];
    ptr_src += sizeof(QEvt); // shift to avoid copy useless header
    piratube = (QEvt *)QF_newX_((QEvtSize)(dmsg.msg_size - DMSG_MIN_SIZE), (uint16_t)0,  dmsg.signal);
    ptr_dest = (uint8*)piratube;
    ptr_dest += sizeof(QEvt); // shift to avoid overwrite header
    memcpy(ptr_dest, ptr_src, dmsg.msg_size - DMSG_MIN_SIZE - sizeof(QEvt)); // fill up data evt
    if (MAX_PUB_SIG > dmsg.signal) /* publish signal*/
    {
        QF_PUBLISH(piratube, me);
    }
    else if((MAX_PUB_SIG < dmsg.signal) && (MAX_RESP_SIG > dmsg.signal)) /* resp signal*/
         {
        SendToServer(dmsg.target_srv_id, piratube);
    }
         else /*req signal*/
    {
            memcpy (ptr_dest, (uint8*)&me, sizeof(QActive*)); //fill sender field with QActive pointer to DebugSrv
            SendToServer(dmsg.target_srv_id, piratube);
    }
    DebugSettSrv_ResetInBuf();
}

static void DebugSettSrv_ResetInBuf()
{
    in_buf_bs_idx = 0;
    dmsg.msg_size = DMSG_MIN_SIZE;
    RingBuf_Reset(&rxBuf);
}

static bool DebugSettSrv_CheckCRC( const unsigned char *byte_stream, unsigned length )
{
    unsigned short calc_crc = crc16( byte_stream, length-2 );
    unsigned short rec_crc = (((unsigned short)byte_stream[length-1])<<8) | byte_stream[length-2] ;
    if( rec_crc==calc_crc )
    {
        return TRUE;
    }
    return FALSE;
}

static unsigned char get_msb( unsigned short x ){ return (x>>8)&0xFF; }

static unsigned char get_lsb( unsigned short x ){ return x&0xFF; }

static void calc_crc_msb_lsb( const unsigned char *byte_stream, unsigned length, unsigned char *msb, unsigned char *lsb )
{
    unsigned short crc = crc16( byte_stream, length );
    *msb = get_msb(crc);
    *lsb = get_lsb(crc);
}
/* pack message with size and CRC */
static void seal_msg(uint16 bytestream_size)
{
    uint8 crc_msb, crc_lsb;
    out_buf_byte_stream[SIZEMSB_IDX] = (bytestream_size & 0xFF00) >> 8;
    out_buf_byte_stream[SIZELSB_IDX] = (bytestream_size & 0x00FF);

    calc_crc_msb_lsb( out_buf_byte_stream, bytestream_size-2, &crc_msb, &crc_lsb );

    out_buf_byte_stream[bytestream_size-2] = crc_lsb;
    out_buf_byte_stream[bytestream_size-1] = crc_msb;

}

static void DebugSettSrv_HandleRespMsg(eSignal sig, uint8* pmsg)
{
    uint16 size = dbg_sig_evt_size_map[sig];
    if (size)
    {
        out_buf_byte_stream[START_SIGN_IDX] = START_SIGN;
        out_buf_byte_stream[SIG_IDX] = sig;
        out_buf_byte_stream[SRVID_IDX] = 0; //ignored in resp msg to pc client

        memcpy(&out_buf_byte_stream[DATASTART_IDX], pmsg, size);

        seal_msg(size + DMSG_MIN_SIZE);

        UartDrv_Write(&p_debug_dev, &out_buf_byte_stream[0], size + DMSG_MIN_SIZE);
    }
}

void DebugSettSrv_PrintStr(char* pMsg)
{
    uint8 size = strlen(pMsg);
    if (size > MAX_PRINTSTR_SIZE) { size = MAX_PRINTSTR_SIZE;  }

    DebugPrintEvt* print_msg = Q_NEW(DebugPrintEvt, DEBUG_SIG);
    memcpy(&print_msg->msg[0], pMsg, size);
    print_msg->size = size;
    print_msg->sender = NULL;
    SendToServer(DSS_SRV_ID, (QEvt*)print_msg);
}
/*__________setting functions____________________*/
void SettingSrv_InitDB(void)
{
    uint16 i;

    for (i=0; i < SETID_MAX; i++)
    {
        // mark all the entities are not being set at start-up
        TYM_CLR_BIT(settingDB[i].attr, SETTING_ATTR_SET);
    }
}

/* @brief       Check if the ID is valid
 * @param[in]   id      ID of the entity to be obtained
 * @return      TRUE when the entity ID is valid
 */
bool Setting_IsIdValid(eSettingId id)
{
    bool ret = settingDB[id].attr & SETTING_ATTR_VALID ? TRUE : FALSE;
    return ret;
}

/* @brief       Check if the entity is ready to get
 * @param[in]   id      ID of the entity to be obtained
 * @return      TRUE when the entity ID is valid
 */
bool Setting_IsReady(eSettingId id)
{
    bool ret = NULL;
    if (Setting_IsIdValid(id))
    {
        ret = settingDB[id].attr & SETTING_ATTR_SET ? TRUE : FALSE;
    }
    return ret;
}

/* @brief       Get the desired information value
 * @param[in]   id      ID of the entity to be obtained
 * @retval      void*   pointer to the desired object
 */
const void* Setting_Get(eSettingId id)
{
    void* ret = NULL;
    if (Setting_IsReady(id))
    {
        ret = settingDB[id].p;
    }
    else
    {
        ASSERT(0);
    }

    return ret;
}

/* @brief       Save the information to setting
 * @param[in]   id      ID of the entity to be set
 * @param[in]   pValue  the pointer to the target value to be set
 */
void Setting_Set(eSettingId id, const void* pValue)
{
    if(Setting_IsIdValid(id))
    {
        memcpy(settingDB[id].p, pValue, settingDB[id].size);
        // mark the entity as set
        TYM_SET_BIT(settingDB[id].attr, SETTING_ATTR_SET);
    }
}

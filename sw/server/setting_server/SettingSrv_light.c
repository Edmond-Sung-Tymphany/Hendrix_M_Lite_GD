/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Setting Server
                  -------------------------

                  SW Module Document




@file        SettingSrv.c
@brief       This implement the server for all settings store and retrieve
@author      Wesley Lee
@date        2014-06-09
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-06-09     Wesley Lee
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

#include "stm32f0xx_flash.h"
#include "product.config"

//#include "./SettiResetIRConditionsngSrv_priv.h"
#include "StorageDrv.h"
#ifdef HAS_NVM
#include "NvmDrv.h"
#endif
#include "controller.h"
#include "trace.h"
#include "bsp.h"
#include "SettingSrv_light_priv.h"
#include "SettingSrv.config"

#ifndef SETTING_SRV_DEBUG_ENABLE
#undef TP_PRINTF
#define TP_PRINTF(...)
#endif


cNvmDrv* pNvmObj;
/* SETTING_HAS_ROM_DATA should be defined if there is ROM data
 *  - direct write data from Debug Server, i.e. TP_Sneak
 *  - writing flash with delay,
 */


/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/

/* @brief       Get the ROM address of the setting ID
 * @param[in]   id      ID of the entity to be obtained
 * @return      ROM address
 */
static uint32 getRomAddr(eSettingId id)
{
    uint32 ret = NULL;
    uint16 i = 0;
    for ( ; i<ArraySize(settingRomMap); i++)
    {
        if (settingRomMap[i].id == id)
        {
            ret = settingRomMap[i].addr;
            break;
        }
    }
    return ret;
}

/*****************************************************************************************************************
 *
 * public functions
 *
 *****************************************************************************************************************/

/* @brief       Check if the ID is valid
 * @param[in]   id      ID of the entity to be obtained
 * @return      TRUE when the entity ID is valid
 */
bool Setting_IsIdValid(eSettingId id)
{
    return (settingDB[id].attr & SETTING_ATTR_VALID);
}

/* @brief       Check if the entity in RAM is ready to get
 * @param[in]   id      ID of the entity to be obtained
 * @return      TRUE when the entity ID is valid
 */
bool Setting_IsReady(eSettingId id)
{
    bool ret = FALSE;
    if (Setting_IsIdValid(id))
    {
        ret = settingDB[id].attr & SETTING_ATTR_SET ? TRUE : FALSE;
    }
    return ret;
}

/* @brief       Get the desired information value
 * @param[in]   id      ID of the entity to be obtained
 * @retval      void*   pointer to the desired object
 */
const void* Setting_Get(eSettingId id)
{
    void* ret = NULL;
    uint32 addr = getRomAddr(id);

    if (Setting_IsReady(id))
    {
        // if the value is avaliable in RAM
        ret = settingDB[id].p;
    }
    else if (addr)
    {
        // if the value is avaliable in ROM
        ret = (void*)addr;
    }
    else
    {
        ASSERT(0);
    }

    return ret;
}

/* @brief       Save the information to setting to RAM
 * @param[in]   id      ID of the entity to be set
 * @param[in]   pValue  the pointer to the target value to be set
 */
void Setting_Set(eSettingId id, const void* pValue)
{
    if(Setting_IsIdValid(id) && settingDB[id].p)
    {
        if (pValue != settingDB[id].p)
        {
            memcpy(settingDB[id].p, pValue, settingDB[id].size);
        }
        // mark the entity as set
        TYM_SET_BIT(settingDB[id].attr, SETTING_ATTR_SET);
    }
}

static bool Setting_ErasePage(uint32 addr)
{
    FLASH_Unlock();
    FLASH_Status s = FLASH_ErasePage(addr);
    FLASH_Lock();
    return (FLASH_GetStatus() == FLASH_COMPLETE);
}


bool Setting_ReadWords(uint32 addr, uint8* pBuf, uint32 sizeInBytes)
{
    uint8* p = (uint8*)addr;

    memcpy((void *)pBuf, p, sizeInBytes);
    return (FLASH_GetStatus() == FLASH_COMPLETE);
}


bool Setting_WriteWords(uint32 addr, uint8* pBuf, uint32 sizeInBytes)
{
    ASSERT(sizeInBytes % 4 == 0);   // Words should be in size of multiple of 4
    uint32 i = 0;
    FLASH_Status s;

    FLASH_Unlock();
    for ( ; i<sizeInBytes; i+=4)
    {
        uint8   *p  = pBuf + i;
        uint32  d   = *p | *(p+1)<<8 | *(p+2)<<16 | *(p+3)<<24;
        s = FLASH_ProgramWord(addr + i, d);
        if (s != FLASH_COMPLETE)
        {
            break;
        }
    }
    FLASH_Lock();

    return (FLASH_GetStatus() == FLASH_COMPLETE);
}

void Setting_Bookkeeping(void)
{
    TP_PRINTF("Enter %s\r\n", __FUNCTION__);
    Setting_ErasePage(SETT_PAGE_ROM_ADDR);
    for (uint16 i = 0 ; i<ArraySize(settingRomMap); i++)
    {
        if (settingRomMap[i].addr)
        {
            eSettingId id = settingRomMap[i].id;
            if ((settingRomMap[i].addr) && ( (settingDB[id].p) ))
            {
                Setting_WriteWords(settingRomMap[i].addr, settingDB[id].p, settingDB[id].size);
            }
        }
    }
    uint8 temp_vol = *(uint8*)Setting_Get(SETID_VOLUME);
}




/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Debug Server
                  -------------------------

                  SW Module Document




@file        DebugSrv.c
@brief       Debug server
@author      Dmitry.Abdulov
@date        2014-02-12
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-02-12     Dmitry.Abdulov
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
 *  * Example using debug print out
 * \msc
 * client, server, driver;
 *              --- [label = "Client send request\command to Server"];
 * client->server   [label = "SendToServer(DEBUG_SIG, event)"];
 *              --- [label = "Server perform print output by calls Uart Driver"];
 * server=>driver   [label = "UartDrv_Write()"];
 *              --- [label = "Server send response back to Client"];
 * server->client   [label = "QACTIVE_POST()"];
 * \endmsc

*/


#include "trace.h"
#include "bsp.h"
#include "pt.h"
#include "controller.h"
#include "AudioSrv.h"
#include "KeySrv.h"
#include "PowerSrv.h"
#include "SettingSrv.h"

#include "./DebugSrv_priv.h"
#include "UartDrv.h"

#include "DebugSrv.config"

#define CAST_ME cDebugSrv * debugSrv = (cDebugSrv *) me;


/* private state functions */
static QState DebugSrv_Initial(cDebugSrv * const me, QEvt const * const e);
static QState DebugSrv_Ready(cDebugSrv * const me, QEvt const * const e);
static QState DebugSrv_WaitResp(cDebugSrv * const me, QEvt const * const e);
static QState DebugSrv_DeActive(cDebugSrv * const me, QEvt const * const e);


/*____________________________________________________________________________*/
#ifndef NDEBUG
static void DebugSrvKeyOutput(KeyStateEvt* kstate);
static void DebugSrvRawKeyOutput(eKeyID keyId, uint32 rawData);
static void DebugSrvEchoPrintableChar( char c );
#endif

static void DebugSrvResetOutBuf( void );
static void DebugSrvHandleOutBuffer( void );
static void uartRxCallback(void* p);
static void DebugSrvParseAndRun();
static void DebugSrvResetInBuf( void );
static void DebugSrvBufferInput( char c );
static void DebugSrvHandlePrintSig(cDebugSrv * const me, QEvt const * const e);
static void DebugSrvInputSourceXtor();

/*____________________________________________________________________________*/

/* Private functions / variables. Declare and drivers here */
/* Internal event queue - Size as needed */
static QEvt const *DebugEvtQue[DBG_SRV_EVENT_Q_SIZE];


#define DBG_UART_TX_BUF_SIZE (8*1024)
#define DBG_UART_RX_BUF_SIZE (676)
static uint8 uartTxBufDbg[DBG_UART_TX_BUF_SIZE];
static uint8 uartRxBufDbg[DBG_UART_RX_BUF_SIZE];
static cRingBuf txBufDbg;
static cRingBuf rxBufDbg;

cUartDrv  p_debug_dev;


#define CHAR_BS 0x08
#define CHAR_CR 0x0D
#define CLI_INPUT_BUFFER_SIZE 127
static char in_buf[CLI_INPUT_BUFFER_SIZE] = {0};
static uint8 in_buf_idx = 0;
#define CLI_OUTPUT_BUFFER_SIZE 255
static char out_buf[CLI_OUTPUT_BUFFER_SIZE];

static KeyDebugReqEvt key_dbg_req;


/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/

void DebugSrv_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(debugSrv);
    QS_OBJ_DICTIONARY(DebugSrv_Ready);

    DebugSrvInputSourceCtor();
    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&DebugSrv_Initial), DEBUG_TIMEOUT_SIG,
                                DebugEvtQue, Q_DIM(DebugEvtQue), DEBUG_SRV_ID);
    /*OK, all done, let's roll.  */
}

void DebugSrv_ShutDown(cPersistantObj *me)
{
	/* Clean memory and shut-down. Called by the controller */
    Server_Xtor(me);
    DebugSrvInputSourceXtor();
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/

/* Initial state */
static QState DebugSrv_Initial(cDebugSrv * const me, QEvt const * const e)
{
    uint8 i;
    for (i = 0; i < NUM_OF_CLI_CMDS; i++)
    {
        if (pdPASS != CLIRegisterCommand(pCLI_Commands[i]))
        {
#ifndef NDEBUG
            char errmsg[46];
            sprintf(&errmsg[0], "Register %s command is failed!\r\n", pCLI_Commands[i]->pcCommand);
            DebugSrvOutput(&errmsg[0], 0);
#endif
        }
    }

#ifndef NDEBUG
    //DebugSrvOutput("\r\n0 JumpToApp\r\n", 0);
    DebugSrvOutput(getVersionString(), 0);
    DebugSrvOutput("\r\n", 2);
#endif
    /* Subscribe for need signals here */

    QActive_subscribe((QActive*) me, KEY_STATE_SIG);

    return Q_TRAN(&DebugSrv_Ready);
}

static QState DebugSrv_Ready(cDebugSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        key_dbg_req.req = DEBUG_NO_REQ;
        DebugSrvResetInBuf();
#ifndef NDEBUG
        DebugSrvOutput(">", 1);
#endif
        return Q_RET_HANDLED;
    }

    case POWER_DEBUG_RESP_SIG:
    {
        PowerSrvDebugRespEvt* dbg_resp = (PowerSrvDebugRespEvt*)e;
        if (RET_SUCCESS == dbg_resp->result)
        {
            pt_handle_adc_resp((get_current_seq()+1), TRUE,(unsigned short)dbg_resp->adcRawValue);
        }
        else
        {
            pt_handle_adc_resp((get_current_seq()+1), FALSE, 0);
        }


        return Q_RET_HANDLED;
    }
    case CLI_AUX_REQ_SIG:
    {
#ifndef NDEBUG
#ifdef HAS_SETTING
        BOOL isAuxInPlugIn = *(BOOL*)Setting_Get(SETID_IS_AUXIN_PLUG_IN);
        if(isAuxInPlugIn)
        {
            DebugSrvOutput("\r\nauxin input: plugged in\r\n",0);
        }
        else
        {
            DebugSrvOutput("auxin input: unplugged \r\n", 0);
        }
#endif        
        return Q_RET_HANDLED;
#endif
    }
    case CLI_ADC_MMI_REQ_SIG:
    {
        KeyDebugReqEvt* kdr = (KeyDebugReqEvt*)e;
        memcpy(&key_dbg_req, kdr, sizeof(KeyDebugReqEvt));
        kdr = Q_NEW(KeyDebugReqEvt, KEY_DEBUG_REQ_SIG);
        kdr->keyEvent = key_dbg_req.keyEvent;
        kdr->keyId = key_dbg_req.keyId;
        kdr->req = key_dbg_req.req;
        SendToServer(KEY_SRV_ID, (QEvt*)kdr);
        return Q_TRAN(&DebugSrv_WaitResp);
    }
    case CMD_READY_CALLBACK_SIG:
    {
        DebugSrvParseAndRun();
        DebugSrvResetInBuf();
#ifndef NDEBUG
        DebugSrvOutput(">", 1);
#endif
        return Q_RET_HANDLED;
    }
    case DEBUG_SIG:
    {
        DebugSrvHandlePrintSig(me, e);
        return Q_RET_HANDLED;
    }
    case KEY_STATE_SIG:
    {
#ifndef NDEBUG
        KeyStateEvt* ks = (KeyStateEvt*) e;
        DebugSrvResetOutBuf();
        DebugSrvKeyOutput(ks);
#endif
        return Q_RET_HANDLED;
    }
	case SYSTEM_SLEEP_REQ_SIG:
    {
        CommonReqEvt* pReq = (CommonReqEvt*)e;
        CommonEvtResp((QActive*)me, pReq->sender,RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);

        return Q_RET_HANDLED;
    }

    case SYSTEM_ACTIVE_REQ_SIG:
    {
        CommonReqEvt* pReq = (CommonReqEvt*) e;
        CommonEvtResp((QActive*) me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
        return Q_RET_HANDLED;
    }

    case Q_EXIT_SIG:
    {
        return Q_RET_HANDLED;
    }
    default: break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState DebugSrv_WaitResp(cDebugSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        QTimeEvt_disarm(TIME_EVT_OF(me));
        QTimeEvt_armX(TIME_EVT_OF(me), GET_TICKS_IN_MS(1000), 0);
        return Q_RET_HANDLED;
    }
    case DEBUG_SIG:
    {
        DebugSrvHandlePrintSig(me, e);
        return Q_RET_HANDLED;
    }

    case DEBUG_TIMEOUT_SIG:
    {
        switch (key_dbg_req.req)
        {
         case DEBUG_RAW_DATA_REQ:
             pt_handle_adc_resp((get_current_seq() + 1), FALSE, 0);
             break;
        case DEBUG_KEY_EVT_SIMULATION:
            pt_handle_cmd_resp((get_current_seq() + 1), PT_COMMAND_MMI, FALSE);
            break;
        default:
            break;
        }
#ifndef NDEBUG
          DebugSrvOutput("\r\nTime out! Error response!\r\n", 0);
#endif
        return Q_TRAN(&DebugSrv_Ready);
    }
    case KEY_STATE_SIG:
    {
        if (DEBUG_KEY_EVT_SIMULATION == key_dbg_req.req)
        {
            KeyStateEvt* ks = (KeyStateEvt*) e;
            if ((ks->keyId == key_dbg_req.keyId) && (ks->keyEvent == key_dbg_req.keyEvent))
            {
                pt_handle_cmd_resp((get_current_seq() + 1), PT_COMMAND_MMI, TRUE);
                return Q_TRAN(&DebugSrv_Ready);
            }
        }

        return Q_RET_HANDLED;
    }
    case KEY_DEBUG_RESP_SIG:
    {
        KeyDebugRespEvt* dbg_resp = (KeyDebugRespEvt*) e;
#ifndef NDEBUG
        if (DEBUG_RAW_DATA_REQ == key_dbg_req.req)
        {
            DebugSrvRawKeyOutput(dbg_resp->keyId, dbg_resp->rawData);
        }
#else
        if (RET_SUCCESS == dbg_resp->serviceState)
        {
            pt_handle_adc_resp((get_current_seq() + 1), TRUE, (unsigned short) dbg_resp->rawData);
        }
        else
        {
            pt_handle_adc_resp((get_current_seq() + 1), FALSE, 0);
        }
#endif
        QTimeEvt_disarm(TIME_EVT_OF(me));

        return Q_TRAN(&DebugSrv_Ready);
    }
    case Q_EXIT_SIG:
    {
        QTimeEvt_disarm(TIME_EVT_OF(me));
        break;
    }
    default:
        break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState DebugSrv_DeActive(cDebugSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
    case Q_ENTRY_SIG:
    {
        DebugSrvInputSourceXtor();
        return Q_RET_HANDLED;
    }
    case SYSTEM_ACTIVE_REQ_SIG:
    {
        DebugSrvInputSourceCtor();
        CommonReqEvt* pReq = (CommonReqEvt*) e;
        CommonEvtResp((QActive*) me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
        return Q_TRAN(&DebugSrv_Ready);
    }
    default:
        break;
    }
    return Q_SUPER(&QHsm_top);
}



/* interface function for handle AJ_Printf; TODO: have to be implemented  */
void DebugSrvAJPrintf(const char *fmt, ...)
{

}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
/**
 * debug server input source constructor - create uart driver instance
 * create tx,rx ringbuffer instance and register uart callback function
 */
void DebugSrvInputSourceCtor()
{
    RingBuf_Ctor(&txBufDbg, uartTxBufDbg, DBG_UART_TX_BUF_SIZE);
    RingBuf_Ctor(&rxBufDbg, uartRxBufDbg, DBG_UART_RX_BUF_SIZE);
    UartDrv_Ctor(&p_debug_dev, (tUARTDevice*) getDevicebyId(DEBUG_DEV_ID, NULL), &txBufDbg, &rxBufDbg);
    UartDrv_RegisterRxCallback(&p_debug_dev, uartRxCallback);
}
/**
 * debug server input source destructor destrot uart driver and ringbuffers objects
 * to save power, while switching into deactive state
 */
static void DebugSrvInputSourceXtor()
{
    UartDrv_Xtor(&p_debug_dev);
    RingBuf_Xtor(&txBufDbg);
    RingBuf_Xtor(&rxBufDbg);
}

/**
 * output string through uart
 * @param  s - pointer to string
 * @param len - string length or 0 if not defined
 * return uint32 value 0 - TP_SUCCESS; 1 - TP_FAIL;
 */
uint32 DebugSrvOutput(char* s, uint8 len)
{
    uint32 ret;
    if (len)
    {
       ret = UartDrv_Write(&p_debug_dev, (uint8*)s, len);
    }
    else
    {
       ret = UartDrv_Write(&p_debug_dev, (uint8*)s, strlen(s));
    }
    return ret;
}

#ifndef NDEBUG

static void DebugSrvRawKeyOutput(eKeyID keyId, uint32 rawData)
{
    switch (keyId)
    {
    case PLAY_PAUSE_KEY:
    {
        sprintf(&out_buf[0], "DBG: adc value of the Play button is :%u\r\n", (unsigned int)rawData);
        break;
    }
    case VOLUME_UP_KEY:
    {
        sprintf(&out_buf[0], "DBG: adc value of the Volume Up button is :%u\r\n", (unsigned int)rawData);
        break;
    }
    case VOLUME_DOWN_KEY:
    {
        sprintf(&out_buf[0], "DBG: adc value of the Volume Down button is :%u\r\n", (unsigned int)rawData);
        break;
    }
    case NEXT_KEY:
    {
        sprintf(&out_buf[0], "DBG: adc value of the Next button is :%u\r\n", (unsigned int)rawData);
        break;
    }
    case PREV_KEY:
    {
        sprintf(&out_buf[0], "DBG: adc value of the Previous button is :%u\r\n", (unsigned int)rawData);
        break;
    }

    default:
        break;
    }
    DebugSrvHandleOutBuffer();
}

/**
 * output key pressed info based on KeyStateEvt* kstate
 * @param kstate - key state event
 */
static void DebugSrvKeyOutput(KeyStateEvt* kstate)
{
#ifndef DONT_PRINT_KEY_EVT_NAME
    switch(kstate->keyEvent)
    {
    case KEY_EVT_UP:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_UP.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_DOWN:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_DOWN.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_SHORT_PRESS:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_SHORT_PRESS.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_LONG_PRESS:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_LONG_PRESS.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_VERY_LONG_PRESS:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_VERY_LONG_PRESS.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_HOLD:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_HOLD.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_REPEAT:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_REPEAT.\r\n ", kstate->keyId);
        break;
    }
    case KEY_EVT_VERY_LONG_HOLD:
    {
        sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent: KEY_EVT_VERY_LONG_HOLD.\r\n ", kstate->keyId);
        break;
    }
    default:
        return;
    }
#else
    sprintf(&out_buf[0],"KEY_STATE_SIG: keyId:%d; keyEvent:%d\r\n", kstate->keyId, kstate->keyEvent);
#endif
    DebugSrvHandleOutBuffer();
}
#endif
static void DebugSrvResetOutBuf( void )
{
    memset( out_buf, 0, sizeof(out_buf) );
}

static void DebugSrvHandleOutBuffer( void )
{
    if( '\0' != out_buf[0] )
    {
        DebugSrvOutput(&out_buf[0], 0);
        DebugSrvResetOutBuf();
    }
}


/* call back function calls each time by Uart Driver, when new byte arrive in uart */
static void uartRxCallback(void* p)
{
    char dat = (char)RingBuf_PopData(&rxBufDbg);
            if (END_OF_CMD_SYM != dat)
            {
#ifndef NDEBUG
                DebugSrvEchoPrintableChar(dat);
#endif
                DebugSrvBufferInput(dat);
            }
            else
            {
                DebugCmdEvt* cmdEvt = Q_NEW(DebugCmdEvt, CMD_READY_CALLBACK_SIG);
                SendToServer(DEBUG_SRV_ID, (QEvt*)cmdEvt);
            }
}


static void DebugSrvParseAndRun()
{
    DebugSrvResetOutBuf();
    while (CLIProcessCommand((const int8_t *) in_buf, (int8_t *) out_buf, sizeof (out_buf)) != pdFALSE)
    {
        DebugSrvHandleOutBuffer();
    }
    DebugSrvHandleOutBuffer();
    DebugSrvResetInBuf();

}

static void DebugSrvResetInBuf( void )
{
    memset( in_buf, 0, sizeof(in_buf) );
    in_buf_idx = 0;
}

#ifndef NDEBUG
static void DebugSrvEchoPrintableChar( char c )
{

    if( (c>=32) && (c<=126) )
    {
        UartDrv_Write(&p_debug_dev, (uint8*)&c, 1);
    }

    if( c==CHAR_BS )
        if( in_buf_idx > 0 )
        {
            UartDrv_Write(&p_debug_dev, (uint8*)&c, 1);
        }

    if( c==CHAR_CR )
    {
        UartDrv_Write(&p_debug_dev, (uint8*)"\r\n", 2);
    }
}
#endif

static void DebugSrvBufferInput( char c )
{
    if( c == CHAR_BS )
    {
        if( in_buf_idx > 0 )
        {
            in_buf_idx--;
            in_buf[in_buf_idx]=0;
        }
    }
    else if(in_buf_idx < sizeof(in_buf))
    {
        in_buf[in_buf_idx]=c;
        in_buf_idx++;
    }
}

static void DebugSrvHandlePrintSig(cDebugSrv * const me, QEvt const * const e)
{
#ifndef NDEBUG
        DebugEvt* dbg = (DebugEvt*) e;
        if (DEBUG_PRINT_EVT == dbg->evt)
        {
            if (NULL != dbg->sender)
            {
                DebugRespEvt* dbg_resp = Q_NEW(DebugRespEvt, DEBUG_RESP_SIG);
                dbg_resp->resp = DebugSrvOutput((char*) dbg->pMsg, dbg->length);
                QACTIVE_POST(dbg->sender, (QEvt*) dbg_resp, &me);
            }
            else
            {
                DebugSrvOutput((char*) dbg->pMsg, dbg->length);
            }
        }
#endif
}




/*
-------------------------------------------------------------------------------
TYMPHANY LTD
                  USB Server
                  -------------------------
                  SW Module Document
@file        UsbSrv.c
@brief       it's the server to control the USB module
@author      Neo Gan
@date        2016-09-08
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2016-09-08     Neo Gan
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  :
-------------------------------------------------------------------------------
*/

/*---------------------------include files-----------------------------------*/
#include "product.config"
#include "controller.h"
#include "bsp.h"

#include "deviceTypes_v2.h"
#include "SettingSrv.h"

#include "ringbuf.h"
#include "SystemDrv.h"
#include "trace.h"
#include "tym_qp_lib.h"
#include "UsbDrv.h"
#include "UsbSrv.h"
#include "UsbSrv_priv.h"
#include "SystemDrv.h"
#include "UsbSrv.Config"

/* Internal event queue - Size as needed */
static QEvt const *UsbEvtQue[USB_SRV_EVENT_Q_SIZE];

static cUsbDrv usbDrvObj;


/*--------------------------macro definition---------------------------------*/
#define CAST_ME cUsbSrv * UsbSrv = (cUsbSrv *) me;

/* 
    acording to the receive message is very big(at least 96bytes),
    when we receive a message from the host, we will send an event to USB_SRV_ID,
    but this event will not include this big message, so we create a global
    variable to store this big message.
*/
#ifdef USB_SERVER_DEBUG
    const static char *server_debug = "[UsbSrv_Debug] ";
    #define USBSRV_DEBUG_MSG TP_PRINTF("\n%s", server_debug); TP_PRINTF
    #define TYMQP_DUMP_QUEUE_WITH_LOG(me, ...) TymQP_DumpQueue_WithLog((QActive *)(me), __func__, __VA_ARGS__)
#else
    #define USBSRV_DEBUG_MSG(...)
    #define TYMQP_DUMP_QUEUE_WITH_LOG(...)
#endif

/*****************************************************************************************************************
 *
 * Start-up / shut-down functions
 *
 *****************************************************************************************************************/
void UsbSrv_StartUp(cPersistantObj *me)
{
    /* Add to QSPY directory - only does so if QSPY enabled.
    * Remember to make sure these items exist
    */
    usbDrvObj.pSender = (QActive*)me;
    QS_OBJ_DICTIONARY(UsbSrv_Active);
    QS_OBJ_DICTIONARY(UsbSrv_DeActive);

    /* start up the object and let it run. including the timer*/
    Server_Ctor((cServer*)me, Q_STATE_CAST(&UsbSrv_Initial), USB_TIMEOUT_SIG,
                  UsbEvtQue, Q_DIM(UsbEvtQue), USB_SRV_ID);
}

void UsbSrv_ShutDown(cPersistantObj *me)
{
    /* Clean memory and shut-down. Called by the controller */
    Server_Xtor((cServer*)me);
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/

/* Initial state */
QState UsbSrv_Initial(cUsbSrv * const me, QEvt const * const e)
{

#ifdef HAS_KEYS
    QActive_subscribe((QActive*) me, KEY_STATE_SIG); // use the macros!
#endif
#ifdef HAS_AUDIO_CONTROL
    QActive_subscribe((QActive*) me, AUDIO_MUSIC_STREAM_STATE_SIG);
    QActive_subscribe((QActive*) me, AUDIO_STATE_SIG);
#endif

    return Q_TRAN(&UsbSrv_DeActive);
}

/*   Active state - first state where "normal" service begins  */
QState UsbSrv_Active(cUsbSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)Q_ENTRY_SIG", e->sig);
            PersistantObj_RefreshTick((cPersistantObj*)me, USB_SRV_ACTIVE_IN_MS);
            return Q_HANDLED();
        }
        case SYSTEM_SLEEP_REQ_SIG:
        {
            CommonReqEvt* reqEvt = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, reqEvt->sender, RET_SUCCESS, SYSTEM_SLEEP_RESP_SIG);
            return Q_TRAN(&UsbSrv_DeActive);
        }
        case USB_TIMEOUT_SIG:
        {
            UsbSrv_RecvDataHandler(me);
            PersistantObj_RefreshTick((cPersistantObj*)me, USB_SRV_ACTIVE_IN_MS);
            return Q_HANDLED();
        }
        case USB_STATE_SIG:
        {
            UsbSrvState *pState = (UsbSrvState *)e;
            USBSRV_DEBUG_MSG("status=%d\r\n", pState->deviceStatus);
            UsbSrv_StateHandler(me, pState);
            return Q_HANDLED();
        }
        case USB_REQ_SIG:
        {
            UsbDrv_RequestHandler(&usbDrvObj, e);
            return Q_HANDLED();
        }
        case USB_RECV_DATA_SIG:
        {
            UsbSrv_RecvDataHandler(me);
            return Q_HANDLED();
        }
        case USB_SEND_DATA_SIG:
        {
            UsbSrv_SendDataHnadler(me);
            return Q_HANDLED();
        }
        case Q_EXIT_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)Q_EXIT_SIG", e->sig);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        default:
        {
            if (e->sig > Q_USER_SIG)
            {
                UsbDrv_HandleUnknown(&usbDrvObj, e);
                /*if (e->sig < Q_USER_SIG), dont return Q_HANDLED() */
                return Q_HANDLED();
            }
        }
    }
    return Q_SUPER(&QHsm_top);
}


/*   DeActive state - Use this state to ramp down the server  */
QState UsbSrv_DeActive(cUsbSrv * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)Q_ENTRY_SIG", e->sig);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            UsbDrv_Xtor(&usbDrvObj);
            return Q_HANDLED();
        }
        case SYSTEM_ACTIVE_REQ_SIG:
        {
            UsbDrv_Ctor(&usbDrvObj);
            CommonReqEvt* pReq = (CommonReqEvt*) e;
            CommonEvtResp((QActive*)me, pReq->sender, RET_SUCCESS, SYSTEM_ACTIVE_RESP_SIG);
            return Q_TRAN(&UsbSrv_Active);
        }
        case Q_EXIT_SIG:
        {
            TYMQP_DUMP_QUEUE_WITH_LOG(me, "(%d)Q_EXIT_SIG", e->sig);
            QTimeEvt_disarm(TIME_EVT_OF(me));
            return Q_HANDLED();
        }
        /* fill me in */
        default:
            break;
    }
    return Q_SUPER(&QHsm_top);
}


QState UsbSrv_StateHandler(cUsbSrv * const me, UsbSrvState *pState)
{
    QState ret = Q_HANDLED();


    return ret;
}

QState UsbSrv_RecvDataHandler(cUsbSrv * const me)
{
    QState ret = Q_HANDLED();


    return ret;
}

QState UsbSrv_SendDataHnadler(cUsbSrv * const me)
{
    QState ret = Q_HANDLED();


    return ret;
}

bool UsbSrv_isDeviceActive(void)
{
    return (USB_STA_CONFIGURED == usbDrvObj.deviceStatus) ? TRUE : FALSE;
}

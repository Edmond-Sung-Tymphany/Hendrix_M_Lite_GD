/*
-------------------------------------------------------------------------------
TYMPHANY LTD





                  Menu Delegate
                  -------------------------

                  SW Module Document




@file        MenuDlg.c
@brief       This file declare and implement the menu dlg
@author      Bob.Xu 
@date        2014-11-19
@copyright (c) Tymphany Ltd. All rights reserved.

Change History:
VERSION    : 1    DRAFT      2014-11-19     Bob.Xu 
DESCRIPTION: First Draft. Generated by newclass.py
SCO/ERROR  : 
-------------------------------------------------------------------------------
*/
#include "MenuDlg.h"
#include "./MenuDlg_priv.h"
#include "persistantObj.h"
#include "trace.h"

#ifdef Q_SPY
#define CAST_ME cMenuDlg * pMenuDlg = (cMenuDlg *) me;
#else
#define CAST_ME cMenuDlg * pMenuDlg = (cMenuDlg *) me;
#endif

/* Private functions / variables. */
/* 
 * This array saves the history of the node position
 */
static uint8 nodeIndexHistory[5] = {0};
static tPageNode **parentStack[5] = {NULL};
static uint8 currentMenuLevel = 0;
static uint8 currNodeIndex = 0; /* Current node position*/
static BOOL isSettingValue = TRUE;
static BOOL isNavigActionwithDelay = FALSE;
/* Internal event queue - Size as needed */
static QEvt const *MenuEvtQue[10];

enum MenuDlgPriSignals /* main appp private signals */
{
    MENU_DLG_TIMEOUT_SIG = MAX_SIG,
    MENU_DLG_STANDBY_SIG,
    MENU_DLG_ACTIVE_SIG
};

/*****************************************************************************************************************
 *
 * Ctor / Xtor functions
 *
 *****************************************************************************************************************/
cMenuDlg * MenuDlg_Ctor(cMenuDlg *me,  QActive *ownerObj, tMenu * pMenu) /* You probably want to change this and inherit tDlgCtorData */
{
    /* Add to QSPY directory - only does so if QSPY enabled. 
    * Remember to make sure these items exist
    */
    QS_OBJ_DICTIONARY(MenuDlg);
    QS_OBJ_DICTIONARY(MenuDlg_PreActive);
    QS_OBJ_DICTIONARY(MenuDlg_Active);
    QS_OBJ_DICTIONARY(MenuDlg_DeActive);
    me->pMenu = pMenu;
    me->ppCurrNode = pMenu->ppMenuEntrance;
    /* Call super... */
    me = (cMenuDlg *)CREATE_DLG(me, cMenuDlg, ownerObj, &MenuDlg_Initial);
    QTimeEvt_ctorX(&me->timeEvt, (QActive*)me, MENU_DLG_TIMEOUT_SIG, 0);
    /* Active object start */
    Delegate_Start((cDelegate*)me, MenuEvtQue, Q_DIM(MenuEvtQue));
    ASSERT(me->super_.delegateOwner);
    /* Subscribe */
    QActive_subscribe((QActive*) me, KEY_STATE_SIG);
    me->isCreated = TRUE;
    /* return */
    return me;

}

void MenuDlg_Xtor(cMenuDlg *me)
{
    QActive_unsubscribeAll((QActive *)me);  /* unsubscribe from all signals */
    CLR_DLG_OWNER(me);
    currentMenuLevel = 0;
    currNodeIndex = 0;
    isSettingValue = TRUE;
    isNavigActionwithDelay = FALSE;
    
    /* ... then call super */
    DESTROY_DLG(me);
}

void MenuDlg_Disable(cMenuDlg *me)
{
    MenuDlgStandbyEvt* pGoStandbyEvt = Q_NEW(MenuDlgStandbyEvt, MENU_DLG_STANDBY_SIG);
    QACTIVE_POST((QActive *)me,(QEvt *)pGoStandbyEvt, 0);
}

void MenuDlg_Enable(cMenuDlg *me)
{
    MenuDlgActivateEvt* pGoActiveEvt = Q_NEW(MenuDlgActivateEvt, MENU_DLG_ACTIVE_SIG);
    QACTIVE_POST((QActive *)me,(QEvt *)pGoActiveEvt, 0);
}

void MenuDlg_Reset(cMenuDlg *me)
{
    currentMenuLevel = 0;
    currNodeIndex = 0;
    isSettingValue = TRUE;
    isNavigActionwithDelay = FALSE;
    me->ppCurrNode = me->pMenu->ppMenuEntrance;
}

/*****************************************************************************************************************
 *
 * State functions
 *
 *****************************************************************************************************************/
/* Initial state */
static QState MenuDlg_Initial(QActive * const me)
{
    /* Fill me in */
    return Q_TRAN(&MenuDlg_Active);
}

/*   Active state - first state where "normal" service begins  */
static QState MenuDlg_Active(QActive * const me, QEvt const * const e)
{
    CAST_ME;
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case KEY_STATE_SIG:
        {
            if(!isNavigActionwithDelay)
            {
                KeyStateEvt *keyEvt = (KeyStateEvt*)e;
                MenuDlg_HandleKeyEvt(pMenuDlg,keyEvt);
            }
            return Q_HANDLED();
        }
        case MENU_DLG_TIMEOUT_SIG:
        {
            /* Go back to the previous page */
            isNavigActionwithDelay = FALSE;
            if(PAGE_ACTION_TYPE == (*(pMenuDlg->ppCurrNode))->pageType && isSettingValue)
            {
                MenuDlg_IndicateController(pMenuDlg, ENTER_KEY,KEY_EVT_DOWN); 
            }
            else
            {
                DisplaySrv_SendString((*(pMenuDlg->ppCurrNode))->pPageText);
            }
            return Q_HANDLED();
        }
        case MENU_DLG_STANDBY_SIG:
        {
            return Q_TRAN(MenuDlg_DeActive);
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

static QState MenuDlg_DeActive(QActive * const me, QEvt const * const e)
{
    switch (e->sig)
    {
        case Q_ENTRY_SIG:
        {
            return Q_HANDLED();
        }
        case MENU_DLG_ACTIVE_SIG:
        {
            return Q_TRAN(MenuDlg_Active);
        }
        case Q_EXIT_SIG:
        {
            return Q_HANDLED();
        }
        default: break;
    }
    return Q_SUPER(&QHsm_top);
}

/*****************************************************************************************************************
 *
 * private functions
 *
 *****************************************************************************************************************/
static void MenuDlg_HandleKeyEvt(cMenuDlg * const me,KeyStateEvt const * const keyEvt)
{
    const tKeyToPageNodeConf * pKeyToPageNode;
    pKeyToPageNode = me->pMenu->pKeyToPageListHead;
    /* Process predefined key and its page node */
    while(NULL != pKeyToPageNode)
    {
        if(pKeyToPageNode->keyId == keyEvt->keyId)
        {
            if(pKeyToPageNode->backToPrePage && pKeyToPageNode->pPageNode != *(me->ppCurrNode))
            {
                MenuDlg_RefleshTick(me, pKeyToPageNode->expireTime);
            }
            else
            {
                QTimeEvt_disarm(&me->timeEvt);
            }
            MenuDataUpdate *pMenuDataUpdateReq = Q_NEW(MenuDataUpdate,VIEW_DLG_REQ_SIG);
            pMenuDataUpdateReq->pPageNode = pKeyToPageNode->pPageNode;
            pMenuDataUpdateReq->keyId     = keyEvt->keyId;
            pMenuDataUpdateReq->keyEvt    = keyEvt->keyEvent;
            QACTIVE_POST(me->super_.delegateOwner, (QEvt*)pMenuDataUpdateReq, 0);
            return ;
        }
        pKeyToPageNode = pKeyToPageNode->pNext;
    }
    /* Process navigation keys */
    QTimeEvt_disarm(&me->timeEvt);
    switch(keyEvt->keyId)
    {
        case RETURN_KEY:
        {
            MenuDlg_HandleBackKey(me, keyEvt);
            break;
        }
        case PREV_KEY:
        {
            MenuDlg_HandlePreKey(me, keyEvt);
            break;
        }
        case NEXT_KEY:
        {
            MenuDlg_HandleNextKey(me, keyEvt);
            break;
        }
        case ENTER_KEY:
        {
            MenuDlg_HandleEnterKey(me, keyEvt);
            break;
        }
        default:break;
    }
}

static void MenuDlg_HandleBackKey(cMenuDlg * const me, KeyStateEvt const * const e)
{
    switch(e->keyEvent)
    {
        case KEY_EVT_SHORT_PRESS:
        {
            MenuDlg_BackToParent(me, e->keyEvent);
            break;
        }
        case KEY_EVT_HOLD:
        {
           MenuDlg_BackToNode(me, 0);
           break;
        }
        default:break;
    }
}

static void MenuDlg_HandlePreKey(cMenuDlg * const me, KeyStateEvt const * const e)
{
    switch(e->keyEvent)
    {
        case KEY_EVT_DOWN:
        case KEY_EVT_REPEAT:
        {
            MenuDlg_ScrollPre(me,e->keyEvent);
            break;
        }
        default:break;
    }
}

static void MenuDlg_HandleNextKey(cMenuDlg * const me, KeyStateEvt const * const e)
{
    switch(e->keyEvent)
    {
        case KEY_EVT_DOWN:
        case KEY_EVT_REPEAT:
        {
            MenuDlg_ScrollNext(me,e->keyEvent);
            break;
        }
        default:break;
    }
}

static void MenuDlg_HandleEnterKey(cMenuDlg * const me, KeyStateEvt const * const e)
{
    switch(e->keyEvent)
    {
        case KEY_EVT_DOWN:
        {
            MenuDlg_Enter(me,e->keyEvent);
            break;
        }
        default:break;
    }
}


static void MenuDlg_ScrollPre(cMenuDlg * const me, eKeyEvent keyEvent)
{
    switch((*(me->ppCurrNode))->pageType)
    {
        case PAGE_ACTION_TYPE:
        {
          if(isSettingValue)
          {
            MenuDlg_IndicateController(me, PREV_KEY, keyEvent);
            break;
          }
        }
        /* Do not put break here, if it is not setting value, do navigation*/
        case PAGE_NAVIGATION_ACTION_TYPE:
        case PAGE_NAVIG_ACTION_WITH_DELAY_TYPE:
        case PAGE_NAVIGATION_TYPE:
        {
          if(currNodeIndex > 0)
          {
              me->ppCurrNode--;
              currNodeIndex--;
          }
          else if(0 == currNodeIndex && TRUE == me->pMenu->menuLoopBack)
          {
              currNodeIndex = (*(me->ppCurrNode))->numOfBrother - 1;
              me->ppCurrNode += ((*(me->ppCurrNode))->numOfBrother - 1); 
          }
          DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
        }
        break;
        default:break;
    }
}

static void MenuDlg_ScrollNext(cMenuDlg * const me, eKeyEvent keyEvent)
{
    switch((*(me->ppCurrNode))->pageType)
    {
         case PAGE_ACTION_TYPE:
         {
            if(isSettingValue)
            {
              MenuDlg_IndicateController(me, NEXT_KEY, keyEvent);
              break;
            }
            /* Do not put break here, if it is not setting value, do navigation*/
         }
        case PAGE_NAVIGATION_ACTION_TYPE:
        case PAGE_NAVIG_ACTION_WITH_DELAY_TYPE:
          /* No break */
        case PAGE_NAVIGATION_TYPE:
          {
            if(currNodeIndex < ((*(me->ppCurrNode))->numOfBrother - 1))
            {
               me->ppCurrNode++;
               currNodeIndex++;
            }
            else if(((*(me->ppCurrNode))->numOfBrother - 1) == currNodeIndex \
              && TRUE == me->pMenu->menuLoopBack)
            {
                currNodeIndex = 0;
                me->ppCurrNode -= ((*(me->ppCurrNode))->numOfBrother - 1);
            }
            DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
          }
          break;
        default:break;
    }
}

static void MenuDlg_Enter(cMenuDlg * const me, eKeyEvent keyEvent)
{
    if(NULL != (*(me->ppCurrNode))->ppChildren)
    {
        if(PAGE_NAVIGATION_ACTION_TYPE == (*(me->ppCurrNode))->pageType)
        {
            MenuDlg_IndicateController(me, ENTER_KEY, keyEvent);
            MenuDlg_UpdateNodeStatus(me);
        }
        MenuDlg_Push(me);
        /* now update me to child */
        MenuDlg_UpdateToNode(me);
    }
    else
    {
        if(PAGE_EXIT_TYPE == (*(me->ppCurrNode))->pageType)
        {
            MenuDlg_IndicateController(me, ENTER_KEY, keyEvent);
            return;
        }
        else if(PAGE_NAVIG_ACTION_WITH_DELAY_TYPE == (*(me->ppCurrNode))->pageType)
        {
            MenuDlg_IndicateController(me, ENTER_KEY, keyEvent);
            /* go to the parent */
            MenuDlg_Pop(me);
            /* Start the timer to display the parent's string later */
            MenuDlg_RefleshTick(me, me->pMenu->navigActionwithDelayTime);
            isNavigActionwithDelay = TRUE;
            return;
        }
        
        if(FALSE == isSettingValue)
        {
            MenuDlg_IndicateController(me, ENTER_KEY, keyEvent);
            if((PAGE_NAVIGATION_ACTION_TYPE != (*(me->ppCurrNode))->pageType))
            {
                MenuDlg_Push(me);
                isSettingValue = TRUE;
                return;
            }
            else
            {
                MenuDlg_UpdateNodeStatus(me);
            }
        }
        else
        {

           /*
            * When user is setting the values, enter mean confirming the settings
            * and go back to the parent, dlg should simpley do a navigation
            */
            isSettingValue = FALSE;
        }
        if(currentMenuLevel > 0)
        {
          MenuDlg_Pop(me);
        }
        DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
    }
}

/* nodeLevel is the level you want to go */
static void MenuDlg_BackToParent(cMenuDlg * const me, eKeyEvent keyEvent)
{
    switch((*(me->ppCurrNode))->pageType)
    {
        case PAGE_NAVIGATION_TYPE:
        case PAGE_NAVIGATION_ACTION_TYPE:
        case PAGE_ACTION_TYPE:
        case PAGE_EXIT_TYPE:
        case PAGE_NAVIG_ACTION_WITH_DELAY_TYPE:
        {
            isSettingValue = FALSE;
            if(currentMenuLevel > 0)
            {
                MenuDlg_Pop(me);
            }
            DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
        }
        break;
        default:break;
    }
}


static void MenuDlg_IndicateController(cMenuDlg * const me,eKeyID keyId, eKeyEvent keyEvt)
{
    MenuDataUpdate *menuDataUpdateReq = Q_NEW(MenuDataUpdate,VIEW_DLG_REQ_SIG);
    menuDataUpdateReq->pPageNode = *(me->ppCurrNode);
    menuDataUpdateReq->keyId     = keyId;
    menuDataUpdateReq->keyEvt    = keyEvt;
    QACTIVE_POST(me->super_.delegateOwner, (QEvt*)menuDataUpdateReq, 0);
}

static void MenuDlg_Push(cMenuDlg * const me)
{
    /* Save current node because it is going to be the parent */
    parentStack[currentMenuLevel] = me->ppCurrNode;
    /* save the index */
    nodeIndexHistory[currentMenuLevel] = currNodeIndex;
    /* update to the next level */
    currentMenuLevel++;
}

static void MenuDlg_Pop(cMenuDlg * const me)
{
    currentMenuLevel--;
    me->ppCurrNode = parentStack[currentMenuLevel];
    currNodeIndex = nodeIndexHistory[currentMenuLevel];
}

static void MenuDlg_RefleshTick(cMenuDlg * const me, const uint16 tickTime)
{
    QTimeEvt_disarm(&me->timeEvt);
    QTimeEvt_armX(&me->timeEvt, tickTime, 0);
}

static void MenuDlg_BackToNode(cMenuDlg * const me, uint8 nodeLevel)
{
    isSettingValue = FALSE;
    while(nodeLevel < currentMenuLevel)
    {
        if(currentMenuLevel > 0)
        {
          MenuDlg_Pop(me);
        }
    }
    DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
}

static void MenuDlg_UpdateToNode(cMenuDlg * const me)
{
    me->ppCurrNode = (*(me->ppCurrNode))->ppChildren;
    /* update index */
    currNodeIndex = 0;
    if((*(me->ppCurrNode))->pageStatus != PAGE_STATUS_INVALID)
    {
        uint8 i = 0;
        for(i = 0; i < (*(me->ppCurrNode))->numOfBrother; i++)
        {
            
            if((*(me->ppCurrNode))->pageStatus == PAGE_ACTIVE)
            {
                break;
            }
            currNodeIndex++;
            ASSERT(currNodeIndex < (*(me->ppCurrNode))->numOfBrother);
            me->ppCurrNode++;
        }
    }
    DisplaySrv_SendString((*(me->ppCurrNode))->pPageText);
}

static void MenuDlg_UpdateNodeStatus(cMenuDlg * const me)
{
    if((*(me->ppCurrNode))->pageStatus != PAGE_STATUS_INVALID)
    {
        uint8 i = 0;
        tPageNode **ppNodeTemp;
        ppNodeTemp = me->ppCurrNode - currNodeIndex;//go back to the first node
        for(i = 0; i < (*(me->ppCurrNode))->numOfBrother; i++)
        {
            (*(ppNodeTemp))->pageStatus = PAGE_DEACTIVE;
            ppNodeTemp++;
        }
        (*(me->ppCurrNode))->pageStatus = PAGE_ACTIVE;//update the current node to active status
    }
}